//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 4972.23166)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.vo.ElectiveListConfigurationVoCollection;
import ims.admin.vo.domain.ElectiveListConfigurationVoAssembler;
import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.ClinicList;
import ims.RefMan.domain.ReferralAppointmentDetailsComponent;
import ims.RefMan.domain.ReferralStatusList;
import ims.RefMan.domain.base.impl.BaseNewElectiveListTCIErodDialogImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.SuitableForSurgeryAssessment;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.PatientElectiveListDetailsToSaveVo;
import ims.RefMan.vo.PatientElectiveListNotesVo;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.PatientElectiveListVo;
import ims.RefMan.vo.SuitableForSurgeryAssessmentForNewelectivelisttcieroddialogVo;
import ims.RefMan.vo.SuspensionDetailsForPatientElectiveListVoCollection;
import ims.RefMan.vo.TCIForReferralBookingVo;
import ims.RefMan.vo.domain.CatsReferralforElectiveListDetailsVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListDetailsToSaveVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListVoAssembler;
import ims.RefMan.vo.domain.SuitableForSurgeryAssessmentForNewelectivelisttcieroddialogVoAssembler;
import ims.RefMan.vo.domain.SuspensionDetailsForPatientElectiveListVoAssembler;
import ims.RefMan.vo.domain.TCIForReferralBookingVoAssembler;
import ims.RefMan.vo.lookups.ERODStatus;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.domain.ClinicalCoding;
import ims.clinical.domain.impl.ClinicalCodingImpl;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Procedure;
import ims.core.configuration.vo.ElectiveListConfigurationRefVo;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.impl.PatientCaseNotesImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.PatientCaseNoteRequestLiteVoCollection;
import ims.core.vo.PatientCaseNoteRequestVoCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientCaseNoteRequestLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.lookups.CaseNoteRequestCancellationReason;
import ims.core.vo.lookups.CaseNoteRequestStatus;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.QueueType;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.hl7adtout.domain.objects.ElectiveListMessageQueue;
import ims.ocrr.vo.lookups.OrderMessageStatus;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.PauseDetails;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class NewElectiveListTCIErodDialogImpl extends BaseNewElectiveListTCIErodDialogImpl
{

	private static final long serialVersionUID = 1L;

	public ims.RefMan.vo.CatsReferralforElectiveListDetailsVo getReferralDetails(ims.RefMan.vo.CatsReferralRefVo referralRef)
	{
		if(referralRef == null)
			throw new CodingRuntimeException("Cannot get Referral on null Ref");
		
		return CatsReferralforElectiveListDetailsVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, referralRef.getID_CatsReferral()));
	}

	public ElectiveListConfigurationVoCollection getElectiveListConfigForHCP(Integer hcpId, Integer serviceId)
	{
		if(hcpId == null)
			   throw new CodingRuntimeException("Cannot get ElectiveListConfig on null HCP id.");
		
		List list = getDomainFactory().find("select config from ElectiveListConfiguration as config left join config.service as serv left join config.hCPs as hcps left join hcps.hCP as hcp where (hcp.id = :hcpID) and (serv.id = :serviceID) and (config.isActive = 1)", 
				new String[] {"hcpID", "serviceID"}, new Object[] {hcpId, serviceId});
		
		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public ElectiveListConfigurationVoCollection getElectiveListConfigForService(Integer serviceId)
	{
		if(serviceId == null)
			   throw new CodingRuntimeException("Cannot get ElectiveListConfig on null Service id.");
		
		List list = getDomainFactory().find("select config from ElectiveListConfiguration as config left join config.service as serv where (config.isActive = 1) and (serv.id = :servID)", 
				new String[] {"servID"}, new Object[] {serviceId});
		
		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public ElectiveListConfigurationVoCollection getElectiveListsBySpecialty(Integer specialtyId)
	{
		if(specialtyId == null)
			   throw new CodingRuntimeException("Cannot get ElectiveListConfig on null Specialty id.");
		
		List list = getDomainFactory().find("select config from ElectiveListConfiguration as config left join config.service as serv left join serv.specialty as spec where (config.isActive = 1) and (spec.id = :servID)", 
				new String[] {"servID"}, new Object[] {specialtyId});
		
		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public ProcedureLiteVo getProcedureFromSuitableForSurgery(CareContextRefVo careContextRef)
	{
		if (careContextRef==null || careContextRef.getID_CareContext()==null)
		{
			throw new CodingRuntimeException("Cannot get SFSProcedure on null CareContextRefVo ");
		}
		
		List list = getDomainFactory().find("select procedure from SuitableForSurgeryAssessment as sfs left join sfs.procedure as patProcedure left join patProcedure.procedure as procedure where sfs.careContext.id = :CareContext and sfs.procedure is not null and (sfs.isRIE is null or sfs.isRIE = 0)", 
				new String[] {"CareContext"}, new Object[] {careContextRef.getID_CareContext()});
		
		if (list!=null && list.size()>0)
			return ProcedureLiteVoAssembler.create((Procedure) list.get(0));
		
		return null;
	}

	public ProcedureLiteVoCollection listProcedures(String name) throws DomainInterfaceException
	{
		ClinicalCoding impl = (ClinicalCoding) getDomainImpl(ClinicalCodingImpl.class);
		return impl.listProcLiteVo(name);
	}

	public PatientElectiveListDetailsToSaveVo getPatientElectiveList(PatientElectiveListRefVo electiveListRef)
	{
		if(electiveListRef == null)
			throw new CodingRuntimeException("Cannot get PatientElectiveList on null Specimen on null electiveListRef.");
		
		return PatientElectiveListDetailsToSaveVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, electiveListRef.getID_PatientElectiveList()));
	}

	public LocationLiteVoCollection listWards(String name, LocationRefVo locationRef)//WDEV-18388
	{
		if(locationRef == null)
			throw new CodingRuntimeException("Cannot get Location on null on null LocationRef.");
		
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveWardsForHospitalByNameLite(locationRef, name);//WDEV-18388
	}

	//wdev-20597		
	private void createPatientEvent(CatsReferral doCatsReferral, EventLiteVo hardCodedEvent) throws StaleObjectException
	{
		PatientPathwayJourney patientJBo = doCatsReferral != null ? doCatsReferral.getJourney() : null;

		if (patientJBo != null && hardCodedEvent != null)
		{				
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCatsReferral.getPatient()));
				patEvent.setEvent(hardCodedEvent);		
				patEvent.setEventDateTime(patientJBo.getCurrentClock() != null && patientJBo.getCurrentClock().getCurrentPause() != null && patientJBo.getCurrentClock().getCurrentPause().getPauseStop() != null ? new DateTime( patientJBo.getCurrentClock().getCurrentPause().getPauseStop()) : new DateTime());
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(patientJBo));
				
				HL7PathwayIf implPath = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				try
				{
					implPath.instantiatePatientEvent(patEvent);
				}
				catch (DomainInterfaceException e)
				{throw new DomainRuntimeException("Domain Error occured in save Event " + e.getMessage(), e);}
		}		
	}
	//wdev-20597	
	public PatientElectiveListDetailsToSaveVo save(PatientElectiveListDetailsToSaveVo patientElectiveList, Boolean bCancelledTCIForNonMedicalReasons) throws StaleObjectException
	{
		if (patientElectiveList == null)
		{
			throw new CodingRuntimeException("Cannot save null PatientElectiveListVo");
		}

		DomainFactory factory = getDomainFactory();
		
		PatientElectiveList domainPatElectiveList = PatientElectiveListDetailsToSaveVoAssembler.extractPatientElectiveList(factory, patientElectiveList);
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(CatsReferral.class, domainPatElectiveList.getReferral().getId());
		
		Boolean isDiagnostic = domainPatElectiveList != null && domainPatElectiveList.getElectiveListReason().getId() == -2621 ? true : false;
		Boolean saveReferral = false;
		
		//wdev-20597		
		if (domainPatElectiveList !=null
			&& domainPatElectiveList.getEROD() != null
			&& bCancelledTCIForNonMedicalReasons)
		{
			ReferralEROD doEROD = (ReferralEROD)domainPatElectiveList.getEROD();
			doEROD.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
			doEROD.setIsActive(Boolean.FALSE);

			if(domainPatElectiveList.getERODHistory() == null)
				domainPatElectiveList.setERODHistory(new java.util.ArrayList());
			domainPatElectiveList.getERODHistory().add(doEROD);
			
			domainPatElectiveList.setEROD(null);
			
			// Remove the erod from the cats referral erod collection based on a match in the current clock
			//add it to the history.
			ReferralEROD doMoveErod = null;
    		for(int i=0; i<doCatsReferral.getElectiveEROD().size(); i++)
    		{
    			if(doCatsReferral.getElectiveEROD().get(i) instanceof ReferralEROD)
    			{
    				if(domainPatElectiveList.getPathwayClock()!=null
    					&& ((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock() != null 
    					&& ((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock().getId().equals(domainPatElectiveList.getPathwayClock().getId()))
    				{
    					doMoveErod = (ReferralEROD) doCatsReferral.getElectiveEROD().get(i);
    					doCatsReferral.getElectiveEROD().remove(i);
    					break;
    				}
    			}
    		}
    		    		
    		if(doMoveErod != null)
    		{
    			doMoveErod.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
    		
    			if(doCatsReferral.getElectiveERODHistory() == null)
    				doCatsReferral.setElectiveERODHistory(new java.util.ArrayList());
    		
    			doCatsReferral.getElectiveERODHistory().add(doMoveErod);
    		}

			if(doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null && doCatsReferral.getJourney().getCurrentClock().getCurrentPause() != null)
			{
				PauseDetails currentPause = doCatsReferral.getJourney().getCurrentClock().getCurrentPause();
				
				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() != null)
				{
					for(int i=0; i<doCatsReferral.getJourney().getCurrentClock().getPauseDetails().size(); i++)
					{
						PauseDetails pause = (PauseDetails) doCatsReferral.getJourney().getCurrentClock().getPauseDetails().get(i);
						if(currentPause.equals(pause) && Boolean.TRUE.equals(pause.isActive()))
						{
							doCatsReferral.getJourney().getCurrentClock().getPauseDetails().remove(i);
							break;
						}
					}
				}
				
				currentPause.setActive(false);
				doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add(currentPause);	
				
				if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && doCatsReferral != null && doCatsReferral.getJourney() != null)			
    			{
    				EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.PATHWAYUNPAUSED.getID());
					createPatientEvent(doCatsReferral, hardCodedEvent);	    			
    			}	
			}
		
			saveReferral = true;
		}
		//wdev-20597		

		if(domainPatElectiveList != null  && domainPatElectiveList.getEROD() != null)// && !bCancelledTCIForNonMedicalReasons)
		{
			if (!isDiagnostic && domainPatElectiveList.getEROD().getId() == null)
			{
    			if(doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null)
    			{
    				PauseDetails doPauseDetails = new PauseDetails();
    				doPauseDetails.setPauseStart(domainPatElectiveList.getEROD().getERODDate1());
    				// WDEV-20704 if PatAvailDate set then pause stop to be populated with it
					doPauseDetails.setPauseStop(domainPatElectiveList.getEROD().getPatAvailFromDate());
					doPauseDetails.setActive(true);
    				
    				doCatsReferral.getJourney().getCurrentClock().setCurrentPause(doPauseDetails);
    				
    				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() == null)
    					doCatsReferral.getJourney().getCurrentClock().setPauseDetails(new java.util.ArrayList());
    				
    				doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add(doPauseDetails);
    				
    				//WDEV-19772 
        			if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && doCatsReferral != null && doCatsReferral.getJourney() != null)			
        			{
        				EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.PATHWAYPAUSED.getID());
    					createPatientEvent(doCatsReferral, hardCodedEvent, domainPatElectiveList.getEROD().getERODDate1());	    			
        			}
    			}   			
			}
			
			ReferralEROD doErod = setSequenceToeErod(domainPatElectiveList.getEROD(), doCatsReferral.getElectiveEROD());
			doCatsReferral.getElectiveEROD().add(doErod);
							
			saveReferral = true;
		}
		
		factory.save(domainPatElectiveList);
		
		if(domainPatElectiveList != null && !isDiagnostic && domainPatElectiveList.getTCIDetails() != null && domainPatElectiveList.getTCIDetails().getTCIDate() != null)
		{
			if(doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null && doCatsReferral.getJourney().getCurrentClock().getCurrentPause() != null)
			{
				PauseDetails currentPause = doCatsReferral.getJourney().getCurrentClock().getCurrentPause();
				
				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() != null)
				{
					for(int i=0; i<doCatsReferral.getJourney().getCurrentClock().getPauseDetails().size(); i++)
					{
						PauseDetails pause = (PauseDetails) doCatsReferral.getJourney().getCurrentClock().getPauseDetails().get(i);
						if(currentPause.equals(pause) && Boolean.TRUE.equals(pause.isActive()))
						{
							doCatsReferral.getJourney().getCurrentClock().getPauseDetails().remove(i);
							break;
						}
					}
				}
				
				currentPause.setPauseStop(domainPatElectiveList.getTCIDetails().getTCIDate());
				
				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() == null)
					doCatsReferral.getJourney().getCurrentClock().setPauseDetails(new java.util.ArrayList());
				
				doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add(currentPause);	
			}
			
			saveReferral = true;
		}
		
		if (saveReferral)
			factory.save(doCatsReferral);

		/* was moved in the logic as per WDEV-20793
		//WDEV-19704 Trigger HL7 message
		if(domainPatElectiveList != null)
		{
			PatientElectiveListVo patientElectList = PatientElectiveListVoAssembler.create(domainPatElectiveList);
			triggerElectiveListEvent(patientElectList);
		}
		*/
		
		return PatientElectiveListDetailsToSaveVoAssembler.create(domainPatElectiveList);
	}

	//WDEV-19772 
	private void createPatientEvent(CatsReferral doCatsReferral, EventLiteVo hardCodedEvent, java.util.Date erodStartDate) throws StaleObjectException
	{
		PatientPathwayJourney patientJBo = doCatsReferral != null ? doCatsReferral.getJourney() : null;

		if (patientJBo != null && hardCodedEvent != null)
		{				
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCatsReferral.getPatient()));
				patEvent.setEvent(hardCodedEvent);
				patEvent.setEventDateTime(erodStartDate != null ? new DateTime(erodStartDate) : new DateTime());
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(patientJBo));
				
				HL7PathwayIf implPath = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				try
				{
					implPath.instantiatePatientEvent(patEvent);
				}
				catch (DomainInterfaceException e)
				{throw new DomainRuntimeException("Domain Error occured in save Event " + e.getMessage(), e);}
		}		
	}

	//WDEV-19772 
	private EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[] {"eventID", "statusID"},new Object[] {event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID()});
		
		if (list == null || list.size() == 0)
			return null;
		
		return EventLiteVoAssembler.create((Event)list.get(0));	
	}
	
	//WDEV-19704 Create message queue trigger record(s) for each provider system for A05 HL7 message 
	public void triggerElectiveListEvent(PatientElectiveListRefVo patientElectiveList) throws StaleObjectException
	{

		if (patientElectiveList == null)
			return;
		
		PatientElectiveListVo patientElectList = PatientElectiveListVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
		
		if(patientElectList != null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.ELECTIVELIST.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				ElectiveListMessageQueue messageQueue = new ElectiveListMessageQueue();
				messageQueue.setPatientElectiveList((PatientElectiveList)factory.getDomainObject(patientElectList));
				messageQueue.setProviderSystem(providerSystem);
				messageQueue.setWasProcessed(Boolean.FALSE);
				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				messageQueue.setQueueType(getDomLookup(QueueType.ELECTIVELIST));

				if (patientElectList.getElectiveListStatusIsNotNull()
						&& patientElectList.getElectiveListStatus().getElectiveListStatusIsNotNull())
				{
					if ((WaitingListStatus.TCI_GIVEN.getId() == patientElectList.getElectiveListStatus().getElectiveListStatus().getID()
							//WDEV-20795 Ensure that A05 is created when elective list is SUSPENDED and TCI is created!
							|| WaitingListStatus.SUSPENDED.getId() == patientElectList.getElectiveListStatus().getElectiveListStatus().getID())
						&& patientElectList.getTCIDetailsIsNotNull()
						&& patientElectList.getTCIDetails().getTCIDateIsNotNull())
					{
						messageQueue.setMsgType(getDomLookup(MsgEventType.A05));
					}
					if ((WaitingListStatus.REQUIRES_TCI.getId() == patientElectList.getElectiveListStatus().getElectiveListStatus().getID())
							//WDEV-20795 Create A38 when elective list status is SUSPENDED and TCI is being cancelled
							|| WaitingListStatus.SUSPENDED.getId() == patientElectList.getElectiveListStatus().getElectiveListStatus().getID())
					{
						Boolean unProcessedCancelledTCI = checkForUnprocessedCancelledTCIForPatElectList(patientElectList);
						if(unProcessedCancelledTCI)
						{
							messageQueue.setMsgType(getDomLookup(MsgEventType.A38));
						}
					}
				}
				
				if (messageQueue.getMsgType() != null)
				{
					factory.save(messageQueue);
				}
			}
		} //WDEV-20680

	}
	

	//WDEV-20680
	private Boolean checkForUnprocessedCancelledTCIForPatElectList(PatientElectiveListVo patientElectList)
	{
		DomainFactory factory = getDomainFactory();
		
		PatientElectiveList patReferral = (PatientElectiveList) factory.getDomainObject(patientElectList);

		// Following check probably not needed..
		if(patReferral.getTCIDetails() != null
				&& patReferral.getTCIDetails().getTCIDate() != null)
		{
			// An active TCI exists for the referral
			return false;
		}
		
		// Check to see if a cancelled TCI exists for the referral
		java.util.List<TCIForPatientElectiveList> histPatElectListTCI = patReferral.getTCIHistory();
		
		if(histPatElectListTCI == null)
			return false;
		
		// Loop thru historic TCI(s) and check for unprocessed row
		for (TCIForPatientElectiveList tciDetail : histPatElectListTCI)
		{
			if (tciDetail.isCancelMsgProcessed() == null
					|| tciDetail.isCancelMsgProcessed()  == Boolean.FALSE)
			{
				return true;
			}
		}			
		return false;
	} //WDEV-20680
	

	private ReferralEROD setSequenceToeErod(ReferralEROD erod, List theatreEROD)
	{
		if(erod == null)
			return null;
		
		if(erod.getId() != null)
			return erod;
		
		int sequence = 0;
		
		if(theatreEROD != null)
		{
			for(int i=0; i<theatreEROD.size(); i++)
			{
				if(theatreEROD.get(i) instanceof ReferralEROD)
				{
					ReferralEROD savedErod = (ReferralEROD) theatreEROD.get(i);
					
					if(savedErod.getSequence() != null && sequence < savedErod.getSequence())
						sequence = savedErod.getSequence();
				}
			}
		}
		
		sequence++;
		
		erod.setSequence(sequence);
		
		return erod;
	}

	//wdev-18341
	public Boolean isFitForSurgery(CareContextRefVo carecontextRef)
	{
		if( carecontextRef == null )
			throw new CodingRuntimeException("CareContextRefVo cannot be null");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer();
		hql.append("select count (f1_1.id) from FitForSurgeryAssesment as f1_1 left join f1_1.careContext as c1_1 where	(c1_1.id =:careContext  and (f1_1.isRIE = 0 or f1_1.isRIE is null)) ");

		List <?> count = factory.find(hql.toString(), new String[] { "careContext" }, new Object[] { carecontextRef.getID_CareContext()});
		if( count != null && count.size() > 0 )
			if( (Long)count.get(0) > 0)
				return true;
			
		
		
		return false;

		
	}

	public Boolean isStaleNote(PatientElectiveListNotesVo patientElectiveListNote)
	{
		if(patientElectiveListNote == null)
			return false;
		
		DomainFactory factory = getDomainFactory();
		
		List<?> refNotes = factory.find("select note.id from NotesForPatientElectiveList as note where note.id = :PatNoteID and note.version > :PatNoteVersion", new String[] {"PatNoteID", "PatNoteVersion"}, new Object[] {patientElectiveListNote.getID_NotesForPatientElectiveList(), patientElectiveListNote.getVersion_NotesForPatientElectiveList()});
		
		if(refNotes != null && refNotes.size() > 0)
			return true;
		
		return false;
	}

	//WDEV-18388
	public LocationLiteVoCollection listHospitals(String name)
	{
		DomainFactory factory = getDomainFactory();
		
		List locations;

		String hql = " from Location loc where loc.isActive = 1 and loc.type = :locType ";
		StringBuffer condStr = new StringBuffer();
		String andStr = " and ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		markers.add("locType");
		values.add(getDomLookup(LocationType.HOSP));
		
		if (name != null)
		{
			condStr.append(andStr + " loc.upperName like :name");
			markers.add("name");
			values.add(name.toUpperCase() + "%");
			andStr = " and ";
		}
		
		condStr.append(andStr + "loc.isVirtual =:isVirtual");
		markers.add("isVirtual");
		values.add(Boolean.FALSE);

		hql += condStr.toString();
		hql += " ORDER BY loc.upperName";					
		locations = factory.find(hql, markers, values);
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
	}

	public ElectiveListConfigurationVoCollection getElectiveList()
	{
		List list = getDomainFactory().find("select config from ElectiveListConfiguration as config where (config.isActive = 1) order by config.waitingListName asc ");
		
		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public Booking_AppointmentVo getBookingAppointment(Booking_AppointmentRefVo appt)
	{
		DomainFactory factory = getDomainFactory();
		Booking_Appointment apptBo = (Booking_Appointment) factory.getDomainObject(Booking_Appointment.class, appt.getID_Booking_Appointment());
		return Booking_AppointmentVoAssembler.create(apptBo);
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
		return impl.cancelAppt(appt, requestType, requestSource);
	}

	//WDEV-18519
	public SuspensionDetailsForPatientElectiveListVoCollection getSuspensionsForPatientElectiveList(PatientElectiveListRefVo patientElectiveListRef)
	{
		if(patientElectiveListRef == null || patientElectiveListRef.getID_PatientElectiveList() == null)
			throw new CodingRuntimeException("Cannot get suspensions for a null patientElectiveListRef reference or a patientElectiveListRef reference with null id");
		
		String hql = "select susp from PatientElectiveList as pel left join pel.suspensions as susp where pel.id = :pelID" + " order by susp.startDate desc"; 
	
		List<?> suspensionDetailsDOs = getDomainFactory().find(hql, new String[] {"pelID"}, new Object[] {patientElectiveListRef.getID_PatientElectiveList()});
		
		return SuspensionDetailsForPatientElectiveListVoAssembler.createSuspensionDetailsForPatientElectiveListVoCollectionFromSuspensionDetailsForPatientElectiveList(suspensionDetailsDOs);
		
	}

	public Boolean hasNonDiagnosticPatientElectiveList(CatsReferralRefVo catsReferral)
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return false;
		
		DomainFactory factory = getDomainFactory();
		String query = "select count(pel.id) from PatientElectiveList as pel left join pel.electiveListStatus as els left join els.electiveListStatus as status left join pel.referral as cats left join cats.journey as j left join j.currentClock as cc left join pel.pathwayClock as pc where cats.id = :CatsReferral and cc.id = pc.id and status.id not in (" + WaitingListStatus.REMOVED.getID() + ")";
		
		Object[] count = factory.find(query, new String[] {"CatsReferral"}, new Object[] {catsReferral.getID_CatsReferral()}).toArray();
		
		if(count != null && count.length > 0)
			return ((Long) count[0]).intValue() > 0;
		
		return false;
	}

	//wdev-18673
	public SuitableForSurgeryAssessmentForNewelectivelisttcieroddialogVo getSuitableForSurgeryAssessmentByCareContext(CareContextRefVo careContextRef)
	{
		if( careContextRef == null || careContextRef.getID_CareContext() == null)
			throw new CodingRuntimeException("careContext is null or id not provided in method getSuitableForSurgeryAssessmentByCareContext");

		List assessments = getDomainFactory().find("from SuitableForSurgeryAssessment sfsa where sfsa.careContext.id = " + careContextRef.getID_CareContext() + " and (sfsa.isRIE is null or sfsa.isRIE = false) order by sfsa.systemInformation.creationDateTime desc "); // WDEV-8144
																																																																		// fix
		if( assessments != null && assessments.size() > 0)
			return SuitableForSurgeryAssessmentForNewelectivelisttcieroddialogVoAssembler.create((SuitableForSurgeryAssessment) assessments.get(0));

		return null;
	}

	// WDEV-18514 
	public Boolean hasNonDiagnosticPatientElectiveListforReferral(CatsReferralRefVo catsReferral)
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return false;
		
		DomainFactory factory = getDomainFactory();
		String query = "select count(pel.id) from PatientElectiveList as pel left join pel.electiveListStatus as els left join els.electiveListStatus as status left join pel.referral as cats left join pel.electiveListReason as pelr where cats.id = :CatsReferral and pelr.id not in (" + ElectiveListReason.DIAGNOSTIC.getID() + ") and status.id not in (" + WaitingListStatus.REMOVED.getID() + ")";
		
		Object[] count = factory.find(query, new String[] {"CatsReferral"}, new Object[] {catsReferral.getID_CatsReferral()}).toArray();
		
		if(count != null && count.length > 0)
			return ((Long) count[0]).intValue() > 0;
		
		return false;
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral,null);		
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		ReferralAppointmentDetailsComponent impl = (ReferralAppointmentDetailsComponent) getDomainImpl(ReferralAppointmentDetailsComponentImpl.class);
		impl.updateCatsReferralCancelStatus(catsReferral);		
	}

	public CatsReferralListVo getCatsReferral(CatsReferralRefVo voReferralRef)
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		return impl.getCatsReferral(voReferralRef);
	}

	public void cancelCaseNoteRequests(Integer tciId) throws StaleObjectException
	{
		PatientCaseNoteRequestLiteVoCollection requestsForCancellation = getLinkedCaseNoteOpenRequests(tciId);
		
		if (requestsForCancellation == null || requestsForCancellation.size() == 0)
			return;
		
		Object mos = getMosUser();
		
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		
		for (int i = 0; i < requestsForCancellation.size(); i++)
		{
			impl.cancelRequest(requestsForCancellation.get(i), (MemberOfStaffRefVo) mos, CaseNoteRequestCancellationReason.TCI_CANCELLED); //WDEV-20989
		}
		
	}
	
	private PatientCaseNoteRequestLiteVoCollection getLinkedCaseNoteOpenRequests(Integer tciId)
	{
		if(tciId == null)
			   return null;
		
		List<?> list = getDomainFactory().find("select req from PatientCaseNoteRequest as req left join req.tCIDetail as tci left join req.requestStatus as status " +
				"where (tci.id = :tciID and status.id = :requestStatusID)", new String[] {"tciID", "requestStatusID"}, new Object[] {tciId, CaseNoteRequestStatus.OPEN.getID()});
		
		return PatientCaseNoteRequestLiteVoAssembler.createPatientCaseNoteRequestLiteVoCollectionFromPatientCaseNoteRequest(list);
	}

	public void createCaseNoteRequests(Integer tciId, PatientShort patient, LocationLiteVo caseNoteLocation) //WDEV-20064
	{
		if (tciId == null || caseNoteLocation == null) //WDEV-20064
			return;
		
		TCIForPatientElectiveList domTciDetails = (TCIForPatientElectiveList) getDomainFactory().getDomainObject(TCIForPatientElectiveList.class, tciId);
		
		if (domTciDetails == null)
			return;

		TCIForReferralBookingVo tci = TCIForReferralBookingVoAssembler.create(domTciDetails);
		
		if (caseNoteLocation != null  && tci.getTCIDate() != null)
		{
			if (tci.getTCITime() != null)
			{
				if (tci.getTCIDate().isGreaterThan(new Date()) || (tci.getTCIDate().equals(new Date()) && tci.getTCITime().isGreaterOrEqualThan(new Time())))
				{
					saveAutomatedCaseNoteRequests(patient, tci, caseNoteLocation);
				}
			}
			else //TCI Time not entered 
			{
				if (tci.getTCIDate().isGreaterOrEqualThan(new Date()))
				{
					saveAutomatedCaseNoteRequests(patient, tci, caseNoteLocation);
				}
			}
		}
		
	}
	
	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequests(PatientShort patient, TCIForReferralBookingVo tci, LocationLiteVo location) //WDEV-20064
	{
		PatientCaseNoteRequestVoCollection savedCaseNotesRequests = null;
		
		DateTime dateTimeRequired = new DateTime();
		
		dateTimeRequired.setDateTime(tci.getTCIDate(), tci.getTCITime());
		
		PatientLiteVo patientLite = new PatientLiteVo(patient.getID_Patient(),patient.getVersion_Patient());
		
		try
		{
			savedCaseNotesRequests = saveAutomatedCaseNoteRequest(patientLite, (MemberOfStaffLiteVo) getMosUser(), location, dateTimeRequired, tci);
		}
		catch (StaleObjectException e)
		{
			e.printStackTrace();
		}
		catch (UniqueKeyViolationException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (DomainInterfaceException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return savedCaseNotesRequests;
	}

	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequest(PatientLiteVo patient, MemberOfStaffLiteVo mos, LocationLiteVo location, DateTime requiredByDate, TCIForReferralBookingVo tci) throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.saveAutomaticCaseNoteRequests(patient, mos, location, requiredByDate, null, tci);
	}

	//WDEV-20065
	public LocationLiteVoCollection listHospitalsByElectiveList(ElectiveListConfigurationRefVo electiveListConfig, String name)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = " select loc from ElectiveListConfiguration as electiveListConf left join electiveListConf.listLocations as listLocations left join listLocations.listLocation as loc where electiveListConf.id = :electiveList and loc.isActive = 1 and loc.type = :locType ";
		StringBuffer condStr = new StringBuffer();
		String andStr = " and ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		
		markers.add("electiveList");
		values.add(electiveListConfig.getID_ElectiveListConfiguration());
		
		markers.add("locType");
		values.add(getDomLookup(LocationType.HOSP));
		
		if (name != null)
		{
			condStr.append(andStr + " loc.upperName like :name");
			markers.add("name");
			values.add(name.toUpperCase() + "%");
			andStr = " and ";
		}
		
		condStr.append(andStr + "loc.isVirtual =:isVirtual");
		markers.add("isVirtual");
		values.add(Boolean.FALSE);

		hql += condStr.toString();
		hql += " ORDER BY loc.upperName";					
		List locations = factory.find(hql, markers, values);
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
	}

	
	
}
