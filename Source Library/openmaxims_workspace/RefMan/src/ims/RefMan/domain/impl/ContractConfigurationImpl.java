//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Calin Perebiceanu using IMS Development Environment (version 1.80 build 4027.29767)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;

import ims.RefMan.domain.base.impl.BaseContractConfigurationImpl;
import ims.RefMan.vo.ContractConfigShortVo;
import ims.RefMan.vo.ContractConfigShortVoCollection;
import ims.RefMan.vo.ContractServiceLocationsConfigVo;
import ims.RefMan.vo.domain.ContractConfigShortVoAssembler;
import ims.RefMan.vo.domain.ContractConfigVoAssembler;
import ims.RefMan.vo.domain.ContractServiceLocationsConfigVoAssembler;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.domain.objects.ContractConfig;
import ims.core.configuration.domain.objects.ContractServiceLocationsConfig;
import ims.core.configuration.vo.ContractConfigRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.domain.OrganisationLiteVoAssembler;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.ReferralManagementContractType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.pathways.helper.IContractConfigurationHelper;

import java.util.ArrayList;
import java.util.List;

public class ContractConfigurationImpl extends BaseContractConfigurationImpl implements IContractConfigurationHelper
{

	private static final long serialVersionUID = 1L;

	public ims.core.vo.OrganisationLiteVoCollection listActiveOrganisations()
	{
		String hql =  "from Organisation as org where (org.type.id not in (" +
				getInvalidTypes()+
				") and org.isActive = 1 and org.isRIE is null) order by org.upperName"; //WDEV-20219 upper(org.upperName)
		
		List<?> dos = getDomainFactory().find(hql);
		
		if (dos == null || dos.size()==0)
			return null;
		return OrganisationLiteVoAssembler.createOrganisationLiteVoCollectionFromOrganisation(dos);
	}

	private String getInvalidTypes() 
	{
		return Integer.toString(OrganisationType.GPP.getID())+","+Integer.toString(OrganisationType.SUPPLIER.getID());
	}


	public ContractConfigShortVoCollection listContracts(String name, OrganisationRefVo organisation, ReferralManagementContractType contractType, String contractId, PreActiveActiveInactiveStatus status, Boolean diagnostic, Boolean nonDiagnostic) 
	{
		if ((name  == null || name.length() == 0) && (organisation==null || !organisation.getID_OrganisationIsNotNull()) && (contractId==null || contractId.length()==0) && status==null && Boolean.FALSE.equals(diagnostic) && Boolean.FALSE.equals(nonDiagnostic) && contractType == null) //wdev-12676
		{
			throw new DomainRuntimeException("No search criteria specified");
		}
		
		StringBuilder hqlBuilder = new StringBuilder("from ContractConfig as cc where ( ");
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		Boolean flagOpenParenthesiz = Boolean.FALSE;
		String and = "";
		if (contractId !=null && contractId.length()>0)
		{
			hqlBuilder.append("cc.contractId like :cID ");
			and = "and ";
			paramNames.add("cID");
			paramValues.add("%"+contractId+"%");
		}
		
		if (organisation!=null && organisation.getID_OrganisationIsNotNull())
		{
			hqlBuilder.append(and);
			hqlBuilder.append(" cc.contractOrganisation.id = :cOrg ");
			and = "and ";
			paramNames.add("cOrg");
			paramValues.add(organisation.getID_Organisation());
		}
		
		if (contractType != null)
		{
			hqlBuilder.append(and);
			hqlBuilder.append(" cc.contractType.id = :cType ");
			and = "and ";
			paramNames.add("cType");
			paramValues.add(contractType.getID());
		}
		
		if (name!=null && name.length()>0)
		{
			hqlBuilder.append(and);
			hqlBuilder.append(" cc.contractName like :cName ");
			and = "and ";
			paramNames.add("cName");
			paramValues.add("%"+name+"%");
		}
		if (status!=null)
		{
			hqlBuilder.append(and);
			hqlBuilder.append(" cc.status.id = :status ");
			and = "and ";
			paramNames.add("status");
			paramValues.add(status.getID());
		}
		//wdev-12676
		
		if(diagnostic != null && diagnostic.equals(Boolean.TRUE))
		{
			hqlBuilder.append(and);
			hqlBuilder.append("(");
			flagOpenParenthesiz = Boolean.TRUE;
			hqlBuilder.append(" cc.contractType.id = :diagnostic ");
			and = "or ";
			paramNames.add("diagnostic");
			paramValues.add(ReferralManagementContractType.DIAGNOSTIC.getID());
		}
		//wdev-12676
		if(nonDiagnostic != null && nonDiagnostic.equals(Boolean.TRUE))
		{
			hqlBuilder.append(and);
			if(flagOpenParenthesiz.equals(Boolean.FALSE))
			{
				hqlBuilder.append("(");
				flagOpenParenthesiz = Boolean.TRUE;
			}
				
			hqlBuilder.append(" cc.contractType.id = :nondiagnostic ");
			
			paramNames.add("nondiagnostic");
			paramValues.add(ReferralManagementContractType.NONDIAGNOSTIC.getID());
		}
		if(flagOpenParenthesiz.equals(Boolean.TRUE))	//wdev-12676
			hqlBuilder.append(" )");
		

		hqlBuilder.append(") order by upper(cc.contractId)");
		
		List<?> dos = getDomainFactory().find(hqlBuilder.toString(),paramNames,paramValues);
		
		if (dos == null || dos.size() == 0)
			return null;
		
		return ContractConfigShortVoAssembler.createContractConfigShortVoCollectionFromContractConfig(dos);
	}

	public ims.RefMan.vo.ContractConfigVo getContract(ims.core.configuration.vo.ContractConfigRefVo contractRef)
	{
		if (!contractRef.getID_ContractConfigIsNotNull())
		{
			throw new DomainRuntimeException("Invalid contract ref provided");
		}
		return ContractConfigVoAssembler.create((ContractConfig) getDomainFactory().getDomainObject(ContractConfig.class, contractRef.getID_ContractConfig()));
	}

	public ims.RefMan.vo.ContractConfigVo save(ims.RefMan.vo.ContractConfigVo contract) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (!contract.isValidated())
		{
			throw new DomainRuntimeException("Trying to save a record that hasn't been validated");
		}
		DomainFactory df = getDomainFactory();
		ContractConfig dObj = ContractConfigVoAssembler.extractContractConfig(df, contract);
		df.save(dObj);
		return ContractConfigVoAssembler.create(dObj);
	}

	//wdev-13733
	public Integer countForContractConfig(Integer contractConfigId,	Integer serviceId, Integer locationId, String contractId) 
	{
		DomainFactory factory = getDomainFactory();
		
		List contract =   factory.find("select c1_1.id, count (c1_1.id) from ContractConfig as c1_1 left join c1_1.serviceLocations as c2_1 where (c1_1.id <> :ContractConfID and c2_1.contractId = :ContractId and c2_1.location.id = :LocationId and c2_1.service.id = :ServiceId) group by c1_1.id having count (c1_1.id) > 0",
				new String[]{"ContractConfID","ContractId","LocationId","ServiceId" }, new Object[]{contractConfigId,contractId,locationId,serviceId});
		if(contract != null && contract.size() > 0)
		{
			Object[] value = (Object[]) contract.get(0);
			
			return (Integer) value[0];
		}
		return null;
	}

	//wdev-13733
	public ContractConfigShortVo getContractConfig(Integer contractConfigId) 
	{
		if (contractConfigId == null)
		{
			throw new DomainRuntimeException("Invalid contract ref provided");
		}
		return ContractConfigShortVoAssembler.create((ContractConfig) getDomainFactory().getDomainObject(ContractConfig.class, contractConfigId));
	}

	//wdev-18409
	public Boolean existsCCGPCTPCCodesRecords(String cCGCode)
	{
		if( cCGCode == null )
			return null;
		DomainFactory factory = getDomainFactory();
		
		List contract =   factory.find("select count (c1_1.id) from CCGPCTPCCodes as c1_1 where	( c1_1.cCGCode = :ccgCode) ",	new String[]{"ccgCode" }, new Object[]{cCGCode});
		if(contract != null && contract.size() > 0)
		{
			Long value = (Long) contract.get(0);
			if( value > 0)
				return true;
			else
				return false;
		}
		return null;
		
				
	}

	//wdev-18049
	public Boolean countContractsWithTheSameServiceForTheSaneCCGCode(ContractConfigRefVo contractId, ServiceRefVo serviceRef, String cCGCode)
	{
		if( cCGCode == null || cCGCode == "")
			return null;
		
		StringBuilder hqlBuilder = new StringBuilder("select c1_1.id, count (c1_1.id) from ContractConfig as c1_1 left join c1_1.serviceLocations as c2_1 left join c2_1.service as s1_1 left join c1_1.cCGsForContract as c3_1 where  ( ");
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String and = "";
		if( contractId != null && contractId.getID_ContractConfigIsNotNull() )
		{
			hqlBuilder.append("c1_1.id <> :cID ");
			and = "and ";
			paramNames.add("cID");
			paramValues.add(contractId.getID_ContractConfig());
		}
		if( serviceRef !=null && serviceRef.getID_ServiceIsNotNull())
		{
			hqlBuilder.append(and);
			hqlBuilder.append("s1_1.id = :service ");
			and = "and ";
			paramNames.add("service");
			paramValues.add(serviceRef.getID_Service());
		}
		if( cCGCode != null )
		{
			hqlBuilder.append(and);
			hqlBuilder.append(" c3_1.cCGCode like :ccgCode and c3_1.isActive = 1");
			and = "and ";
			paramNames.add("ccgCode");
			paramValues.add("%"+cCGCode+"%");
		}
		
		hqlBuilder.append(") group by c1_1.id");
		
		List<?> dos = getDomainFactory().find(hqlBuilder.toString(),paramNames,paramValues);
		if( dos != null && dos.size() > 0)
		{
			Object[] value = (Object[]) dos.get(0);
			Integer nrcontracts = (Integer) value[0];
			if( nrcontracts > 0)
				return true;
			else
				return false;
		}
		
		return null;
	}

	//WDEV-20181
	public ContractServiceLocationsConfigVo getContractServiceLocConfByContractService(ContractConfigRefVo contractRef, ServiceRefVo serviceRef)
	{
		if (contractRef==null || serviceRef==null)
		{
			return null;
		}
		
		String sql="select serviceLoc from ContractConfig as contractConf left join contractConf.serviceLocations as serviceLoc where contractConf.id = :ContractID and serviceLoc.service.id = :ServiceID" ;
		
		List <?>  listServiceLoc=getDomainFactory().find(sql,new String[]{"ContractID", "ServiceID"}, new Object[]{contractRef.getID_ContractConfig(), serviceRef.getID_Service()}) ;
		
		if (listServiceLoc!=null && listServiceLoc.size()>0)
			return ContractServiceLocationsConfigVoAssembler.create((ContractServiceLocationsConfig)listServiceLoc.get(0));
		
		return null;
	}

}
