//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.65 build 3175.20077)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.PatientSearchConfiguration;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.domain.impl.PatientSearchConfigurationImpl;
import ims.admin.vo.CaseNoteTrackingConfigVo;
import ims.admin.vo.PDSConfigurationVo;
import ims.admin.vo.domain.CaseNoteTrackingConfigVoAssembler;
import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.ClinicList;
import ims.RefMan.domain.ContractConfiguration;
import ims.RefMan.domain.base.impl.BaseBookAppointmentImpl;
import ims.RefMan.domain.objects.CATSReferralStatus;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.OrderInvAppt;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.ContractServiceLocationsConfigVo;
import ims.RefMan.vo.OrderInvApptVo;
import ims.RefMan.vo.OrderInvApptVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.ReferralBookingVo;
import ims.RefMan.vo.ReferralERODForBookAppointmentVoCollection;
import ims.RefMan.vo.ReferralERODVo;
import ims.RefMan.vo.ReferralLetterDetailsBookingVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.OrderInvApptVoAssembler;
import ims.RefMan.vo.domain.ReferralERODForBookAppointmentVoAssembler;
import ims.RefMan.vo.domain.ReferralERODVoAssembler;
import ims.RefMan.vo.domain.ReferralLetterDetailsBookingVoAssembler;
import ims.RefMan.vo.domain.TCIForReferralBookingVoAssembler;
import ims.RefMan.vo.domain.TriageOutcomeForBookAppointmentVoAssembler;
import ims.RefMan.vo.lookups.AcceptedActionsRequired;
import ims.RefMan.vo.lookups.AdditionalInvestigationAppointmentsStatus;
import ims.RefMan.vo.lookups.ICABReferralStatus;
import ims.RefMan.vo.lookups.LookupHelper;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.RefMan.vo.lookups.ReferralUrgency;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareSpell;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.domain.objects.ICABReferral;
import ims.core.admin.domain.objects.Referral;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.ReferralRefVo;
import ims.core.clinical.domain.objects.NonUniqueTaxonomyMap;
import ims.core.clinical.domain.objects.ReferralLetterDetails;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ServiceFunctionRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.clinical.vo.ServiceRefVoCollection;
import ims.core.configuration.domain.objects.CaseNoteTrackingConfig;
import ims.core.configuration.domain.objects.ContractConfig;
import ims.core.configuration.domain.objects.ContractServiceLocationsConfig;
import ims.core.configuration.vo.ContractConfigRefVo;
import ims.core.domain.PDSDemographics;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.impl.PDSDemographicsImpl;
import ims.core.domain.impl.PatientCaseNotesImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.LocationRefVoCollection;
import ims.core.vo.ActivityVo;
import ims.core.vo.HcpFilter;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MissingMappingVoCollection;
import ims.core.vo.Patient;
import ims.core.vo.PatientCaseNoteRequestVoCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceFunctionLiteVoCollection;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceShortVoCollection;
import ims.core.vo.domain.ActivitySchedVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.ServiceFunctionLiteVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PatientStatus;//http://jira/browse/WDEV-23441
import ims.core.vo.lookups.PollStatus;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.ReferralManagementContractType;
import ims.core.vo.lookups.ReferralType;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.SourceOfReferral;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.YesNo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupMapping;
import ims.framework.enumerations.SortOrder;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IAppRole;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.Time;
import ims.icp.vo.PatientICPFullVo;
import ims.icp.vo.PatientICPFullVoCollection;
import ims.icp.vo.domain.PatientICPFullVoAssembler;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.domain.SelectandOrder;
import ims.ocrr.domain.impl.SelectandOrderImpl;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.vo.OrderInvestigationBookingVo;
import ims.ocrr.vo.domain.OrderInvestigationBookingVoAssembler;
import ims.ocrr.vo.lookups.AuthorisationOrderStatus;
import ims.ocrr.vo.lookups.OcsDisplayFlag;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PathwaysRTTClockImpact;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.PathwayClockRefVo;
import ims.pathways.vo.PathwayClockVo;
import ims.pathways.vo.PathwayClockVoCollection;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.RTTStatusEventMapRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientEventVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.RTTClockImpactSource;
import ims.pathways.vo.lookups.RTTClockState;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.ExclusionDates;
import ims.scheduling.domain.OCSExternalEvents;
import ims.scheduling.domain.Profiles;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.SessionDetailsEdit;
import ims.scheduling.domain.SessionManagement;
import ims.scheduling.domain.impl.DirectoryOfServiceAdminImpl;
import ims.scheduling.domain.impl.ExclusionDatesImpl;
import ims.scheduling.domain.impl.OCSExternalEventsImpl;
import ims.scheduling.domain.impl.ProfilesImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.impl.SessionManagementImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.DirectoryofService;
import ims.scheduling.domain.objects.Sch_Booking;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionSlotStatus;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.BookingAppointmentForLinkedAppointmentsVo;
import ims.scheduling.vo.BookingAppointmentForLinkedAppointmentsVoCollection;
import ims.scheduling.vo.BookingAppointmentLiteVoCollection;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.Booking_AppointmentVoCollection;
import ims.scheduling.vo.ExclusionDatesVo;
import ims.scheduling.vo.ProfileLiteVoCollection;
import ims.scheduling.vo.Sch_BookingApptForLinkedAppointmentsVo;
import ims.scheduling.vo.Sch_BookingVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.Sch_SessionRefVoCollection;
import ims.scheduling.vo.SessionParentChildSlotForBookingVo;
import ims.scheduling.vo.SessionParentChildSlotListVoCollection;
import ims.scheduling.vo.SessionParentChildSlotRefVo;
import ims.scheduling.vo.SessionParentChildSlotVoCollection;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotListVo;
import ims.scheduling.vo.SessionSlotListVoCollection;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.SessionSlotVoCollection;
import ims.scheduling.vo.SessionSlotWithStatusOnlyVo;
import ims.scheduling.vo.SessionSlotWithStatusOnlyVoCollection;
import ims.scheduling.vo.Session_ListOwnerVoCollection;
import ims.scheduling.vo.Session_SlotRefVo;
import ims.scheduling.vo.domain.BookingAppointmentForLinkedAppointmentsVoAssembler;
import ims.scheduling.vo.domain.BookingAppointmentLiteVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.ProfileLiteVoAssembler;
import ims.scheduling.vo.domain.Sch_BookingApptForLinkedAppointmentsVoAssembler;
import ims.scheduling.vo.domain.Sch_BookingVoAssembler;
import ims.scheduling.vo.domain.SessionParentChildSlotForBookingVoAssembler;
import ims.scheduling.vo.domain.SessionParentChildSlotListVoAssembler;
import ims.scheduling.vo.domain.SessionParentChildSlotVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.domain.SessionSlotListVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.domain.SessionSlotWithStatusOnlyVoAssembler;
import ims.scheduling.vo.domain.Session_ListOwnerVoAssembler;
import ims.scheduling.vo.lookups.ProfileListType;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.SchedCABSlotType;
import ims.scheduling.vo.lookups.SchedulingPriority;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.hibernate.exception.LockAcquisitionException;

public class BookAppointmentImpl extends BaseBookAppointmentImpl
{

	private static final long	serialVersionUID	= 1L;
	boolean						icabBooking;
	private static final int TWO_WEEK_WAIT_TO_1ST_APP = 14;
	private static final int GP_SOURCE_OF_REFERRAL_NAT_CODE = 10; // FIRST ACTIVITY
	private static final int OTHER_SOURCE_OF_REFERRAL_NAT_CODE = 12;
	private static final int DID_NOT_ATTEND = 33; 
	private static final int SUBSEQUENT_ACTIVITY = 20;
	
	private static final String CHOOSE_AND_BOOK_EXT_SYS_NAME = "Choose and Book"; 
	
	public SessionSlotListVoCollection listSessionSlot(Sch_SessionRefVoCollection session, ActivityRefVo activity, LookupInstVo urgency, ServiceFunctionRefVo serviceFunction, HcpRefVo respHCP)
	{
		if (session == null || session.size() == 0)
			return null;
		
		StringBuilder query = new StringBuilder();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		StringBuffer condStr = new StringBuffer();
		
		query.append("SELECT slot FROM Session_Slot AS slot LEFT JOIN slot.session AS session  LEFT JOIN session.schLocation as location  LEFT JOIN slot.functions as servFunctions ");
		condStr.append(" WHERE session.id in (");
		
		for (int i = 0; i < session.size(); i++)
		{
			condStr.append(session.get(i).getID_Sch_Session());
			
			if (i != session.size() - 1)
				condStr.append(", ");
		}
		
		condStr.append(")");
		
		condStr.append(" AND (slot.directAccessSlot.id != :CAB_TYPE OR slot.directAccessSlot is null)");
		condStr.append(" AND slot.status.id = :OPEN_SLOT AND slot.appointment is null ");
		
		paramNames.add("CAB_TYPE");		paramValues.add(SchedCABSlotType.CAB.getID());
		paramNames.add("OPEN_SLOT");	paramValues.add(Status_Reason.SLOTOPENED.getID());
		
		if (activity != null && activity.getID_Activity() != null)
		{
			query.append( " LEFT JOIN slot.activity AS activity ");
			condStr.append(" AND activity.id = :ACTIVITY_ID ");
			
			paramNames.add("ACTIVITY_ID");		paramValues.add(activity.getID_Activity());
		}
		
		if (urgency != null && SchedulingPriority.ROUTINE.getID() == urgency.getID())//WDEV-22393
		{
			query.append( " LEFT JOIN slot.priority as priority ");
			condStr.append(" AND priority.id = :idUrgency ");
			
			paramNames.add("idUrgency");
			paramValues.add(urgency.getID());
			
		}
		
		if (serviceFunction != null)
		{
			condStr.append(" AND servFunctions.id = :idFunction ");
			
			paramNames.add("idFunction");
			paramValues.add(serviceFunction.getID_ServiceFunction());
			
		}
		else
			condStr.append(" AND servFunctions.id is null");
		
		if (respHCP != null)
		{
			query.append( " LEFT JOIN slot.slotResp as slResp LEFT JOIN slResp.hcp as slHCP ");
			condStr.append(" AND (slHCP.id = :idListOwner or slResp is null) ");
			
			paramNames.add("idListOwner");
			paramValues.add(respHCP.getID_Hcp());
		}
		
		condStr.append(" ORDER BY location.name ASC, session.name ASC, slot.startTm ASC ");
		query.append(condStr.toString());
		
		return SessionSlotListVoAssembler.createSessionSlotListVoCollectionFromSession_Slot(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public SessionSlotVo getSessionSlot(Session_SlotRefVo slot)
	{
		if (slot == null || slot.getID_Session_Slot() == null)
			return null;
		
		return SessionSlotVoAssembler.create((Session_Slot) getDomainFactory().getDomainObject(Session_Slot.class, slot.getID_Session_Slot()));
	}

	
	public SessionSlotVoCollection listSessionSlot(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not supplied for method listSessionSlot;");

		DomainFactory factory = getDomainFactory();
		Sch_Session doSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, session.getID_Sch_Session());
		List slots = factory.find("from Session_Slot as slot where slot.session.id = " + session.getID_Sch_Session() + " and (slot.directAccessSlot.id != " + SchedCABSlotType.CAB.getId() + " or slot.directAccessSlot is null)");
		return SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(slots).sort();
	}

	public ims.core.vo.ServiceLiteVoCollection listActiveCanBeScheduledService()
	{
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(getDomainFactory().find("from Service service where (service.isActive = 1 and service.canBeScheduled = 1 and service.serviceCategory.id != '" + ServiceCategory.RADIOLOGY_MODALITY.getID() + "') order by service.serviceName asc"));   //wdev-20862
	}

	/**
	 * NB - This method is called from a web service and therefore should only
	 * be modified with extreme caution (dlaffan)
	 */
	public Sch_BookingVo saveBooking(Sch_BookingVo voBooking, CatsReferralRefVo catsRef, Boolean isRebook) throws DomainInterfaceException, StaleObjectException
	{
		return saveBooking(voBooking, catsRef, isRebook, null, null, null, null); //WDEV-19543
	}
	
	private List createdReferralERODCollection(DomainFactory factory, List outpatientEROD, ReferralERODForBookAppointmentVoCollection outpatientERODCollection, HashMap objMap)
	{
		if(outpatientERODCollection == null)
			return outpatientEROD;
		
		int sequence = 0;
		
		if(outpatientEROD != null)
		{
			for(int i=0; i<outpatientEROD.size(); i++)
			{
				if(outpatientEROD.get(i) instanceof ReferralEROD)
				{
					ReferralEROD savedErod = (ReferralEROD) outpatientEROD.get(i);
					
					if(sequence < savedErod.getSequence())
						sequence = savedErod.getSequence();
				}
			}
		}
		
		sequence++;
		
		if(outpatientEROD == null)
			outpatientEROD = new java.util.ArrayList();
		
		List coll = ReferralERODForBookAppointmentVoAssembler.extractReferralERODList(factory, outpatientERODCollection, null, objMap);
		
		for(int i=0; i<coll.size(); i++)
		{
			if(coll.get(i) instanceof ReferralEROD)
			{
				ReferralEROD erod = (ReferralEROD) coll.get(i);
				erod.setSequence(sequence);
				sequence++;
				
				outpatientEROD.add(erod);
			}
		}
		
		return outpatientEROD;
	}

	/**
	 * WDEV-5711
	 * 
	 * @param isRebook
	 * @param factory
	 * @param doOrderInvAppts
	 * @param doBooking
	 * @param doCatsReferral
	 * @throws StaleObjectException
	 */
	private void RefManMessaging(Boolean isRebook, DomainFactory factory, Set doOrderInvAppts, Sch_Booking doBooking, CatsReferral doCatsReferral) throws StaleObjectException
	{
		// WDEV-5711 - generateNewOrderEvent
		// for all the new OrderInvAppt where the order has beeen authorised
		// call generateNewOrderEvent
		if (doOrderInvAppts != null)
		{
			Iterator it = doOrderInvAppts.iterator();
			while (it.hasNext())
			{
				OrderInvAppt doOrderInvAppt = (OrderInvAppt) it.next();
				OrderInvestigation doOrderInv = doOrderInvAppt.getOrderInvestigation();
				if (doOrderInv.getOrderDetails() != null && doOrderInv.getOrderDetails().getAuthorisationOrderStatus() != null && doOrderInv.getOrderDetails().getAuthorisationOrderStatus().equals(getDomLookup(AuthorisationOrderStatus.AUTHORISED)))
				{
					// WDEV-5740
					OrderedInvestigationStatus status = new OrderedInvestigationStatus();
					status.setOrdInvStatus(getDomLookup(OrderInvStatus.ORDERED));
					status.setChangeDateTime(new java.util.Date());
					status.setProcessedDateTime(new java.util.Date());
					status.setChangeUser(getHcpLiteUser() != null ? ((HcpLiteVo) getHcpLiteUser()).getIMosName() : null);
					doOrderInv.setOrdInvCurrentStatus(status);
					doOrderInv.getOrdInvStatusHistory().add(status);
					factory.save(doOrderInv);

					OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
					if (doOrderInvAppt.getAppointment() != null)
						impl.generateNewOrderEvent(new Booking_AppointmentRefVo(doOrderInvAppt.getAppointment().getId(), 0), new OrderInvestigationRefVo(doOrderInv.getId(), 0));
				}
			}
		}

		// WDEV-5711 - generateOrderUpdateEvent
		// if rebooking and appt has orderinvs generateOrderUpdateEvent needs to
		// be called
		if (isRebook != null)
		{
			if (isRebook == true)
			{
				if (doCatsReferral != null)
					doOrderInvAppts = doCatsReferral.getOrderInvAppts();

				if (doOrderInvAppts != null)
				{
					Iterator it = doOrderInvAppts.iterator();
					while (it.hasNext())
					{
						OrderInvAppt doOrderInvAppt = (OrderInvAppt) it.next();
						if (doBooking.getAppointments() != null && doBooking.getAppointments().contains(doOrderInvAppt.getAppointment()))
						{
							OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
							impl.generateOrderUpdateEvent(new Booking_AppointmentRefVo(doOrderInvAppt.getAppointment().getId(), doOrderInvAppt.getAppointment().getVersion()), new OrderInvestigationRefVo(doOrderInvAppt.getOrderInvestigation().getId(), doOrderInvAppt.getOrderInvestigation().getVersion()));
						}
					}
				}
			}
		}
	}

	/**
	 * Save Patient if needed, set SlotStatus, set TransportRequired, set
	 * FirstAppointment
	 * 
	 * @param doBooking
	 * @param doCatsReferral
	 * @param icabBooking
	 * @return doConsultationAppt
	 * @throws StaleObjectException
	 */
	private Booking_Appointment arrangeAppointmentsInReferralAndSavePatient(Sch_Booking doBooking, CatsReferral doCatsReferral) throws StaleObjectException
	{
		// If this is a new patient (from gateway) we will need to save the
		// patient first
		if (doBooking.getPatient().getId() == null)
		{
			getDomainFactory().save(doBooking.getPatient());
		}

		// WDEV-5727 - consultation appt
		Booking_Appointment doConsultationAppt = null;
		if (doCatsReferral != null)
			doConsultationAppt = doCatsReferral.getConsultationAppt();

		//WDEV-8307
		HashMap mapSessionsRefreshed = new HashMap();
		
		if (doBooking.getAppointments() != null)
		{
			Iterator it = doBooking.getAppointments().iterator();
			Booking_Appointment doEarliestAppt = null;
			while (it.hasNext())
			{
				Booking_Appointment doBookAppt = (Booking_Appointment) it.next();

				if (doBookAppt.getSession()==null)//WDEV-19379
					continue;
				
				if(!mapSessionsRefreshed.containsKey(doBookAppt.getSession()))
				{
					getDomainFactory().refresh(doBookAppt.getSession());
					mapSessionsRefreshed.put(doBookAppt.getSession(), true);
				}
				else
				{
					//WDEV-8257 - get Session from DB
					getDomainFactory().refresh(doBookAppt.getSession());
				}
				
				// WDEV-19050 - Its possible to get SOE when two people booking into same session
				// at the same time, so need to get the actual session from database before setting the remaining slots
				// to prevent this happening
				Sch_Session doSession = (Sch_Session) getDomainFactory().getDomainObject(Sch_Session.class, doBookAppt.getSession().getId());
				doSession.setRemainingSlots(new Integer(doBookAppt.getSession().getRemainingSlots().intValue() - 1));
				if(doSession.getRemainingSlots() < 0)
					doSession.setRemainingSlots(0);
				getDomainFactory().saveNoFlush(doSession);
				System.out.println("Session saved - vstp = " + doSession.getVersion() + " no slots " + doSession.getRemainingSlots() + " " + new DateTime().toString(DateTimeFormat.ISO_SECS, true));

				
//				doBookAppt.getSession().setRemainingSlots(new Integer(doBookAppt.getSession().getRemainingSlots().intValue() - 1));
//				if(doBookAppt.getSession().getRemainingSlots() < 0)
//					doBookAppt.getSession().setRemainingSlots(0);
//			
				
				
				// Set patient at this level if not already set
				if (doBookAppt.getPatient() == null)
					doBookAppt.setPatient(doBooking.getPatient());

				if (doBookAppt.isIsCABBooking())
					icabBooking = true;
				if (doEarliestAppt != null && doEarliestAppt.getAppointmentDate().before(doBookAppt.getAppointmentDate()))
					doEarliestAppt = doBookAppt;

				if (doBookAppt.getSessionSlot() != null)
				{
					doBookAppt.getSessionSlot().setAppointment(doBookAppt);
					if(!doBookAppt.getSessionSlot().getStatus().equals(getDomLookup(Status_Reason.DNA)))						//wdev-12090
						doBookAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.APPOINTMENT_BOOKED));
				}//WDEV-20333
				else if (doBookAppt.getParentChildSlot() != null)
				{
					doBookAppt.getParentChildSlot().setAppointment(doBookAppt);
					if(!doBookAppt.getParentChildSlot().getStatus().equals(getDomLookup(Status_Reason.DNA)))
						doBookAppt.getParentChildSlot().setStatus(getDomLookup(Status_Reason.APPOINTMENT_BOOKED));
						
					doBookAppt.getParentChildSlot().setStatusReason(getDomLookup(Status_Reason.APPOINTMENT_BOOKED));
					
					SessionSlotStatus doStat = new SessionSlotStatus();
					doStat.setDateTime(new java.util.Date());
					doStat.setStatus(doBookAppt.getParentChildSlot().getStatus());
					doStat.setStatusReason(doBookAppt.getParentChildSlot().getStatusReason());
					doBookAppt.getParentChildSlot().getStatusReasonHistory().add(doStat);
					
				}

				if (doEarliestAppt == null)
					doEarliestAppt = doBookAppt;

				// WDEV-5727 - consultation appt
				if (doConsultationAppt == null)
				{
					if (doBookAppt.getSession().getService() != null)
					{
						if (doBookAppt.getSession().getService().getServiceCategory().equals(getDomLookup(ServiceCategory.CLINICAL)))
							doConsultationAppt = doBookAppt;
					}
				}

				// WDEV-5984
				if (doCatsReferral != null)
				{
					if (doCatsReferral.getReferralDetails() != null && doCatsReferral.getReferralDetails().getTransportRequired() != null && doCatsReferral.getReferralDetails().getTransportRequired().equals(getDomLookup(YesNo.YES)))
					{
						if (doBookAppt.getId() == null) // for every new appt
						{
							doBookAppt.setIsTransportRequired(true);
						}
					}
				}
			}
			doBooking.setFirstAppointment(doEarliestAppt);

			// if the first appointment is no longer associated with this
			// booking ie. was cancelled
			if (!doBooking.getAppointments().contains(doEarliestAppt))
			{
				doBooking.setFirstAppointment(null);
			}
		}
		return doConsultationAppt;
	}

	/**
	 * NB - This method is called from a web service and therefore should only
	 * be modified with extreme caution (dlaffan)
	 * 
	 * WDEV-7448 - If PukkaJ interface is enabled this method will attempt to
	 * either create an OcsOrder and an OrderInvestigation and link it to a new
	 * BookingAppointment or update existing OrderInvAppt records and then send
	 * messages to PukkaJ by creating entries in OcsExternalEvent
	 * 
	 * @param doCatsReferral
	 * @param voAppt
	 * @throws StaleObjectException
	 * @desc
	 */
	public void processAppointmentForPukkaJ(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appt) throws StaleObjectException
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided in method processAppointmentForPukkaJ");
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method processAppointmentForPukkaJ");

		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		
		if (doCatsReferral.getContract() != null
			&& doCatsReferral.getContract().getContractType() != null
			&& doCatsReferral.getContract().getContractType().getId() != ReferralManagementContractType.DIAGNOSTIC.getId())
			return;

		Booking_Appointment doAppt = (Booking_Appointment) factory.getDomainObject(appt);

		// get the booking record
		Sch_Booking doBooking = null;
		List bookings = getDomainFactory().find("select book from Sch_Booking book left join book.appointments as appt where appt.id = '" + appt.getID_Booking_Appointment() + "'");
		if (bookings != null && bookings.size() == 1)
			doBooking = (Sch_Booking) bookings.iterator().next();

		// count the number of bookings
		int bookedApptsFromThisReferral = countExistingReferralAppts(doCatsReferral, Status_Reason.BOOKED);

		if (bookedApptsFromThisReferral > 1 && !doCatsReferral.getOrderInvAppts().isEmpty())
		{
			OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
			//presuming ordinvappt will only ever have one
			OrderInvAppt doOrdInvAppt = (OrderInvAppt)doCatsReferral.getOrderInvAppts().iterator().next();
			if (doOrdInvAppt != null)
			{
				doOrdInvAppt.setAppointment(doAppt);
				doOrdInvAppt.getOrderInvestigation().setAppointmentDate(doAppt.getAppointmentDate());
				getDomainFactory().save(doOrdInvAppt);	
				impl.generateOrderUpdateEvent(appt, new OrderInvestigationRefVo(doOrdInvAppt.getOrderInvestigation().getId(), doOrdInvAppt.getOrderInvestigation().getVersion()));
			}
		}
		//changed here following discussion with barbara - 02 Jul 09 - following Dan West testing
		else if (bookedApptsFromThisReferral == 1)
		{
			OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
			Object[] orderInvAndOrder = null;
			if (doCatsReferral.getOrderInvAppts().isEmpty())
			{
				orderInvAndOrder = createOrder(doCatsReferral, doAppt);
				if (orderInvAndOrder != null)
				{
					OrderInvestigation doOrderInv = (OrderInvestigation) orderInvAndOrder[0];
					OcsOrderSession doOcsOrder = (OcsOrderSession) orderInvAndOrder[1];
					
					OrderInvAppt ordInvAppt = new OrderInvAppt();
					ordInvAppt.setOrderInvestigation(doOrderInv);
					ordInvAppt.setAppointment(doAppt);
					ordInvAppt.getOrderInvestigation().setAppointmentDate(doAppt.getAppointmentDate());
					doCatsReferral.getOrderInvAppts().add(ordInvAppt);
					doCatsReferral.getInvestigationOrders().add(doOcsOrder);
					doCatsReferral.setHasInvestigations(true);
					getDomainFactory().save(doCatsReferral);	
					impl.generateNewOrderEvent(appt, new OrderInvestigationRefVo(doOrderInv.getId(), doOrderInv.getVersion()));
				}
			}
			else
			{
				OrderInvAppt doOrdInvAppt = (OrderInvAppt)doCatsReferral.getOrderInvAppts().iterator().next();
				if (doOrdInvAppt != null)
				{
					doOrdInvAppt.setAppointment(doAppt);
					doOrdInvAppt.getOrderInvestigation().setAppointmentDate(doAppt.getAppointmentDate());
					getDomainFactory().save(doOrdInvAppt);	
					impl.generateOrderUpdateEvent(appt, new OrderInvestigationRefVo(doOrdInvAppt.getOrderInvestigation().getId(), doOrdInvAppt.getOrderInvestigation().getVersion()));
				}
			}
			
		}
	}

	/**
	 * get a list of default investigations run for the Referral service and
	 * automatically create an order and link the appt if supplied
	 * 
	 * @param doCatsReferral
	 * @param doNewAppt
	 * @return an object array containing the OrderInvestigation and the Order
	 */
	public Object[] createOrder(CatsReferral doCatsReferral, Booking_Appointment doNewAppt) throws StaleObjectException
	{
		if (doCatsReferral == null)
			throw new CodingRuntimeException("doCatsReferral is null in method createOrder");

		Set orderInvestigations = null;

		String invMapping = null;
		if (doCatsReferral.getReferralDetails() != null && doCatsReferral.getReferralDetails().getService() != null)
		{
			if (doCatsReferral.getReferralDetails().getService().getTaxonomyMap() != null)
			{
				Iterator itTax = doCatsReferral.getReferralDetails().getService().getTaxonomyMap().iterator();
				while (itTax.hasNext())
				{
					NonUniqueTaxonomyMap doTaxMap = (NonUniqueTaxonomyMap) itTax.next();  // WDEV-20676 changed to non-unique
					if (doTaxMap.getTaxonomyName().equals(getDomLookup(TaxonomyType.INVESTIGATION)))
					{
						invMapping = doTaxMap.getTaxonomyCode();
						break;
					}
				}
			}
		}

		if (invMapping != null)
		{
			List invs = getDomainFactory().find("from Investigation inv where upper(inv.providerInvCode) = '" + invMapping.toUpperCase() + "'");
			if (invs != null && invs.size() > 0)
			{
				OcsOrderSession doOcsOrder = new OcsOrderSession();
				doOcsOrder.setPatient(doCatsReferral.getPatient());
				doOcsOrder.setClinicalTrial(false);
				doOcsOrder.setAuthorisationOrderStatus(getDomLookup(AuthorisationOrderStatus.AUTHORISED));
				if(doCatsReferral.getReferralDetails() != null)
					doOcsOrder.setResponsibleGp(doCatsReferral.getReferralDetails().getGPName());
				
				orderInvestigations = createOrderInvestigations(invs, doNewAppt, doOcsOrder);
				doOcsOrder.setInvestigations(orderInvestigations);
				doOcsOrder.setWasProcessed(false);
				
				getDomainFactory().save(doOcsOrder);
				return new Object[]{(OrderInvestigation) orderInvestigations.iterator().next(), doOcsOrder};
			}
		}
		return null;
	}

	private Set createOrderInvestigations(List invs, Booking_Appointment doNewAppt, OcsOrderSession doOcsOrder)
	{
		Set orderInvs = new HashSet();
		Iterator it = invs.iterator();
		while (it.hasNext())
		{
			Investigation doInv = (Investigation) it.next();
			OrderInvestigation doOrderInv = new OrderInvestigation();
			doOrderInv.setInvestigation(doInv);
			doOrderInv.setAppointmentDate(doNewAppt != null ? doNewAppt.getAppointmentDate() : null);
			doOrderInv.setOrderDetails(doOcsOrder);

			OrderedInvestigationStatus status = new OrderedInvestigationStatus();
			status.setOrdInvStatus(getDomLookup(OrderInvStatus.ORDERED));
			status.setChangeDateTime(new java.util.Date());
			status.setProcessedDateTime(new java.util.Date());
			status.setChangeUser("ICAB");
			doOrderInv.setOrdInvCurrentStatus(status);
			doOrderInv.getOrdInvStatusHistory().add(status);

			doOrderInv.setWasOrdered(true);
			doOrderInv.setDisplayDateTime(new DateTime().getJavaDate());
			doOrderInv.setDisplayTimeSupplied(true);
			doOrderInv.setDisplayFlag(getDomLookup(OcsDisplayFlag.REQUESTED));
			doOrderInv.setOrdInvSeq(new Integer(0));
			doOrderInv.setWasProcessed(false);

			orderInvs.add(doOrderInv);
		}

		return orderInvs;
	}

	private String getIdString(List<String> invIds)
	{
		String idString = "";

		for (int i = 0; i < invIds.size(); i++)
		{
			idString += invIds.get(i).toUpperCase();
			idString += ((invIds.size() - (i + 1)) > 0 ? "," : "");
		}

		return idString;
	}

	private int countExistingReferralAppts(CatsReferral doCatsReferral, Status_Reason status)
	{
		int apptsFromThisReferral = 0;

		// check how many existing 'booked' appts there are in the referral
		if (doCatsReferral != null)
		{
			if (doCatsReferral.getAppointments() != null)
			{
				Iterator itAppt = doCatsReferral.getAppointments().iterator();
				while (itAppt.hasNext())
				{
					Booking_Appointment doAppt = (Booking_Appointment) itAppt.next();
					if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(status)))
						apptsFromThisReferral++;
				}
			}
		}

		return apptsFromThisReferral;
	}

	private OrderInvApptVoCollection getOrdinvApptCollection(ims.scheduling.vo.Sch_BookingVo voBooking)
	{
		OrderInvApptVoCollection voCollOrdInvAppt = new OrderInvApptVoCollection();
		if (voBooking.getAppointmentsIsNotNull())
		{
			for (Booking_AppointmentVo voAppt : voBooking.getAppointments())
			{
				if (voAppt.getOrderInvestigationIsNotNull())
				{
					// SITE-508 use existing OrderInvAppt record or create new
					OrderInvApptVo voOrdInvAppt = getOrCreateOrderInvApptVo(voAppt, voAppt.getOrderInvestigation());
					voOrdInvAppt.setAppointment(voAppt);
					voAppt.getOrderInvestigation().setAppointmentDate(new DateTime(voAppt.getAppointmentDate(), voAppt.getApptStartTime()));
					voOrdInvAppt.setOrderInvestigation(voAppt.getOrderInvestigation());
					voOrdInvAppt.setStatus(PollStatus.CANCELNOTPROCESSED);
					voCollOrdInvAppt.add(voOrdInvAppt);
				}
			}
		}
		return voCollOrdInvAppt.size() > 0 ? voCollOrdInvAppt : null;
	}

	private OrderInvApptVo getOrCreateOrderInvApptVo(Booking_AppointmentVo voAppt, OrderInvestigationBookingVo orderInvestigationBookingVo)
	{
		List ordInvAppts = getDomainFactory().find("from OrderInvAppt invAppt where invAppt.appointment.id = :idAppt and invAppt.orderInvestigation.id = :idOrderInv", new String[]{"idAppt", "idOrderInv"}, new Object[]{voAppt.getID_Booking_Appointment(), orderInvestigationBookingVo.getID_OrderInvestigation()});
		if (ordInvAppts != null && ordInvAppts.size() == 1)
		{
			OrderInvAppt doOrdInvAppt = (OrderInvAppt) ordInvAppts.get(0);
			return OrderInvApptVoAssembler.create(doOrdInvAppt);
		}

		return new OrderInvApptVo();
	}

	/**
	 * checkReferral
	 * 
	 * @param factory
	 * @param doBooking
	 *            The booking we just saved This method will check if an open
	 *            referral already exists for this patient and UBRN. If it does
	 *            the appointment will be saved alongside it. If not, a new
	 *            referral will be created with the given appointment associated
	 *            with it.
	 * @param eventDateTime 
	 * @throws StaleObjectException
	 * @throws DomainInterfaceException 
	 */
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	@SuppressWarnings("unchecked")
	private void checkReferral(DomainFactory factory, Sch_Booking doBooking, java.util.Date eventDateTime) throws StaleObjectException, DomainInterfaceException
	{
		if (!ConfigFlag.GEN.ICAB_ENABLED.getValue())
			return;

		CatsReferral cancelledReferral=null;
		CatsReferral catsReferral = null;
		List<?> lst = CatsReferral.listCatsReferralByPatient(factory, doBooking.getPatient());
		if (lst != null && lst.size() > 0)
		{
			
			Iterator<?> it = lst.iterator();
			while (it.hasNext())
			{
				CatsReferral domRef = (CatsReferral) it.next();
				if (domRef instanceof CatsReferral)
				{
					ICABReferral tmpRef = ((CatsReferral) domRef).getICABReferral();
					if (tmpRef != null && tmpRef.getUBRN() != null && tmpRef.getUBRN().equals(doBooking.getUBRN()) && tmpRef.getStatus().getId() != ICABReferralStatus.COMPLETED.getId())
					{
						// WDEV-12701 If more than one referral found for the ubrn, and one has a cancelled
						// status, then use the other one i.e. don't just use the first one we come across.
						if (domRef.getCurrentStatus() != null && 
											(domRef.getCurrentStatus().getReferralStatus().getId() == ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER.getID() ||
											 domRef.getCurrentStatus().getReferralStatus().getId() == ReferralApptStatus.CAB_CANCELLATION.getID()))
						{
							cancelledReferral=domRef;
							// Continue as we might find another referral that isn't cancelled
						}
						else
						{
							catsReferral = domRef;
							break;
						}
					}
				}
			}
		}

		if (catsReferral == null && cancelledReferral == null)
			catsReferral = createNewReferral(factory, doBooking);
		else
		{
			// WDEV-12701 - use the cancelled referral if no other one to use
			if (catsReferral == null)
				catsReferral=cancelledReferral;
			
			// wdev-6738 If referral transport required, then set appointment
			// value to true
			if (catsReferral.getReferralDetails() != null && catsReferral.getReferralDetails().getTransportRequired() != null && catsReferral.getReferralDetails().getTransportRequired().getId() == YesNo.YES.getId())
			{
				doBooking.getFirstAppointment().setIsTransportRequired(Boolean.TRUE);
				factory.save(doBooking.getFirstAppointment());
			}

		}
		
		catsReferral.getAppointments().add(doBooking.getFirstAppointment());
		catsReferral.setConsultationActivityRequired(false); //WDEV-22915
		
		//WDEV-23223 - starts here
		if(icabBooking && catsReferral.getJourney() == null)
		{
			PatientPathwayJourney journey = createJourney(factory, catsReferral);
			catsReferral.setJourney(journey);
		}
		
		PathwayRTTStatus rttStatus = null;
		if(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && Boolean.TRUE.equals(catsReferral.isRTTClockImpact()))
		{
			rttStatus = createPathwayRTTStatus(catsReferral, eventDateTime);
			catsReferral.setCurrentRTTStatus(rttStatus);
		}
		//WDEV-23223 - ends here
		
		factory.save(catsReferral);
		
		//WDEV-23550
		catsReferral.setPathwayID(createPathwayID(catsReferral));
		factory.save(catsReferral);
		
		//WDEV-23223 - starts here
		if(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && rttStatus != null && Boolean.TRUE.equals(catsReferral.isRTTClockImpact()))
		{
			RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus.getRTTStatus());
			
			if(rttMap != null && rttMap.getEvent() != null)
			{
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient(new PatientRefVo(catsReferral.getPatient().getId(), catsReferral.getPatient().getVersion()));
				patEvent.setEvent(rttMap.getEvent());
				patEvent.setEventDateTime(new DateTime());
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(catsReferral.getJourney()));
				
				HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				impl.instantiatePatientEvent(patEvent);
			}
		}
		//WDEV-23223 - ends here
		
		return;
	}
	
	//WDEV-23550
	private String createPathwayID(CatsReferral domCatsReferral)
	{
		if (domCatsReferral!=null && domCatsReferral.getPathwayID() == null )
		{
			String orgCode = "";
			String szZeros = "";
			String allZeros = "00000000000000000000";//20 chars

			if (domCatsReferral.getReferralDetails() != null
				&& domCatsReferral.getReferralDetails().getReferrerType() != null)
			{
				if (domCatsReferral.getReferralTransfer()!=null && domCatsReferral.getReferralDetails().getReferrerType().equals(SourceOfReferral.TRANSFER))//WDEV-18554
				{	
					//WDEV-19698 //WDEV-20048
					if (domCatsReferral.getReferralTransfer().getOTherOrganisationCode() != null)
					{	
						String extCode = getLookupService().getRemoteLookup(domCatsReferral.getReferralTransfer().getOTherOrganisationCode().getId(), "MAXIMS");
						if (extCode != null)
							orgCode = extCode;
					}

				}
				else if(domCatsReferral.getReferralDetails().getPCT()!=null)
					orgCode = domCatsReferral.getReferralDetails().getPCT();
			}
			
			//WDEV-18816
			if (orgCode != null && orgCode.length() <= allZeros.length())//WDEV-20618
				szZeros = allZeros.subSequence(0, allZeros.length() - orgCode.length()).toString();
			
			if (szZeros.length() < domCatsReferral.getId().toString().length())
				szZeros = "";
			else
				szZeros = szZeros.subSequence(0, szZeros.length() - domCatsReferral.getId().toString().length()).toString();
			
			String pathwayId = orgCode + szZeros + domCatsReferral.getId().toString();
			
			return (pathwayId.length() > 20 ? pathwayId.subSequence(0, 19).toString() : pathwayId);
		}

		return null;
	}

	//WDEV-23223 - starts here.
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral record, java.util.Date eventDateTime) throws DomainInterfaceException
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if(record == null)
			return null;
		
		int nationalCode = OTHER_SOURCE_OF_REFERRAL_NAT_CODE;
		
		if(record.getReferralDetails() != null && record.getReferralDetails().getReferrerType() != null && SourceOfReferral.GP.getID() == record.getReferralDetails().getReferrerType().getId())
		{
			nationalCode = GP_SOURCE_OF_REFERRAL_NAT_CODE;
		}
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPoint(nationalCode);
		
		//WDEV-19383
		if (rttStatusPoint == null)
			throw new DomainInterfaceException("No RTT Status Point was found for National Code: " + nationalCode);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(eventDateTime);
		
		if(record.getJourney() != null && record.getJourney().getCurrentClock() != null)
    	{
			record.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(record.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			record.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		record.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
    		
    	}
		
		return pathwayRTTStatus;
	}
	//WDEV-23223 - ends here
	
	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;
		
		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral record, Boolean isBasedOnHardCodedEvent, java.util.Date eventDateTime)
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if(record == null)
			return null;
		
		int nationalCode = OTHER_SOURCE_OF_REFERRAL_NAT_CODE;
		
		if(record.getReferralDetails() != null && record.getReferralDetails().getReferrerType() != null && SourceOfReferral.GP.getID() == record.getReferralDetails().getReferrerType().getId())
		{
			nationalCode = GP_SOURCE_OF_REFERRAL_NAT_CODE;
		}
		RTTStatusPoint rttStatusPoint = null;
		
		if(record.getCurrentRTTStatus()!=null
			&&record.getCurrentRTTStatus().getRTTStatus()!=null
			&&DID_NOT_ATTEND == record.getCurrentRTTStatus().getRTTStatus().getNationalCode()
			&&record.getReferralDetails()!=null
			&&record.getPathwayID()!=null) //WDEV-21454
		{
			if (Boolean.TRUE.equals(record.getPatient().isPaediatricOn(record.getReferralDetails().getDateOfReferral()))) //Paed
			{
				rttStatusPoint = getRTTStatusPoint(SUBSEQUENT_ACTIVITY);
			}
			else // adult
			{
				rttStatusPoint = getRTTStatusPoint(GP_SOURCE_OF_REFERRAL_NAT_CODE);
			}
		}
		else
		{
			rttStatusPoint = isBasedOnHardCodedEvent ? getRTTStatusPointForBookedAppt(HardCodedEvents.APPOINTMENTBOOKED.getID()) : getRTTStatusPoint(nationalCode);
		}
		
		if (rttStatusPoint == null && isBasedOnHardCodedEvent)
			return null;
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(eventDateTime);
		
		if(record.getJourney() != null && record.getJourney().getCurrentClock() != null)
    	{
			record.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(record.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			record.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		record.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
		}
		
		return pathwayRTTStatus;
	}
	
	private RTTStatusPoint getRTTStatusPointForBookedAppt(int bookedApptEventId)
	{
		String query = "select trs from RTTStatusEventMap as rsem left join rsem.targetRTTStatus as trs left join rsem.event as e where e.id =:eventID and rsem.active = 1 ";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"eventID"}, new Object[] {bookedApptEventId});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}

	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}
	
	private boolean isNonDiagnosticAppointment(CatsReferral catsReferral)
	{
		if(catsReferral != null && catsReferral.getDOS() != null && catsReferral.getDOS().getContract() != null && catsReferral.getDOS().getContract().getContractType() != null)
		{
			if(ReferralManagementContractType.DIAGNOSTIC.getID() == catsReferral.getDOS().getContract().getContractType().getId())
				return false;
		}
		
		return true;
	}

	private PatientPathwayJourney createJourney(DomainFactory factory, CatsReferral referral) 
	{
		//WDEV-18483 - the patient journey gets created regardless of Elective List flag value
		//if (!ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
		//	return null;
		
		if (referral != null && referral.getId() != null)
		{
			CatsReferral domReferral = (CatsReferral) factory.getDomainObject(CatsReferral.class, referral.getId());
			if (domReferral != null && domReferral.getJourney() != null)
				return domReferral.getJourney();
		}
		
		PatientJourneyVo journey = new PatientJourneyVo();
				
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		try 
		{
			// Create the holding referral first
			Referral domReferral = new Referral();
			domReferral.setAuthoringDateTime(new java.util.Date());
			//WDEV-18395
			
			//WDEV-23223 - starts here
			if (referral.getPathwayID()!=null && !referral.getPathwayID().equals(""))
				domReferral.setClockId(referral.getPathwayID());
			else
				domReferral.setClockId("MAXIMS_1");
			//WDEV-23223 - ends here
			
			//WDEV-18395
			domReferral.setReferralType(factory.getLookupInstance(ReferralType.INTERNAL.getId()));
			
			 // WDEV-23419  Include user Id as part of external referral key
			int userId=0;
			ims.framework.interfaces.IAppUser user = super.getLoggedInUser();
			if (user != null)
				userId = user.getUserId();
			domReferral.setExtReferralKey("IMS_" + userId + "_" + new java.util.Date().getTime()); // WDEV-23419 Include UserId
			domReferral.setPatient((ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, referral.getPatient().getId()));
			
			// New Patient - need to save it
			if (referral.getPatient() != null && referral.getPatient().getId() == null)
			{
				ims.core.patient.domain.objects.Patient domPatient = referral.getPatient();
				factory.save(domPatient);
				domReferral.setPatient(domPatient);
				PatientShort voPatient = PatientShortAssembler.create(domPatient);
				journey.setPatient(voPatient);
			}
			else
			{
				domReferral.setPatient(referral.getPatient());
				journey.setPatient(PatientShortAssembler.create(referral.getPatient()));

			}
			factory.save(domReferral);
						
			journey.setReferral(new ReferralRefVo(domReferral.getId(), domReferral.getVersion()));
			
			if (referral.getReferralDetails() != null)
			{
				if(referral.getReferralDetails().getDateOfReferral() != null)
				{
					journey.setStartDate(new ims.framework.utils.Date(referral.getReferralDetails().getDateOfReferral()));
				}
			}
			
			journey.setExtReferralKey(domReferral.getExtReferralKey());
						
			//WDEV-18395
			if (referral.isRTTClockImpact() != null && Boolean.TRUE.equals(referral.isRTTClockImpact()))
			{
				PathwayClockVo clock = new PathwayClockVo();
				clock.setExtClockId(domReferral.getClockId());
				clock.setExtClockName("MaximsClock_1");
				clock.setStartDate(journey.getStartDate());	
				clock.setTargetClockEnd(getTargetClockEnd(clock.getStartDate(), referral));
				journey.setCurrentClock(clock);			
				if (!journey.getClockHistoryIsNotNull())
					journey.setClockHistory(new PathwayClockVoCollection());
				journey.getClockHistory().add(clock);
			}
			
			// Services specialty - if not set then use Emergency
			if (referral.getReferralDetails() != null && referral.getReferralDetails().getService() != null && referral.getReferralDetails().getService().getSpecialty() != null)
				journey = impl.createPatientJourney(journey, null, getSpecialty(referral.getReferralDetails().getService().getSpecialty()), null,null);			
			else	
				journey = impl.createPatientJourney(journey, null, Specialty.EMERGENCY, null,null);
			
			return PatientJourneyVoAssembler.extractPatientPathwayJourney(factory, journey);
		} 
		catch (DomainInterfaceException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Domain Interface Exception occurred creating patient journey - " + e.getMessage());
			return null;
		} 
		catch (StaleObjectException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Stale Object Exception occurred creating patient journey - " + e.getMessage());
			return null;
		}		
	}

	private Date getTargetClockEnd(Date date, CatsReferral referral)
	{
		Date startDate = date.copy();

		int daysToRttBreachDate = 0;

		if (referral != null && referral.getReferralDetails() != null)
		{
			ContractConfigRefVo contractRefVo = referral.getContract() != null ? new ContractConfigRefVo(referral.getContract().getId(), referral.getContract().getVersion()) : null;
			ServiceRefVo serviceRefVo = referral.getReferralDetails().getService() != null ? new ServiceRefVo(referral.getReferralDetails().getService().getId(), referral.getReferralDetails().getService().getVersion()) : null;
			
			ContractServiceLocationsConfigVo contrServiceLocationConf = getContractServiceLocConf(contractRefVo, serviceRefVo);

			if (contrServiceLocationConf != null && contrServiceLocationConf.getDaysToRTTBreachDate() != null)
			{
				daysToRttBreachDate = contrServiceLocationConf.getDaysToRTTBreachDate();
			}
			else if (referral.getContract() != null)
			{
				daysToRttBreachDate = referral.getContract().getDaysToRTTBreachDate();
			}
		}

		return startDate.addDay(daysToRttBreachDate);
	}

	private Specialty getSpecialty(LookupInstance specialty)
	{
		if(specialty == null)
			return null;
		
		ims.framework.utils.ImagePath img = null;
		ims.framework.utils.Color color = null;	
		
		img = null;
		if (specialty.getImage() != null) 
		{
			img = new ims.framework.utils.ImagePath(specialty.getImage().getImageId(), specialty.getImage().getImagePath());
		}
		
		color = specialty.getColor();
		if (color != null) 
			color.getValue();

		Specialty spec = new Specialty(specialty.getId(),specialty.getText(), specialty.isActive(), null, img, color);
		
		return spec;
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	private CatsReferral createNewReferral(DomainFactory factory, Sch_Booking doBooking) throws StaleObjectException
	{
		CatsReferral catsRef = new CatsReferral();
		ICABReferral domReferral = new ICABReferral();
		domReferral.setAuthoringDateTime(new java.util.Date());
		domReferral.setReferralType(getDomLookup(ReferralType.EXTERNAL));
		domReferral.setPatient(doBooking.getPatient());
		domReferral.setUBRN(doBooking.getUBRN());
		domReferral.setStatus(getDomLookup(ICABReferralStatus.CHOOSEANDBOOK));

		catsRef.setICABReferral(domReferral);
		catsRef.setPatient(doBooking.getPatient());
		catsRef.setIsCAB(Boolean.TRUE);
		catsRef.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.NONE));
		catsRef.setConsultationAppt(doBooking.getFirstAppointment());
		catsRef.setHasAppointments(Boolean.TRUE);
		catsRef.setPatientCategory(getDomLookup(PatientStatus.NHS)); //http://jira/browse/WDEV-23441
		//WDEV-5507  
		
		//WDEV-19457 
		DirectoryofService dos = doBooking.getFirstAppointment().getSessionSlot().getDOSfromUBRN(doBooking.getUBRN());
		catsRef.setDOS(dos); 
        
		if (dos!=null)
		{
			catsRef.setRTTClockImpact(dos.isRTTClockImpact()); 
		}
		
		// wdev-10023 Set the ContractId from the DOS
        if (catsRef.getDOS() != null)
        	//WDEV-11713
        	catsRef.setContract(catsRef.getDOS().getContract());

        //WDEV-22829 
        if (doBooking.getFirstAppointment() != null)
        {	
        	LookupInstance referralUrgencyForApptCABPriority = getReferralUrgencyForApptCABPriority(doBooking.getFirstAppointment().getPriority());
        	catsRef.setUrgency(referralUrgencyForApptCABPriority);
        }
        //WDEV-22829  -- end
		CATSReferralStatus refStat = new CATSReferralStatus();
		refStat.setStatusDateTime(new java.util.Date());
		refStat.setReferralStatus(getDomLookup(ReferralApptStatus.REFERRAL_RECEIVED));
		catsRef.setCurrentStatus(refStat);
		catsRef.setStatusHistory(new HashSet());
		catsRef.getStatusHistory().add(refStat);

		// Need to create CareSpell, EpisodeOfCare and CareContext as
		// CareContext required for CatsReferral
		CareSpell domCS = new CareSpell();
		domCS.setStartDate(new java.util.Date());
		domCS.setPatient(doBooking.getPatient());

		EpisodeOfCare domEpis = new EpisodeOfCare();
		domEpis.setCareSpell(domCS);
		domEpis.setStartDate(new java.util.Date());
		domEpis.setSpecialty(doBooking.getFirstAppointment().getSession().getService().getSpecialty());
		Set episSt = new HashSet();
		episSt.add(domEpis);
		domCS.setEpisodes(episSt);

		CareContext domCC = new CareContext();
		domCC.setStartDateTime(new java.util.Date());
		domCC.setEpisodeOfCare(domEpis);
		domCC.setContext(getDomLookup(ContextType.REFERRAL));
		Set ccSt = new HashSet();
		ccSt.add(domCC);
		domEpis.setCareContexts(ccSt);
		
		//WDEV-19436 
		if (null==catsRef.getReferralDetails())
		{
			ReferralLetterDetails refDet = new ReferralLetterDetails(); 
			refDet.setDateOfReferral(new java.util.Date());	
			refDet.setService(doBooking.getFirstAppointment().getSession().getService());
			if(doBooking.getFirstAppointment().getSessionSlot()!=null&&doBooking.getFirstAppointment().getSessionSlot().getSlotResp()!=null)//http://jira/browse/WDEV-23441
			{
				refDet.setConsultant(doBooking.getFirstAppointment().getSessionSlot().getSlotResp().getHcp());
			}
			if (doBooking.getPatient().getPractice()!=null) 
				refDet.setPCT(doBooking.getPatient().getPractice().getPctCode()); 
			else 
				//WDEV-20080
				refDet.setPCT("X98");
				//WDEV-20080
			refDet.setAuthoringDateTime(new java.util.Date()); 
			Object mos = getMosUser(); 
			MemberOfStaff doMos = null; 
	
			if(mos instanceof MemberOfStaffLiteVo) 
			{ 
				doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos); 
			} 
	
			refDet.setAuthoringUser(doMos); 
			catsRef.setReferralDetails(refDet);

			
			Integer daysToRttBreachDate = getDaysToRttBreachDateByService(catsRef.getContract(), refDet.getService());
			refDet.setEnd18WW(calculateKPI(catsRef, catsRef.getContract(), daysToRttBreachDate)); 
			
			refDet.setReferrerType(getDomLookup(SourceOfReferral.GP));
		}
		//WDEV-19436

		factory.save(domCS);
		catsRef.setCareContext(domCC);
		return catsRef;
	}

	//WDEV-22829
	private LookupInstance getReferralUrgencyForApptCABPriority(LookupInstance priority)
	{
		if (priority == null)
			return null;
		LookupInstance refUrgency = null;
		LookupMapping cABMapping = priority.getMapping(CHOOSE_AND_BOOK_EXT_SYS_NAME);
		if (cABMapping != null)
		{			
			LookupInstVo refUrgencyVo = getLookupService().getLocalLookup(ReferralUrgency.class, ReferralUrgency.TYPE_ID, cABMapping.getExtSystem(), cABMapping.getExtCode());
			if (refUrgencyVo != null && refUrgencyVo.isActive())
				refUrgency = getDomLookup(refUrgencyVo);
			else
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "No active referral urgency lookup instance was found with mapping of type:\"" + cABMapping.getExtSystem() + "\", mapping value: " + cABMapping.getExtCode() + ". Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
				return null;
			}
		}
		else
		{	
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "The Scheduling Priority lookup instance associated to appointment priority is not mapped. No valid \"Choose and Book\" mapping was found. Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
			return null;
		}
		return refUrgency;		
	}

	private Integer getDaysToRttBreachDateByService(ContractConfig contractConfig, Service service)
	{
		if (contractConfig == null || service == null || service.getId() == null)
			return null;
		
		for (int i=0;contractConfig.getServiceLocations()!=null && i<contractConfig.getServiceLocations().size();i++)
		{
			if (contractConfig.getServiceLocations().get(i)!=null && service.getId().equals(((ContractServiceLocationsConfig)contractConfig.getServiceLocations().get(i)).getService().getId()))
				return ((ContractServiceLocationsConfig)contractConfig.getServiceLocations().get(i)).getDaysToRTTBreachDate();
		}
		
		return null;
	}

	
	public java.util.Date calculateKPI(CatsReferral doCatsReferral, ContractConfig contractConfig, Integer daysToRttBreachDate)
	{
		if(!getDomLookup(SourceOfReferral.NATIONAL_SCREENING).equals(doCatsReferral.getReferralDetails().getReferrerType()))
		{
    		if(!Boolean.TRUE.equals(doCatsReferral.isIsEmergencyReferral()))
    		{
        		boolean serviceIsSubjectToRTT = doCatsReferral.getReferralDetails().getService() != null && Boolean.TRUE.equals(doCatsReferral.getReferralDetails().getService().isIsSubjectToRTTClock());
        		
        		if(doCatsReferral.getReferralTransfer() != null)
        		{
        			if(doCatsReferral.getReferralTransfer().getRTTStartDate() != null && daysToRttBreachDate != null)
        			{
        				Date rttStartDate = new Date(doCatsReferral.getReferralTransfer().getRTTStartDate());
        				rttStartDate.addDay(daysToRttBreachDate);
        				
        				return rttStartDate.getDate();
        			}
        			else if(doCatsReferral.getReferralTransfer().getRTTStartDate() != null && contractConfig != null && contractConfig.getDaysToRTTBreachDate() != null && serviceIsSubjectToRTT)
        			{
        				Date rttStartDate = new Date(doCatsReferral.getReferralTransfer().getRTTStartDate());
        				rttStartDate.addDay(contractConfig.getDaysToRTTBreachDate());
        				
        				return rttStartDate.getDate();
        			}
        		}
        		else
        		{
        			if(doCatsReferral.getReferralDetails().getDateOfReferral() != null && daysToRttBreachDate!=null)
        			{
        				Date rttStartDate = new Date(doCatsReferral.getReferralDetails().getDateOfReferral());
        				rttStartDate.addDay(daysToRttBreachDate);
            		
        				return rttStartDate.getDate();
        			}
        			else if(doCatsReferral.getReferralDetails().getDateOfReferral() != null && contractConfig != null && contractConfig.getDaysToRTTBreachDate() != null && serviceIsSubjectToRTT)
        			{
        				Date rttStartDate = new Date(doCatsReferral.getReferralDetails().getDateOfReferral());
        				rttStartDate.addDay(contractConfig.getDaysToRTTBreachDate());
        				
        				return rttStartDate.getDate();
        			}
        		}
    		}
		}
		
		return null;
	}

	
	

	/**
	 * list sessions for scheduling
	 */
	public SessionShortVoCollection listSession(Date startDate, Date endDate, ActivityVo activity, ServiceRefVo service, LocationRefVo location, HcpLiteVo listOwner, ServiceFunctionRefVo clinicType, LocationRefVoCollection locationList, ProfileListType listType, LookupInstVo urgency)	//wdev-19419
	{
		// all params must be set
		if (startDate == null || endDate == null || activity == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listGenericSession");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		String serviceCriteria = "";
		String listtypeCriteria = "";	//wdev-19419
		String locationCriteria = "";
		String clinicTypeCriteria = "";
		String clinicTypeJoin = "";
		String listOwnerJoin = "";
		String listOwnerCriteria = "";
		String urgencyJoin = "";
		String urgencyCriteria = "";

		// mandatory fields
		markers.add("activityId");
		markers.add("open");
		markers.add("startDate");
		markers.add("endDate");

		values.add(activity.getID_Activity());
		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		values.add(startDate.getDate());
		values.add(endDate.getDate());

		if (service != null)
		{
			markers.add("idService");
			values.add(service.getID_Service());
			serviceCriteria = " and session.service.id = :idService";
		}
		
		if (clinicType != null)
		{
			markers.add("idClinicType");
			values.add(clinicType.getID_ServiceFunction());
			clinicTypeJoin = " left join slot.functions as func ";
			clinicTypeCriteria = " and func.id = :idClinicType ";
		}
		else
		{
			clinicTypeJoin = " left join slot.functions as func ";
			clinicTypeCriteria = " and func.id is null ";
		}
		
		if (listOwner != null)
		{
			markers.add("idListOwner");
			values.add(listOwner.getID_Hcp());
			listOwnerJoin = " left join session.listOwners as lowners left join lowners.hcp shcp left join slot.slotResp as slResp left join slResp.hcp as slHCP";
			listOwnerCriteria = " and shcp.id = :idListOwner and (slHCP.id = :idListOwner or slResp is null)";
		}
		
		//wdev-19419
		if( listType != null)
		{
			markers.add("idlistType");
			values.add(getDomLookup(listType).getId());
			listtypeCriteria = " and session.listType.id = :idlistType";
		
		}
		//-----------
		
		if (location != null)
		{
			markers.add("idLocation");
			values.add(location.getID_Location());
			locationCriteria = " and session.schLocation.id = :idLocation";
		}
		else if(locationList != null)
		{
			List<String> locationIds = new ArrayList<String>();
			for(LocationRefVo voRef : locationList)
				locationIds.add(voRef.getID_Location().toString());

			locationCriteria = " and session.schLocation.id in (" + getIdString(locationIds) + ")";
		}
		
		if (urgency != null && SchedulingPriority.ROUTINE.getID() == urgency.getID())//WDEV-22393
		{
			markers.add("idUrgency");
			values.add(urgency.getID());
			urgencyJoin = " left join slot.priority as priority ";
			urgencyCriteria = " and priority.id = :idUrgency ";
		}

		DomainFactory factory = getDomainFactory();
		
		markers.add("OUTPATIENT_SESSION");
		values.add(SchProfileType.OUTPATIENT.getID());
		
		markers.add("CAB_TYPE");		
		values.add(SchedCABSlotType.CAB.getID());

		List<?> sessions = factory.find(" Select distinct session from Sch_Session as session " + " left join session.sessionSlots as slot " + clinicTypeJoin + listOwnerJoin + urgencyJoin + " where ( slot.activity.id = :activityId) " + " and session.sessionDate >= :startDate and session.sessionDate <= :endDate " + serviceCriteria + locationCriteria + clinicTypeCriteria + listOwnerCriteria + listtypeCriteria + urgencyCriteria + " and session.isFixed = 1 and session.sessionStatus = :open " +
				"and (session.sessionProfileType.id = :OUTPATIENT_SESSION) and session.isRIE is null AND (slot.directAccessSlot.id != :CAB_TYPE OR slot.directAccessSlot is null)", markers, values, 1000); //wdev-19419
		
		
		if (sessions == null || sessions.size() == 0)
			return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(sessions);


		SessionShortVoCollection voCollSessionShort = new SessionShortVoCollection();

		for (int i = 0; i < sessions.size(); i++)
		{
			if (sessions.get(i) instanceof Sch_Session)
			{
				Sch_Session session = (Sch_Session) sessions.get(i);

				SessionShortVo sessionShort = SessionShortVoAssembler.create(session);

				if (session.getSessionSlots() != null)
				{
					sessionShort.setCalendarSlots(new SessionSlotWithStatusOnlyVoCollection());

					Iterator<?> slotIterator = session.getSessionSlots().iterator();

					while (slotIterator.hasNext())
					{
						Session_Slot slot = (Session_Slot) slotIterator.next();

						SessionSlotWithStatusOnlyVo sessionSlot = SessionSlotWithStatusOnlyVoAssembler.create(slot);

						if (sessionSlot.getActivity().equals(activity))
						{
							sessionShort.getCalendarSlots().add(sessionSlot);
						}
					}
				}

				voCollSessionShort.add(sessionShort);
			}
		}

		return voCollSessionShort.sort();
	}

	/**
	 * list activities for ActivityType
	 */
	public ims.core.vo.ActivitySchedVoCollection listActivitiesForType(ims.core.vo.lookups.ActivityType actType, CatsReferralRefVo catsReferral, ServiceRefVo service)
	{
		if(catsReferral == null || service == null || service.getID_Service() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		String query = null;
		
		// WDEV-22672
		Long noConsultationActivityRequiredForReferral = factory.countWithHQL("select count(cats.id) from CatsReferral as cats where cats.id = :CatsReferralId and (cats.consultationActivityRequired = 0 or cats.consultationActivityRequired is null) ", new String[] {"CatsReferralId"}, new Object[] {catsReferral.getID_CatsReferral()});
		
		if (noConsultationActivityRequiredForReferral == null || noConsultationActivityRequiredForReferral == 0) //WDEV-22672
		{
			List appointments  = factory.find("select appts.id from CatsReferral as cats right join cats.appointments as appts where appts.theatreBooking is null and cats.id = :CatsReferralId", new String[] {"CatsReferralId"}, new Object[] {catsReferral.getID_CatsReferral()});

			if(appointments == null || appointments.size() == 0)
			{
				query = "select act from ServiceActivity as servActivity left join servActivity.activity as act left join servActivity.service as serv where serv.id = :serviceID and act.activityType = :actType and servActivity.isActive = :isActive  and (act.firstAppointment = 1 or act.diagnostic = 1) order by act.name asc";
			}
			else
			{
				query = "select act from ServiceActivity as servActivity left join servActivity.activity as act left join servActivity.service as serv where serv.id = :serviceID and act.activityType = :actType and servActivity.isActive = :isActive order by act.name asc";
			}
		}
		else
		{
			query = "select act from ServiceActivity as servActivity left join servActivity.activity as act left join servActivity.service as serv where serv.id = :serviceID and act.activityType = :actType and servActivity.isActive = :isActive order by act.name asc";
		}
		
		if(query != null && query.length() > 0)
		{
			return ActivitySchedVoAssembler.createActivitySchedVoCollectionFromActivity(factory.find(query, new String[]{"serviceID", "actType", "isActive"}, new Object[]{service.getID_Service(), getDomLookup(actType), Boolean.TRUE}));//WDEV-16073
		}
		
		return null;
	}

	/**
	 * list Booking appointments for a session
	 */
	public ims.scheduling.vo.Booking_AppointmentVoCollection listBookingAppointment(ims.scheduling.vo.Sch_SessionRefVo session)
	{
		DomainFactory factory = getDomainFactory();
		return Booking_AppointmentVoAssembler.createBooking_AppointmentVoCollectionFromBooking_Appointment(factory.find(" from Booking_Appointment book where book.session.id = :sessionId", new String[]{"sessionId"}, new Object[]{session.getID_Sch_Session()})).sort();
	}

	/**
	 * check Booking Rights for this Role and Session
	 */
	public Boolean hasBookingRights(IAppRole role, Sch_SessionRefVo session)
	{
		if (role == null)
			throw new CodingRuntimeException("role is null in method hasBookingRights");
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method hasBookingRights");

		DomainFactory factory = getDomainFactory();
		String hql = "select count(bookRight.id) from Sch_Session as session left join session.sch_Profile as profile left join profile.bookingRights as bookRight where (session.id = :idSession and bookRight.role.id = :idRole)"; //WDEV-21137

		int count = -1;
		List lstCount = factory.find(hql, new String[]{"idSession", "idRole"}, new Object[]{session.getID_Sch_Session(), role.getId()});
		Iterator it = lstCount.iterator();
		if (it.hasNext())
		{
			Long res = (Long) it.next();
			count = res.intValue();
		}

		return count > 0;
	}

	/**
	 * listLocationLite
	 */
	public ims.core.vo.LocationLiteVoCollection listLocationLite()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listLocationLiteByName(null);
	}

	/**
	 * getCurrentMonth
	 */
	public ims.framework.utils.Date getCurrentMonth(ims.core.vo.ActivityVo activity, ims.core.clinical.vo.ServiceRefVo service, ims.core.resource.place.vo.LocationRefVo location, ServiceFunctionRefVo clinicType, LocationRefVoCollection locationList, HcpLiteVo listOwner, ProfileListType listType) //wdev-19419
	{
		if (activity == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listGenericSession");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		String serviceCriteria = "";
		String listtypeCriteria = "";	//wdev-19419
		String locationCriteria = "";
		String clinicTypeCriteria = "";
		String clinicTypeJoin = "";
		//wdev-19419
		String listOwnerJoin = "";
		String listOwnerCriteria = "";
		//----------

		markers.add("activityId");
		markers.add("open");
		markers.add("today");

		values.add(activity.getID_Activity());
		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		values.add(new Date().getDate());

		if (service != null)
		{
			markers.add("idService");
			values.add(service.getID_Service());
			serviceCriteria = " and session.service.id = :idService";
		}
		//wdev-19419
		if (listOwner != null)
		{
			markers.add("idListOwner");
			values.add(listOwner.getID_Hcp());
			listOwnerJoin = " left join session.listOwners as lowners left join lowners.hcp shcp ";
			listOwnerCriteria = " and shcp.id = :idListOwner ";
		}
		
		if( listType != null)
		{
			markers.add("idlistType");
			values.add(getDomLookup(listType).getId());
			listtypeCriteria = " and session.listType.id = :idlistType";
		
		}
		//-----------
		if (location != null)
		{
			markers.add("idLocation");
			values.add(location.getID_Location());
			locationCriteria = " and session.schLocation.id = :idLocation";
		}
		else if(locationList != null)
		{
			List<String> locationIds = new ArrayList<String>();
			for(LocationRefVo voRef : locationList)
				locationIds.add(voRef.getID_Location().toString());
		
			locationCriteria = " and session.schLocation.id in (" + getIdString(locationIds) + ")";
		}
		if (clinicType != null)
		{
			markers.add("idClinicType");
			values.add(clinicType.getID_ServiceFunction());
			clinicTypeJoin = " join slot.functions as func ";
			clinicTypeCriteria = " and func.id = :idClinicType ";
		}

		DomainFactory factory = getDomainFactory();

		markers.add("OUTPATIENT_SESSION");
		values.add(SchProfileType.OUTPATIENT.getID());
		List date = factory.find(" Select min (session.sessionDate) from Sch_Session as session " + " left join session.sessionSlots as slot " + clinicTypeJoin + listOwnerJoin + " where ( slot.activity.id = :activityId) " + serviceCriteria + locationCriteria + clinicTypeCriteria + listOwnerCriteria + listtypeCriteria + " and session.sessionStatus = :open and session.sessionDate >= :today  and (session.sessionProfileType.id = :OUTPATIENT_SESSION)", markers, values, 1000); //wdev-19419

		if (date != null && date.get(0) != null)
			return new ims.framework.utils.Date((java.util.Date) date.get(0));

		return null;
	}

	/**
	 * getReferralDetail - Referral Booking Vo contains all the data for the top
	 * panel (Referral Details) - in the Booking Screen for CARE_UK
	 */
	public ims.RefMan.vo.ReferralBookingVo getReferralDetail(ims.RefMan.vo.CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provide for method getReferralDetail");

		DomainFactory factory = getDomainFactory();

		ReferralBookingVo voReferralBooking = new ReferralBookingVo();

		CatsReferral doCatsRef = (CatsReferral) factory.getDomainObject(catsReferral);
		if (doCatsRef != null)
		{
			java.util.Date triageDateTime = doCatsRef.getTriageDateTime();
			if (triageDateTime != null)
				voReferralBooking.setTriageDateTime(new ims.framework.utils.DateTime(triageDateTime));

			ReferralLetterDetailsBookingVo voReferralLetterDetail = ReferralLetterDetailsBookingVoAssembler.create(doCatsRef.getReferralDetails());
			
			if (voReferralLetterDetail != null)
			{
				//WDEV-20181
				CatsReferralListVo voCatsRef = CatsReferralListVoAssembler.create(doCatsRef);
				ContractServiceLocationsConfigVo contrServiceLocationConf=getContractServiceLocConf(voCatsRef.getContract(), voCatsRef.getReferralDetails().getService());
				
				if (contrServiceLocationConf!=null && contrServiceLocationConf.getDaysToRTTBreachDateIsNotNull())
				{
					voReferralLetterDetail.setDaysToRTTBreachDate(contrServiceLocationConf.getDaysToRTTBreachDate());
				}
				else if (doCatsRef.getContract() != null) //WDEV-11713
				{
					voReferralLetterDetail.setDaysToRTTBreachDate(doCatsRef.getContract().getDaysToRTTBreachDate());
				}
				if (getDomLookup(ReferralUrgency.TWO_WEEK_WAIT).equals(doCatsRef.getUrgency()))//WDEV-20432
				{
					voReferralLetterDetail.setDayTo1stApp(TWO_WEEK_WAIT_TO_1ST_APP);
				}
				else
				{
					if (contrServiceLocationConf!=null && contrServiceLocationConf.getDaysTo1stApptIsNotNull())
					{
						voReferralLetterDetail.setDayTo1stApp(contrServiceLocationConf.getDaysTo1stAppt());
					}
					else if (doCatsRef.getContract() != null)//WDEV-11713
					{
						voReferralLetterDetail.setDayTo1stApp(doCatsRef.getContract().getDaysTo1stAppt());
					}
				}
				ExclusionDatesVo voExDate = listExclusionDates();
				
				// WDEV-13456
				// KPI dates are calculated based on days till first appointment
				if (voReferralLetterDetail.getDayTo1stAppIsNotNull())
				{
					Date[] arrDates = ExclusionDatesVo.getKPIDays(voReferralLetterDetail.getDateReferralReceived(), voReferralLetterDetail.getDayTo1stApp(), voExDate != null ? voExDate.getDates() : null, true);//WDEV-11713 & WDEV-12918
					voReferralLetterDetail.setKPIDays(arrDates);
					if (voReferralLetterDetail.getDateOfReferral() != null)
						voReferralLetterDetail.setEndXdayKPI(ExclusionDatesVo.addBusinessDays(voReferralLetterDetail.getDateOfReferral(), voReferralLetterDetail.getDayTo1stApp(), voExDate != null ? voExDate.getDates() : null, true));//WDEV-11713 & WDEV-12918
				}
				//WDEV-21042  bug fix - if the referral did not have a KPI (Emergency Referral), the referral details was not being set correctly
				voReferralBooking.setReferralLetterDetail(voReferralLetterDetail);
				
				voReferralBooking.setTriageOutcome(TriageOutcomeForBookAppointmentVoAssembler.create(doCatsRef.getTriageOutcome()));
			}
			
			//WDEV-18411
			if (doCatsRef.getReferralCategory() != null)
			{	
				voReferralBooking.setReferralCategory(LookupHelper.getCatsReferralCategoryInstance(getLookupService(), doCatsRef.getReferralCategory().getId()));
			}
		}

		// CurrentAppts - appts with status of appt_booked for Referral
		List currentAppts = factory.find("select appt from CatsReferral as catsRef join catsRef.appointments as appt where (catsRef.id = :idCatsRef and appt.apptStatus = :bookedStatus and appt.theatreBooking is null )", new String[]{"idCatsRef", "bookedStatus"}, new Object[]{catsReferral.getID_CatsReferral(), getDomLookup(Status_Reason.BOOKED)});
		voReferralBooking.setCurrentAppointments(BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(currentAppts));

		// Appts Requiring Rebook for Referral
		List rebookAppts = factory.find("select appt from CatsReferral as catsRef join catsRef.appointments as appt where (catsRef.id = :idCatsRef and appt.requiresRebook = 1  and appt.theatreBooking is null )", new String[]{"idCatsRef"}, new Object[]{catsReferral.getID_CatsReferral()});
		voReferralBooking.setAppointmentsRequiringRebook(BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(rebookAppts));

		//Theatre Appts - WDEV-7653
		List theatreAppts = factory.find("select appt from CatsReferral as catsRef join catsRef.appointments as appt where (catsRef.id = :idCatsRef and appt.theatreBooking <> null )", new String[]{"idCatsRef"}, new Object[]{catsReferral.getID_CatsReferral()});
		voReferralBooking.setOtherAppointments(BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(theatreAppts));
		
		// Invs Requiring an appt - For the CatsReferral - orderInvestigations
		// that are in the InvestigationOrders Collection and not in the
		// collection of OrderInvAppt
		List ordInvs = listInvsRequiringAppt(catsReferral, factory);
		voReferralBooking.setOrdersRequiringAppt(OrderInvestigationBookingVoAssembler.createOrderInvestigationBookingVoCollectionFromOrderInvestigation(ordInvs));
		
		voReferralBooking.setReferralEROD(getLastOutpatientEROD(catsReferral));
		
		if(doCatsRef != null && doCatsRef.getJourney() != null && doCatsRef.getJourney().getCurrentClock() != null)
		{
			voReferralBooking.setCurrentClock(new PathwayClockRefVo(doCatsRef.getJourney().getCurrentClock().getId(), doCatsRef.getJourney().getCurrentClock().getVersion()));
		}
		
		voReferralBooking.setIsCAB(doCatsRef.isIsCAB());
		
		List tciColl = factory.find("select pel.tCIDetails	from PatientElectiveList as pel left join pel.referral as cats left join pel.tCIDetails as tcid where cats.id = :idCatsRef and tcid.isActive = 1", new String[]{"idCatsRef"}, new Object[]{catsReferral.getID_CatsReferral()});
		voReferralBooking.setCurrentTCIs(TCIForReferralBookingVoAssembler.createTCIForReferralBookingVoCollectionFromTCIForPatientElectiveList(tciColl));
		
		return voReferralBooking;
	}

	//WDEV-20181
	private ContractServiceLocationsConfigVo getContractServiceLocConf(ContractConfigRefVo contract, ServiceRefVo service)
	{
		ContractConfiguration impl = (ContractConfiguration) getDomainImpl(ContractConfigurationImpl.class);
		return impl.getContractServiceLocConfByContractService(contract,service);
	}

	
	// Invs Requiring an appt - For the CatsReferral - orderInvestigations that
	// are in the InvestigationOrders Collection and not in the collection of
	// OrderInvAppt
	private List listInvsRequiringAppt(ims.RefMan.vo.CatsReferralRefVo catsReferral, DomainFactory factory)
	{
		String hql = "select ordInv from CatsReferral as catsRef " + "join catsRef.investigationOrders as ocsOrder join ocsOrder.investigations as ordInv left join ordInv.investigation.providerService as provService left join provService.locationService.service as service " + "where (catsRef.id = :idCatsRef and (service.canBeScheduled = 1  ) " + "and ordInv.id not in " + "(select ordInv1.id from CatsReferral as catsRef1 " + "join  catsRef1.orderInvAppts as ordInvAppt " + "join ordInvAppt.orderInvestigation as ordInv1" + " where catsRef1.id = :idCatsRef) and ordInv.ordInvCurrentStatus.ordInvStatus.id not in (:cancelled,:cancelledrequest))";
		return factory.find(hql, new String[]{"idCatsRef", "cancelled", "cancelledrequest"}, new Object[]{catsReferral.getID_CatsReferral(), OrderInvStatus.CANCELLED.getID(), OrderInvStatus.CANCEL_REQUEST.getID()});
	}

	/**
	 * listExclusionDates
	 */
	public ims.scheduling.vo.ExclusionDatesVo listExclusionDates()
	{
		ExclusionDates impl = (ExclusionDates) getDomainImpl(ExclusionDatesImpl.class);
		return impl.listExclusionDates();
	}

	// WDEV-5283 was an incorrect issue - have rolled back to the original implementation (dlaffan)
	private void cancelPublishedSlots(Session_Slot doSessionSlot) throws StaleObjectException
	{
		ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
		impl.cancelSlot(SessionSlotVoAssembler.create(doSessionSlot), ActionRequestType.NOTIFY_SLOT_CANCEL, "Cancel Slot requested as Appointment Booked");
	}
	
	public Sch_BookingVo getSch_BookingByAppt(Booking_AppointmentRefVo appt)
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided for method getSch_BookingByAppt");

		Sch_BookingVo voBooking = null;
		List bookings = getDomainFactory().find("select book from Sch_Booking book left join book.appointments as appt where appt.id = '" + appt.getID_Booking_Appointment() + "'");
		if (bookings != null && bookings.size() == 1)
		{
			voBooking = Sch_BookingVoAssembler.create((Sch_Booking) bookings.get(0));
			if (voBooking != null && voBooking.getAppointments() != null)
			{
				for (int i = 0; i < voBooking.getAppointments().size(); i++)
				{
					// SITE-508 get the associatedOrderInv at this point if any
					setOrderInvAppt(voBooking.getAppointments().get(i));
				}
			}
			return voBooking;
		}

		return null;
	}

	public Booking_AppointmentVo getBookingAppointment(Booking_AppointmentRefVo appt)
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided for method getBookingAppointment");

		Booking_AppointmentVo voAppt = Booking_AppointmentVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(appt));
		// SITE-508 get the associatedOrderInv at this point if any
		setOrderInvAppt(voAppt);

		return voAppt;
	}

	// getting the order inv for this appt if any
	private void setOrderInvAppt(Booking_AppointmentVo voAppt)
	{
		if (voAppt == null)
			return;

		List ordInvAppts = getDomainFactory().find("from OrderInvAppt invAppt where invAppt.appointment.id = '" + voAppt.getID_Booking_Appointment() + "'");
		if (ordInvAppts != null && ordInvAppts.size() == 1)
		{
			OrderInvAppt doOrdInvAppt = (OrderInvAppt) ordInvAppts.get(0);
			voAppt.setOrderInvestigation(OrderInvestigationBookingVoAssembler.create(doOrdInvAppt.getOrderInvestigation()));
		}
	}

	public ServiceShortVoCollection listActiveService()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		ServiceShortVo voService = new ServiceShortVo();
		voService.setIsActive(Boolean.TRUE);
		return impl.listService(voService);
	}

	public ProfileLiteVoCollection listProfileLiteByService(ServiceRefVo service)
	{
		if (service == null || service.getID_Service() == null)
			throw new CodingRuntimeException("service parameter null or id not provided for listSessionLiteByService");

		DomainFactory factory = getDomainFactory();
		List profiles = factory.find("from Sch_Profile prof where prof.service.id = :idService", new String[]{"idService"}, new Object[]{service.getID_Service()});
		return ProfileLiteVoAssembler.createProfileLiteVoCollectionFromSch_Profile(profiles);
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appt) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral,appt);
		
		updateActiveMonitoring(catsReferral);
	}

	private void updateActiveMonitoring(CatsReferralRefVo catsReferral) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		if (doCatsReferral.getCurrentStatus() != null
			&& doCatsReferral.getCurrentStatus().getReferralStatus().equals(getDomLookup(ReferralApptStatus.ACTIVE_MONITORING))
			&& doCatsReferral.isIsActiveMonitorApptRequired().booleanValue())
		{
			doCatsReferral.setIsActiveMonitorApptRequired(Boolean.FALSE);

			factory.save(doCatsReferral);
		}
	}

	public SessionSlotListVoCollection addSlotsToSession(SessionShortVo session, SessionSlotVoCollection slots) throws StaleObjectException
	{
		if (session == null)
			throw new CodingRuntimeException("session is null in method addSlotToSession");

		if (slots == null || slots.size() == 0)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Sch_Session doSession = (Sch_Session) factory.getDomainObject(session);
		SessionSlotListVoCollection slotsCollection = new SessionSlotListVoCollection();
		
		// update remaining slots
		int remainingSlots = doSession.getRemainingSlots();
		remainingSlots += slots.size();
		int totalslots = doSession.getTotalSlots();
		totalslots += slots.size();
		
		ArrayList list = new ArrayList();
		
		for (int i = 0; i < slots.size(); i++)
		{
			Session_Slot doSlot = SessionSlotVoAssembler.extractSession_Slot(factory, slots.get(i));
			doSlot.setDirectAccessSlot(getDomLookup(SchedCABSlotType.LOCAL));
			doSlot.setSession(doSession);
			doSlot.setIsActive(true);
			doSession.getSessionSlots().add(doSlot);
			
			list.add(doSlot);
		}
		
		doSession.setRemainingSlots(remainingSlots);
		doSession.setTotalSlots(totalslots);
		
		factory.save(doSession);
		
		for (int i = 0; i < list.size(); i++)
		{
			slotsCollection.add(SessionSlotListVoAssembler.create((Session_Slot) list.get(i)));
		}
		
		//WDEV-19326
		return slotsCollection;
	}

	/**
	 * NB - This method is called from a web service and therefore should only
	 * be modified with extreme caution (dlaffan)
	 * 
	 * WDEV-7448 - If PukkaJ interface is enabled this method will attempt to
	 * send a cancel message to PukkaJ by creating an entry in OcsExternalEvent
	 * 
	 * @param doCatsReferral
	 * @param voAppt
	 * @throws StaleObjectException
	 */
	public void cancelAppointmentForPukkaJ(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appt) throws StaleObjectException
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided in method processAppointmentForPukkaJ");
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method processAppointmentForPukkaJ");

		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);

		if (doCatsReferral.getContract() != null
				&& doCatsReferral.getContract().getContractType() != null
				&& doCatsReferral.getContract().getContractType().getId() != ReferralManagementContractType.DIAGNOSTIC.getId())
				return;

		Booking_Appointment doAppt = (Booking_Appointment) factory.getDomainObject(appt);

		if (doCatsReferral.getAppointments().size() > 0)
		{
			Iterator it = doCatsReferral.getAppointments().iterator();

			if (doAppt.getApptStatus() != null && (doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED))))
			{
				if (countExistingReferralAppts(doCatsReferral, Status_Reason.BOOKED) == 0)
				{
					Iterator itOrdInvA = doCatsReferral.getOrderInvAppts().iterator();
					OrderInvAppt doOrdInvAppt = null;
					if(itOrdInvA.hasNext())
						doOrdInvAppt = (OrderInvAppt) itOrdInvA.next();
					
					//WDEV-7448 - null pointer fix here - code was presuming that an ordInvAppt always exists
					if(doOrdInvAppt != null)
					{
						doOrdInvAppt.getOrderInvestigation().setAppointmentDate(null);
						factory.save(doOrdInvAppt.getOrderInvestigation());
						doCatsReferral.getOrderInvAppts().remove(doOrdInvAppt);
						try
						{
							factory.delete(doOrdInvAppt);
						}
						catch (ForeignKeyViolationException e)
						{
							throw new DomainRuntimeException(e.getMessage());
						}
						factory.save(doCatsReferral);
				
					
						OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
						impl.generateOrderUpdateEvent(new Booking_AppointmentRefVo(doAppt.getId(), doAppt.getVersion()), new OrderInvestigationRefVo(doOrdInvAppt.getOrderInvestigation().getId(), doOrdInvAppt.getOrderInvestigation().getVersion()));
					}
				}
			}
		}
		
	}

	public PatientICPFullVo getPatientICP(CareContextRefVo careCOntextRefVo)
	{
		if(careCOntextRefVo != null)
		{
			DomainFactory factory = getDomainFactory();
			StringBuffer hql = new StringBuffer(" from PatientICP pICP where "); 
			String andStr = " ";
		
			ArrayList<String> markers = new ArrayList<String>();
			ArrayList<Serializable> values = new ArrayList<Serializable>();
		
			hql.append(andStr + " pICP.careContext.id = :pICPID");
 			markers.add("pICPID");
			values.add(careCOntextRefVo.getID_CareContext());
			andStr = " and ";	

			hql.append(andStr + " pICP.completedDateTime = null");
 			andStr = " and ";	

			List listAdditional = factory.find(hql.toString(), markers,values);
			if(listAdditional != null && listAdditional.size() > 0)
			{ 
				PatientICPFullVoCollection voColl = PatientICPFullVoAssembler.createPatientICPFullVoCollectionFromPatientICP(listAdditional);
				if(voColl != null && voColl.size() > 0)
					return voColl.get(0);
			}
		}
		return null;
	}

	public PatientICPFullVo savePatientICP(PatientICPFullVo pateintICPVo) throws DomainInterfaceException, StaleObjectException 
	{
		if(pateintICPVo == null)
			throw new CodingRuntimeException("Invalid patientICPVo");
		if(!pateintICPVo.isValidated())
			throw new CodingRuntimeException("patientICPVo not validated");
		
		DomainFactory factory = getDomainFactory();
		PatientICP domainObject = PatientICPFullVoAssembler.extractPatientICP(factory, pateintICPVo);
		
		factory.save(domainObject);
		
		return PatientICPFullVoAssembler.create(domainObject);
	}

	//WDEV-10010
	public LocationLiteVoCollection listLocationLiteForReferralContract(CatsReferralRefVo referral)
	{
		SelectandOrder impl = (SelectandOrder) getDomainImpl(SelectandOrderImpl.class);
		return impl.listLocationLiteForReferralContract(referral,true); //WDEV-10431
	}

	//wdev-12826
	public CatsReferralListVo getCatsReferral(CatsReferralRefVo catsrefVo) {
		// TODO Auto-generated method stub
		return CatsReferralListVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, catsrefVo.getID_CatsReferral()));
	}

	/**
	 * Function used to check if a referral has 'Safety questionnaire' completed for the modality (Speciality) given
	 */
	public Boolean hasSafetyQuestionnarie(CatsReferralRefVo referral, ServiceRefVo service)
	{
		if (referral == null || service == null)
			throw new CodingRuntimeException("Can not retrieve 'Safety Questionnaire' for null referral or null service.");
		
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT COUNT (docs.id) FROM PatientDocument AS docs LEFT JOIN docs.careContext AS docContext LEFT JOIN docs.services AS service, ");
		query.append(" CatsReferral AS referral LEFT JOIN referral.careContext AS refContext ");
		query.append(" WHERE docContext.id = refContext.id AND referral.id = :REF_ID AND service.id = :SRV_ID ");

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("REF_ID");	paramValues.add(referral.getID_CatsReferral());
		paramNames.add("SRV_ID");	paramValues.add(service.getID_Service());
		
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray());

		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public ReferralERODVo getLastOutpatientEROD(CatsReferralRefVo catsReferral)
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List lastOutpatientErod = factory.find("select outErod from CatsReferral as cats left join cats.outpatientEROD as outErod where cats.id = :CatsReferralId and (outErod.isRIE is null or outErod.isRIE = 0) and outErod.sequence = (select max(outErodSec.sequence) from CatsReferral as catsSec left join catsSec.outpatientEROD as outErodSec where catsSec.id = :CatsReferralId and (outErodSec.isRIE is null or outErodSec.isRIE = 0))", new String[] {"CatsReferralId"}, new Object[] {catsReferral.getID_CatsReferral()});
			
		if(lastOutpatientErod != null && lastOutpatientErod.size() > 0 && lastOutpatientErod.get(0) instanceof ReferralEROD)
		{
			return ReferralERODVoAssembler.create((ReferralEROD) lastOutpatientErod.get(0));
		}
			
		return null;
	}
	
	public ReferralEROD getLastSavedOutpatientEROD(CatsReferral catsReferralDO)
	{
		if(catsReferralDO == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List<?> lastOutpatientErod = factory.find("select outErod from CatsReferral as cats left join cats.outpatientEROD as outErod where cats.id = :CatsReferralId and (outErod.isRIE is null or outErod.isRIE = 0) and outErod.sequence = (select max(outErodSec.sequence) from CatsReferral as catsSec left join catsSec.outpatientEROD as outErodSec where catsSec.id = :CatsReferralId and (outErodSec.isRIE is null or outErodSec.isRIE = 0))", new String[] {"CatsReferralId"}, new Object[] {catsReferralDO.getId()});
			
		if(lastOutpatientErod != null && lastOutpatientErod.size() > 0 && lastOutpatientErod.get(0) instanceof ReferralEROD)
		{
			return (ReferralEROD) lastOutpatientErod.get(0);
		}
			
		return null;
	}
	
	public synchronized Sch_BookingVo saveBooking(Sch_BookingVo voBooking,	CatsReferralRefVo catsRef,	Boolean isRebook, ReferralERODForBookAppointmentVoCollection outpatientERODCollection, Boolean isERODUpdatedOnBooking, BookingAppointmentForLinkedAppointmentsVoCollection linkApptsColl, Booking_AppointmentVoCollection linkMultipleBookingApptsColl) throws DomainInterfaceException, StaleObjectException  //WDEV-19543 //WDEV-20053
	{
		if (voBooking == null)
			throw new CodingRuntimeException("voBooking is null in method saveBooking");

		DomainFactory factory = getDomainFactory();
		
		if (ConfigFlag.GEN.CREATE_ICP_ON_ACCEPTANCE_OF_REFERRAL.getValue())
		{
			if (catsRef != null && catsRef.getID_CatsReferralIsNotNull())
			{
				
			String hql = "select count(patICP.id) from PatientICP as patICP left join patICP.careContext as careC," +
					" CatsReferral as cats left join cats.careContext as catsCC " +
					"where (cats.id = :catsId and patICP.completedDateTime is not null and catsCC.id = careC.id)";
			long count = getDomainFactory().countWithHQL(hql,new String[]{"catsId"},new Object[]{catsRef.getID_CatsReferral()});
			if (count > 0 )
				throw new DomainInterfaceException("Can not book an appointment on a referral that has a linked ICP that is Closed");
			}
		}
		
		//wdev-12090
		if((isRebook != null && isRebook == true) && voBooking.getSessionSlotDNAorDisplacedIsNotNull())
		{
			SessionSlotVo sessionSlot = voBooking.getSessionSlotDNAorDisplaced();
			 
			sessionSlot.setAppointment(null);
			Session_Slot doSessionSlot = SessionSlotVoAssembler.extractSession_Slot(factory, sessionSlot);
			factory.save(doSessionSlot);
		}
		//-------------
		
		
		// OrdInvAppt
		OrderInvApptVoCollection voCollOrdInvAppt = getOrdinvApptCollection(voBooking);
		HashMap objMap = new HashMap();
		Set doOrderInvAppts = OrderInvApptVoAssembler.extractOrderInvApptSet(factory, voCollOrdInvAppt, null, objMap);
		
		Sch_Booking doBooking = Sch_BookingVoAssembler.extractSch_Booking(factory, voBooking, objMap);

		// If CatsReferral record is in scope ie. Appointment booked through UI
		// associate the created appointments with the catsReferral record and
		// patient from cats referral with booking
		CatsReferral doCatsReferral = null;
		if (catsRef != null && catsRef.getID_CatsReferralIsNotNull())
		{
			doCatsReferral = (CatsReferral) factory.getDomainObject(catsRef);
			doBooking.setPatient(doCatsReferral.getPatient());
		}
		
		//http://jira/browse/WDEV-21154 first activity for referral
		if(doCatsReferral!=null&&doCatsReferral.getReferralDetails()!=null&&doCatsReferral.getReferralDetails().getService()!=null 
				&&doCatsReferral.getReferralDetails().getService().getId()!=null 
				&&doBooking!=null&&doBooking.getAppointments()!=null)
		{
			Date referralDate = new ims.framework.utils.Date (doCatsReferral.getReferralDetails().getDateOfReferral());
			for (Object obj : doBooking.getAppointments())
			{
				Booking_Appointment appt = (Booking_Appointment)obj;
				if(appt.getSession()!=null&&appt.getSession().getService()!=null&&appt.getSession().getService().getId()!=null
						&&appt.getSession().getService().getId().equals(doCatsReferral.getReferralDetails().getService().getId()))//&&!isCancerPathwayReferral(catsRef) //WDEV-21454
//						&&referralDate!=null
//						&&!doCatsReferral.getPatient().isPaediatricOn(referralDate.getDate()))
				{
					appt.setFirstActivityForReferral(Boolean.TRUE);
				}
			}
		}

		icabBooking = false;
		Booking_Appointment doConsultationAppt = arrangeAppointmentsInReferralAndSavePatient(doBooking, doCatsReferral);
		
		//WDEV-20333 save the childSlots
		if (voBooking.getAppointments() != null)
		{
			for (int i = 0; i < voBooking.getAppointments().size(); i++)
			{
				Booking_AppointmentVo appointment = voBooking.getAppointments().get(i);
				
				if (!Boolean.TRUE.equals(appointment.getIsFlexibleAppointment()) || appointment.getParentChildSlot() == null) //make sure the appointment is flexible and has slots (wasn't cancelled)
					continue;
				
				if (appointment.getParentChildSlot().getChildSlots() != null)
				{
					SessionParentChildSlot doParentSlot = (SessionParentChildSlot) factory.getDomainObject(appointment.getParentChildSlot());
					
					for (int j = 0; j < appointment.getParentChildSlot().getChildSlots().size(); j++)
					{
						SessionParentChildSlot doSlot = (SessionParentChildSlot) factory.getDomainObject(appointment.getParentChildSlot().getChildSlots().get(j));
						
						//WDEV-22596 slot may have already been booked
						if (appointment.getParentChildSlot().getChildSlots().get(j).getVersion_SessionParentChildSlot() != doSlot.getVersion())
						{
							throw new StaleObjectException(doSlot);
						}
						
						doSlot.setParentSlot(doParentSlot);
						doSlot.setStatus(getDomLookup(Status_Reason.BOOKED));
						
						try
						{
							factory.save(doSlot);
						}
						catch(LockAcquisitionException e)
						{
							throw new DomainInterfaceException("A database lock has occurred. This could be because another user has booked into this Slot or Session. Please try again.");
						}
					}
				}
			}
		}
		
		if (icabBooking) //WDEV-23584
		{
			if (doBooking.getFirstAppointment() != null)
			{
				doBooking.getFirstAppointment().setFirstConsultationActivity(Boolean.TRUE);
				doBooking.getFirstAppointment().setFirstActivityForReferral(Boolean.TRUE);
			}

			if (doBooking.getAppointments() != null)
			{
				for (Object obj : doBooking.getAppointments())
				{
					Booking_Appointment appt = (Booking_Appointment) obj;

					if (appt != null)
					{
						appt.setFirstConsultationActivity(Boolean.TRUE);
						appt.setFirstActivityForReferral(Boolean.TRUE);
					}
				}
			}
		}
		
		factory.save(doBooking);
	
		// WDEV-19489
		createCaseNoteRequests(Sch_BookingVoAssembler.create(doBooking));
		
		//WDEV-20053
		Sch_BookingApptForLinkedAppointmentsVo schBookLinkApptVo = Sch_BookingApptForLinkedAppointmentsVoAssembler.create(doBooking);
		if (schBookLinkApptVo.getAppointments()!=null && schBookLinkApptVo.getAppointments().size()==1 && linkApptsColl!=null && linkApptsColl.size()>0)
		{
			saveLinkApptsBackwards(factory,linkApptsColl,schBookLinkApptVo.getAppointments().get(0));
			
			//WDEV-20764
			BookingAppointmentForLinkedAppointmentsVo bookingAppointmentToBeLinked = schBookLinkApptVo.getAppointments().get(0);
			if (bookingAppointmentToBeLinked!=null && !Boolean.TRUE.equals(bookingAppointmentToBeLinked.getFirstConsultationActivity()) && isFirstConsultationActivitySetForAnyApptsFromColl(linkApptsColl))
			{
				bookingAppointmentToBeLinked.setFirstConsultationActivity(true);
				Booking_Appointment doBookAppt = BookingAppointmentForLinkedAppointmentsVoAssembler.extractBooking_Appointment(factory, bookingAppointmentToBeLinked);
				factory.save(doBookAppt);
			}
		}
		else if (schBookLinkApptVo.getAppointments()!=null && schBookLinkApptVo.getAppointments().size()>1 && linkMultipleBookingApptsColl!=null && linkMultipleBookingApptsColl.size()>0) 
		{
			linkApptsBetween(factory,getCollectionToLinkBetween(schBookLinkApptVo,linkMultipleBookingApptsColl));
		}
		
		
		savePatientElectiveListWithFisrtApptBooked(factory,doBooking); //WDEV-21037
		
		// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
		// When booking a first activity appointment - use the booking date for RTT Status (the date the appointment is created, not the appointment date)
		java.util.Date eventDateTime = new java.util.Date();
		
		
		if (doCatsReferral != null)
		{
			doCatsReferral.getAppointments().addAll(doBooking.getAppointments());
			doCatsReferral.getOrderInvAppts().addAll(doOrderInvAppts);
			
			//WDEV-18421
			// WDEV-23784 ReferralEROD doRefEROD = getLastSavedOutpatientEROD(doCatsReferral);  Removed as caused lock acquisition errors
			
			// WDEV-5727 - consultation appt
			doCatsReferral.setConsultationAppt(doConsultationAppt);
			// WDEV-5727 - has appointments
			doCatsReferral.setHasAppointments(true);
			
			if(outpatientERODCollection != null && outpatientERODCollection.size() > 0)
			{
				doCatsReferral.setOutpatientEROD(createdReferralERODCollection(factory, doCatsReferral.getOutpatientEROD(), outpatientERODCollection, objMap));
			}
			
			//WDEV-18421 
			Booking_Appointment firstApptDO = getFirstAppointmentBooking(doBooking);
			
			if (firstApptDO != null)
			{					
				createNewPathwayClockAndEvent(doCatsReferral,firstApptDO, eventDateTime);
			}	
						
//	WDEV-23784	if (doCatsReferral!= null && firstApptDO != null && isERODUpdatedOnBooking)
//			{	
//				 doRefEROD.setAppointment(firstApptDO);
//				 factory.save(doRefEROD);
//			}
			//WDEV-21189
			if (hasReferralTriageSingleOpaAction(doCatsReferral) && doConsultationAppt != null)
			{
				doCatsReferral.setConsultationActivityRequired(false);
			}
			factory.save(doCatsReferral);
		}
		
		if(doCatsReferral != null
			&& doCatsReferral.getContract() != null
			&& doCatsReferral.getContract().getContractType() != null
			&& doCatsReferral.getContract().getContractType().getId() == ReferralManagementContractType.DIAGNOSTIC.getId())
		{
			//for linking in the maxims UI
			if(icabBooking == false)
			{
				if(doOrderInvAppts != null)
				{
					OrderInvAppt doOrdInvA = null;
					if(doOrderInvAppts.size() > 0)
					{
						Iterator it = doOrderInvAppts.iterator();
						if(it.hasNext())
						{
							doOrdInvA = (OrderInvAppt) it.next();
						}
					}
					if(doOrdInvA != null)
					{
						OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
						impl.generateOrderUpdateEvent(new Booking_AppointmentRefVo(doOrdInvA.getAppointment().getId(), doOrdInvA.getAppointment().getVersion()), new OrderInvestigationRefVo(doOrdInvA.getOrderInvestigation().getId(), doOrdInvA.getOrderInvestigation().getVersion()));
					}
				}
			}
		}
		else
			RefManMessaging(isRebook, factory, doOrderInvAppts, doBooking, doCatsReferral);
		
		
		// WDEV-5283 - only if not booked through ICAB
		if (ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			Iterator it = doBooking.getAppointments().iterator();
			while (it.hasNext())
			{
				Booking_Appointment doAppt = (Booking_Appointment) it.next();
				if (doAppt.getSessionSlot() != null)
					cancelPublishedSlots(doAppt.getSessionSlot());
			}
		}

		// booking is from CAB, we need to see if we need to create a referral
		// record
		if (icabBooking)
			checkReferral(factory, doBooking, eventDateTime);

//		WDEV-15944 Is it possible to create a pathway event based on this booking?
		if (ConfigFlag.DOM.INSTANTIATE_EVENT_FROM_SCHEDULING.getValue())
		{
			ims.scheduling.domain.BookAppointment impl = (ims.scheduling.domain.BookAppointment) getDomainImpl(ims.scheduling.domain.impl.BookAppointmentImpl.class);
			impl.instantiateEvent(Booking_AppointmentVoAssembler.create(doBooking.getFirstAppointment()),isRebook?"R":"B", "Booking from Appointment Booking form");
		}
		return Sch_BookingVoAssembler.create(doBooking);
	}
	//WDEV-21189
	private boolean hasReferralTriageSingleOpaAction(CatsReferral doCatsReferral)
	{
		if (doCatsReferral == null || doCatsReferral.getTriageOutcome() == null ||  doCatsReferral.getTriageOutcome().getAcceptedDetails() == null || doCatsReferral.getTriageOutcome().getAcceptedDetails().getActionRequired() == null)
			return false;
		return (AcceptedActionsRequired.OPA.getID() == doCatsReferral.getTriageOutcome().getAcceptedDetails().getActionRequired().getId() ||
				AcceptedActionsRequired.DIRECT_TO_LIST_AND_OPA.getID() == doCatsReferral.getTriageOutcome().getAcceptedDetails().getActionRequired().getId() ||
				AcceptedActionsRequired.LINKED_OPA_AND_DIAGNOSTICS.getID() == doCatsReferral.getTriageOutcome().getAcceptedDetails().getActionRequired().getId() ||
				AcceptedActionsRequired.CHANGE_CAB_OPA.getID() == doCatsReferral.getTriageOutcome().getAcceptedDetails().getActionRequired().getId());			
	}

	//WDEV-21037
	private void savePatientElectiveListWithFisrtApptBooked(DomainFactory factory, Sch_Booking doBooking) throws StaleObjectException
	{
		
		if (doBooking==null || doBooking.getAppointments()==null || doBooking.getAppointments().size()==0)
			return;
		
		Sch_BookingVo schBooking = Sch_BookingVoAssembler.create(doBooking);
		Booking_AppointmentVoCollection collAppts = schBooking.getAppointments();
		collAppts=collAppts.sort(SortOrder.ASCENDING);
		Booking_AppointmentVo firstApptBooked = collAppts.get(0);
		PatientElectiveListRefVo patientElectiveListRef=firstApptBooked!=null ? firstApptBooked.getElectiveList() : null;
		
		if (patientElectiveListRef!=null)
		{
			PatientElectiveList doPatElectiveList =(PatientElectiveList) factory.getDomainObject(patientElectiveListRef);
			if (doPatElectiveList!=null && doPatElectiveList.getPreAssessmentAppointment()==null)
			{
				Booking_Appointment doFirstApptBooked =(Booking_Appointment) factory.getDomainObject(firstApptBooked);
				doPatElectiveList.setPreAssessmentAppointment(doFirstApptBooked);
				if (doPatElectiveList.getPreAssessmentOutcome()!=null)
				{
					doPatElectiveList.getPreAssessmentOutcome().setPreAssessmentAppointment(doFirstApptBooked);
				}
				factory.save(doPatElectiveList);
			}
		}
		
		
	}

	//WDEV-20053
	private void linkApptsBetween(DomainFactory factory, BookingAppointmentForLinkedAppointmentsVoCollection collApts) throws StaleObjectException
	{
		if (collApts==null || collApts.size()==0)
			return;
		Boolean firstConsultationActivity = isFirstConsultationActivitySetForAnyApptsFromColl(collApts); //WDEV-20643
		for (int i=0;i<collApts.size();i++)
		{
			BookingAppointmentForLinkedAppointmentsVo appt = collApts.get(i);
			
			if (appt!=null)
			{
				BookingAppointmentForLinkedAppointmentsVoCollection collApptToBeLinked = (BookingAppointmentForLinkedAppointmentsVoCollection)collApts.clone();
				collApptToBeLinked.remove(appt);
				
				if (!Boolean.TRUE.equals(appt.getFirstConsultationActivity()) && firstConsultationActivity) //WDEV-20643
				{
					appt.setFirstConsultationActivity(true);
				}
				
				appt.setLinkedAppointments(collApptToBeLinked);
				
				Booking_Appointment doBookAppt = BookingAppointmentForLinkedAppointmentsVoAssembler.extractBooking_Appointment(factory, appt);
				factory.save(doBookAppt);
			}
		}
	}

	//WDEV-20643
	private Boolean isFirstConsultationActivitySetForAnyApptsFromColl(BookingAppointmentForLinkedAppointmentsVoCollection collApts)
	{
		if (collApts==null)
			return false;
		
		for (int i=0;i<collApts.size();i++)
		{		
			if (collApts.get(i).getActivityIsNotNull() &&  Boolean.TRUE.equals(collApts.get(i).getActivity().getFirstAppointment()) && Boolean.TRUE.equals(collApts.get(i).getFirstConsultationActivity())) //WDEV-20764
				return true;
		}
		
		return false;
	}

	//WDEV-20053
	private void saveLinkApptsBackwards(DomainFactory factory, BookingAppointmentForLinkedAppointmentsVoCollection linkApptsColl, BookingAppointmentForLinkedAppointmentsVo bookingAppointmentToBeLinked) throws StaleObjectException
	{
		if (linkApptsColl==null || bookingAppointmentToBeLinked==null)
			return;
		
		for (int i=0;i<linkApptsColl.size();i++)
		{		
			if (linkApptsColl.get(i).getLinkedAppointments()==null)
				linkApptsColl.get(i).setLinkedAppointments(new BookingAppointmentForLinkedAppointmentsVoCollection());
			
			if (Boolean.TRUE.equals(bookingAppointmentToBeLinked.getFirstConsultationActivity())) //WDEV-20643
			{
				linkApptsColl.get(i).setFirstConsultationActivity(true);
			}
			
			linkApptsColl.get(i).getLinkedAppointments().add(bookingAppointmentToBeLinked);
			Booking_Appointment doBookAppt = BookingAppointmentForLinkedAppointmentsVoAssembler.extractBooking_Appointment(factory, linkApptsColl.get(i));
			factory.save(doBookAppt);
		}
	}

	//WDEV-20053
	private BookingAppointmentForLinkedAppointmentsVoCollection getCollectionToLinkBetween(Sch_BookingApptForLinkedAppointmentsVo sch_BookingApptForLinkedAppointmentsVo, Booking_AppointmentVoCollection linkMultipleBookingApptsColl) throws StaleObjectException
	{
		BookingAppointmentForLinkedAppointmentsVoCollection collAppts = sch_BookingApptForLinkedAppointmentsVo.getAppointments();
		
		if (collAppts==null || collAppts.size()<=1 || linkMultipleBookingApptsColl==null || linkMultipleBookingApptsColl.size()<=1)
			return null;
		
		//collAppts=collAppts.sort(new ApptDateTimeComparator(SortOrder.ASCENDING));
		BookingAppointmentForLinkedAppointmentsVoCollection collAppsToLink = new BookingAppointmentForLinkedAppointmentsVoCollection(); 
		
		for (int i=0;i<collAppts.size();i++)
		{
			if (isApptInApptSelectedColl(collAppts.get(i),linkMultipleBookingApptsColl))
			{
				collAppsToLink.add(collAppts.get(i));
			}
		}
		
		return collAppsToLink;
		
	}

	//WDEV-20053
	private boolean isApptInApptSelectedColl(BookingAppointmentForLinkedAppointmentsVo bookingAppt, Booking_AppointmentVoCollection linkMultipleBookingApptsColl)
	{
		if (bookingAppt==null  || linkMultipleBookingApptsColl==null )
		{
			return false;
		}
		
		for (int i=0;i<linkMultipleBookingApptsColl.size();i++)
		{
			if ( bookingAppt.getSessionSlot()!=null && linkMultipleBookingApptsColl.get(i)!=null && linkMultipleBookingApptsColl.get(i).getSessionSlot()!=null &&  bookingAppt.getSessionSlot().getID_Session_Slot().equals(linkMultipleBookingApptsColl.get(i).getSessionSlot().getID_Session_Slot()))
			{
				return true;
			}
			else if ( bookingAppt.getParentChildSlot() != null && linkMultipleBookingApptsColl.get(i) != null && linkMultipleBookingApptsColl.get(i).getParentChildSlot() != null &&  bookingAppt.getParentChildSlot().getID_SessionParentChildSlot().equals(linkMultipleBookingApptsColl.get(i).getParentChildSlot().getID_SessionParentChildSlot()))
			{
				return true;
			}
		}
		
		return false;
	}

	private void createCaseNoteRequests(Sch_BookingVo voBooking) throws DomainInterfaceException
	{
		if (voBooking.getAppointmentsIsNotNull())
		{
			PatientCaseNoteRequestVoCollection addedCaseNoteRequests = new PatientCaseNoteRequestVoCollection();

			for (int i = 0; i < voBooking.getAppointments().size(); i++)
			{
				
				boolean sessionHasCaseNoteLocation = voBooking.getAppointments().get(i).getSession() != null && voBooking.getAppointments().get(i).getSession().getCaseNoteFolderLocation() != null;

				if (sessionHasCaseNoteLocation && voBooking.getAppointments().get(i).getAppointmentDate() != null && voBooking.getAppointments().get(i).getApptStartTime() != null)
				{
					if (voBooking.getAppointments().get(i).getAppointmentDate().isGreaterThan(new Date()) || (voBooking.getAppointments().get(i).getAppointmentDate().equals(new Date()) && voBooking.getAppointments().get(i).getApptStartTime().isGreaterOrEqualThan(new Time())))
					{

						//WDEV-20969 removed this check
						//if (!alreadyAddedCaseNotesRequest(addedCaseNoteRequests, voBooking.getAppointments().get(i)))
						//{

							PatientCaseNoteRequestVoCollection caseNoteRequests = saveAutomatedCaseNoteRequests(voBooking, i);

							if (caseNoteRequests != null && caseNoteRequests.size() > 0)
							{

								for (int k = 0; k < caseNoteRequests.size(); k++)
								{
									addedCaseNoteRequests.add(caseNoteRequests.get(k));
								}
							}
						//}
					}
				}
			}
		}
	}
	
	private boolean alreadyAddedCaseNotesRequest(PatientCaseNoteRequestVoCollection addedCaseNoteRequests, Booking_AppointmentVo appointment)
	{
		if (addedCaseNoteRequests == null || addedCaseNoteRequests.size() == 0)
			return false;
		
		DateTime caseNoteRequestDate = new DateTime();
		caseNoteRequestDate.setDateTime(appointment.getAppointmentDate(), appointment.getApptStartTime());
		
		for (int i=0; i < addedCaseNoteRequests.size(); i++)
		{
			
			LocationLiteVo caseNoteRequestLocation = appointment.getSession() != null ? appointment.getSession().getCaseNoteFolderLocation() : null;
			
			CaseNoteTrackingConfigVo caseNoteConfig = getCaseNoteTrackingConfig();
			
			DateTime maxDate = caseNoteRequestDate.copy();
			maxDate.addHours(caseNoteConfig != null && caseNoteConfig.getCaseNoteRequestOffset() != null ? caseNoteConfig.getCaseNoteRequestOffset() : 0);
			DateTime minDate = caseNoteRequestDate.copy();
			minDate.addHours(caseNoteConfig != null && caseNoteConfig.getCaseNoteRequestOffset() != null ? caseNoteConfig.getCaseNoteRequestOffset() * -1 : 0);
			
			boolean isBetweenDates = addedCaseNoteRequests.get(i).getRequiredByDate().isLessOrEqualThan(maxDate) && addedCaseNoteRequests.get(i).getRequiredByDate().isGreaterOrEqualThan(minDate);
			
			if (addedCaseNoteRequests.get(i).getRequestedForLocation().equals(caseNoteRequestLocation) && isBetweenDates)
			{
				return true;
			}
		}
		
		return false;
	}
	
	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequests(Sch_BookingVo voBooking, int i) throws DomainInterfaceException
	{
		PatientCaseNoteRequestVoCollection savedCaseNotesRequests = null;
		
		DateTime dateTimeRequired = new DateTime();
		
		dateTimeRequired.setDateTime(voBooking.getAppointments().get(i).getAppointmentDate(), voBooking.getAppointments().get(i).getApptStartTime());
		PatientLiteVo patient = new PatientLiteVo(voBooking.getPatient().getID_Patient(), voBooking.getPatient().getVersion_Patient());
		
		try
		{
			savedCaseNotesRequests = saveAutomatedCaseNoteRequest(patient, (MemberOfStaffLiteVo) getMosUser(), voBooking.getAppointments().get(i), dateTimeRequired);
		}
		catch (StaleObjectException e)
		{
			e.printStackTrace();
		}
		catch (UniqueKeyViolationException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return savedCaseNotesRequests;
	}
	
	private Booking_Appointment getFirstAppointmentBooking(Sch_Booking doBooking)
	{
		if (doBooking != null && doBooking.getAppointments() != null)
		{
			if (doBooking.getAppointments().size() == 1)
			{
				Booking_Appointment firstAppt = (Booking_Appointment) doBooking.getAppointments().iterator().next();
				if (firstAppt.getActivity() != null && Boolean.TRUE.equals(firstAppt.getActivity().isFirstAppointment()))
				{
					return firstAppt;
				}
			}
			
			//WDEV-19772 
			else if (doBooking.getAppointments().size() > 1)
			{
				Iterator apptIterator = doBooking.getAppointments().iterator();
				while (apptIterator.hasNext())
				{
					Booking_Appointment firstAppt = (Booking_Appointment) apptIterator.next();
					if (firstAppt.getActivity() != null && Boolean.TRUE.equals(firstAppt.getActivity().isFirstAppointment()))
					{
						return firstAppt;
					}
				}

			}
		}
		return null;
	}
	
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private void createNewPathwayClockAndEvent(CatsReferral doCatsReferral, Booking_Appointment doAppt, java.util.Date eventDateTime) throws DomainInterfaceException, StaleObjectException //WDEV-18421 
	{
		if (doCatsReferral == null || doCatsReferral.getJourney() == null)
			return;	
		
		PatientPathwayJourney journeyDO = doCatsReferral.getJourney();
		PathwayClock currentClockDO = doCatsReferral.getJourney().getCurrentClock();
		boolean isRTTApplicable = ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && Boolean.TRUE.equals(doCatsReferral.isRTTClockImpact());
		PatientEventVo savedPatEv = null;

		DomainFactory factory = getDomainFactory();
		EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.APPOINTMENTBOOKED.getID());
		PathwayRTTStatus rttStatus = null;
		Boolean onlyEventCreated = false;
		
		PathwaysRTTClockImpact clockImpact = new PathwaysRTTClockImpact();
		PathwayClock initialClock = doCatsReferral.getJourney().getCurrentClock();
		PathwayRTTStatus initialRTTStatus = doCatsReferral.getCurrentRTTStatus();
		//WDEV-21154
		Integer currentNationalCode = null;
		if(doCatsReferral.getCurrentRTTStatus()!=null)
		{
			currentNationalCode = initialRTTStatus.getRTTStatus().getNationalCode(); 
		}
		boolean wasClockStarted = false;
		boolean wasClockStopped = false;
		LookupInstance initialClockState = getClockState(initialClock);
		
		//WDEV-19941
		if (isRTTApplicable)
		{	
			wasClockStarted = initialClock != null && initialClock.getStartDate() != null;
			wasClockStopped = initialClock != null && initialClock.getStopDate() != null;

			rttStatus = createPathwayRTTStatus(doCatsReferral, true, eventDateTime);
			
			if (rttStatus == null)
				rttStatus = doCatsReferral.getCurrentRTTStatus();

			if(rttStatus != null)
			{				
				doCatsReferral.setCurrentRTTStatus(rttStatus);
				savedPatEv = createEvent(null, doCatsReferral, hardCodedEvent);		

				if (isRTTApplicable & (currentClockDO != null && currentClockDO.getStopDate() != null) && savedPatEv != null && !Boolean.TRUE.equals(hardCodedEvent.getStartsClock()))
				{
					onlyEventCreated = true;
				}
			}
		}
		
		//WDEV-19772 
		if(ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && hardCodedEvent != null && doAppt.getActivity().isFirstAppointment() && savedPatEv == null )
		{
				PatientJourneyVo patJ = PatientJourneyVoAssembler.create(doCatsReferral.getJourney());				
				if (patJ == null)
					return; 				
				savedPatEv = createEvent (doAppt, doCatsReferral, hardCodedEvent);
				
				if (isRTTApplicable & (currentClockDO != null && currentClockDO.getStopDate() != null) && savedPatEv != null && !Boolean.TRUE.equals(hardCodedEvent.getStartsClock()))
				{
					onlyEventCreated = true;
				}
		}

		if (savedPatEv != null)
		{
			doAppt.getPathwayEvents().add(PatientEventVoAssembler.extractPatientEvent(factory, savedPatEv));		
			factory.save(doAppt);
			
			//WDEV-19941
			if (rttStatus != null)
			{
				PatientPathwayJourney refreshedJouney = (PatientPathwayJourney) factory.getDomainObject(PatientPathwayJourney.class, journeyDO.getId());
				
				//WDEV-20859
				if (refreshedJouney != null && refreshedJouney.getCurrentClock() != null)
				{
					refreshedJouney.getCurrentClock().setCurrentRTTStatus(rttStatus);
					refreshedJouney.getCurrentClock().getRTTStatusHistory().add(rttStatus);
				
					factory.save(refreshedJouney);
				}
			}
		}
		// new appointment should only start a new clock if the patient is non-paediatric with a current RTT status of 33 - WDEV-22808
		if ((savedPatEv == null || onlyEventCreated) && isRTTApplicable && (currentClockDO == null || (currentClockDO != null && currentClockDO.getStopDate() != null)))
		{		
			if (Integer.valueOf(DID_NOT_ATTEND).equals(currentNationalCode) && !Boolean.TRUE.equals(doCatsReferral.getPatient().isPaediatricOn(doCatsReferral.getReferralDetails().getDateOfReferral()))) ////WDEV-21154 33 Did not attend 
				createNewClock(journeyDO, doAppt, currentClockDO, true);	
			//else
				//createNewClock(journeyDO, doAppt, currentClockDO,false);		
		}
		
		if (isRTTApplicable)
		{
			LookupInstance finalClockState = getClockState(doCatsReferral.getJourney().getCurrentClock());
			
			clockImpact = createRTTClockImpactRecord(initialClock, doCatsReferral.getJourney().getCurrentClock(), initialRTTStatus, doCatsReferral.getCurrentRTTStatus(), null, doCatsReferral.getJourney(), RTTClockImpactSource.APPOINTMENT_BOOKED, wasClockStarted, wasClockStopped, initialClockState, finalClockState);
			
			// After all the process is complete, if the ClockImpact is not null
			// Recorded against CatsReferral and Clock records
			if (clockImpact != null)
			{
				if (doCatsReferral.getRTTClockImpacts() == null)
					doCatsReferral.setRTTClockImpacts(new ArrayList<PathwaysRTTClockImpact>());
				
				doAppt.setBookedRTTClockImpact(clockImpact);
				doCatsReferral.getRTTClockImpacts().add(clockImpact);
			}
			
			doAppt.setPathwayClock(doCatsReferral.getJourney().getCurrentClock());
			factory.save(doAppt);
			factory.save(doCatsReferral);
		}
	} 
	
	private LookupInstance getClockState(PathwayClock clock)
	{
		if (clock == null)
			return getDomLookup(RTTClockState.NOT_PRESENT);
		
		if (clock.getStopDate() != null)
			return getDomLookup(RTTClockState.STOPPED);
		
		return getDomLookup(RTTClockState.STARTED);
	}

	private void createNewClock(PatientPathwayJourney journeyDO, Booking_Appointment doAppt, PathwayClock currentClockDO,boolean createNow) throws StaleObjectException
	{
		int X = getNumberOfClocks(journeyDO.getClockHistory());

		PathwayClock newClockDO = new PathwayClock ();
		newClockDO.setExtClockId("MAXIMS_" + X);
		newClockDO.setExtClockName("MaximsClock_" + X);
		if(createNow) //WDEV-21154 when rebooking a DNA set the clock to now
			newClockDO.setStartDate(new java.util.Date());
		else
			newClockDO.setStartDate(doAppt.getAppointmentDate());
		
		newClockDO.setCurrentRTTStatus(currentClockDO != null ? currentClockDO.getCurrentRTTStatus() : null);
		newClockDO.getRTTStatusHistory().add(currentClockDO != null ? currentClockDO.getCurrentRTTStatus() : null);
		
		journeyDO.setCurrentClock(newClockDO);
		
		if (journeyDO.getClockHistory() == null)
			journeyDO.setClockHistory(new HashSet<PathwayClock>());

		journeyDO.getClockHistory().add(newClockDO);

		getDomainFactory().save(journeyDO);
	}

	private PatientEventVo createEvent(Booking_Appointment doAppt, CatsReferral doCatsReferral, EventLiteVo event) throws DomainInterfaceException, StaleObjectException
	{
		if(event == null)
			return null;
		
		PatientEventVo patEvent = new PatientEventVo();
		
		patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCatsReferral.getPatient()));
		patEvent.setEvent(event);
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCatsReferral.getJourney()));
		patEvent.setScheduledDate(doAppt != null ? new DateTime(new Date(doAppt.getAppointmentDate()), new Time(doAppt.getApptStartTime())) : null);
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		
		// WDEV-23784 pass referral to the method if we have it
		if (doCatsReferral != null)
			return impl.instantiatePatientEvent(patEvent, new CatsReferralRefVo(doCatsReferral.getId(), doCatsReferral.getVersion()));
		else
			return impl.instantiatePatientEvent(patEvent);
	}

	public EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[] {"eventID", "statusID"},new Object[] {event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID()});
		
		if (list == null || list.size() == 0)
			return null;
		
		return EventLiteVoAssembler.create((Event)list.get(0));
	}

	private int getNumberOfClocks(Set clockHistory)
	{
		int X = 0;

		if(clockHistory == null || clockHistory.size() == 0)
			return ++X;

		Iterator iterator = clockHistory.iterator();
		while(iterator.hasNext()) 
		{
			X++;
			iterator.next();
		}

		return ++X;
	}
	public ReferralERODVo getReferralERODByAppointment(Booking_AppointmentRefVo apptRef)
	{
		if(apptRef == null || apptRef.getID_Booking_Appointment() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		String query = "select erod from ReferralEROD as erod left join erod.appointment as appt where appt.id = :BookAppointment";
		List<?> list = factory.find(query, new String[] {"BookAppointment"}, new Object[] {apptRef.getID_Booking_Appointment()});
		
		if(list != null && list.size() > 0 && list.get(0) != null)
		{
			return ReferralERODVoAssembler.create((ReferralEROD) list.get(0));
		}
		
		return null;
	}

	public Boolean checkIfThereIsFirstApptPerClock(CatsReferralRefVo catsReferral, Boolean areFirstAppointmentsLocally, SessionSlotListVo sessionSlot)
	{
		if(sessionSlot == null || sessionSlot.getID_Session_Slot() == null)
			return false;
		
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return false;
		
		DomainFactory factory = getDomainFactory();
		Session_Slot doSessionSlot = (Session_Slot) factory.getDomainObject(Session_Slot.class, sessionSlot.getID_Session_Slot());
		
		if(doSessionSlot != null && doSessionSlot.getActivity() != null)
		{
			if(doSessionSlot.getActivity().isFirstAppointment() == null || Boolean.FALSE.equals(doSessionSlot.getActivity().isFirstAppointment()))
				return false;
			else if(Boolean.TRUE.equals(doSessionSlot.getActivity().isFirstAppointment()))
			{
				if(Boolean.TRUE.equals(areFirstAppointmentsLocally))
					return true;
				else
				{
					String query = "select appt from CatsReferral as cats left join cats.appointments as appt left join appt.pathwayClock as apptClock left join cats.journey as catsJourney left join catsJourney.currentClock as catsCurrentClock left join appt.apptStatus as apptStatus left join appt.sessionSlot as apptSessionSlot left join apptSessionSlot.activity as apptActivity where cats.id = :CatsReferralId and (apptStatus.id not in (" + Status_Reason.CANCELLED.getID() + "," + Status_Reason.DNA.getID() + ") and not (apptStatus.id = " + Status_Reason.ARRIVAL.getID() + " and appt.outcome is not null)) and catsCurrentClock.id = apptClock.id and apptActivity.firstAppointment = 1";
					List<?> apptList = factory.find(query, new String[] {"CatsReferralId"}, new Object[] {catsReferral.getID_CatsReferral()}); 
					
					return apptList != null && apptList.size() > 0;
				}
			}	
		}
		
		return false;
	}

	//WDEV-18411 
	public HcpLiteVoCollection listClinicsListOwners(HcpFilter filter)
	{
		SessionDetailsEdit impl = (SessionDetailsEdit) getDomainImpl(ims.scheduling.domain.impl.SessionAdminImpl.class);

		return impl.listHcpLite(filter);
	}

	public PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequest(PatientLiteVo patient, MemberOfStaffLiteVo mos, Booking_AppointmentVo appointment, DateTime requiredByDate) throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.saveAutomaticCaseNoteRequests(patient, mos, appointment.getSession().getCaseNoteFolderLocation(), requiredByDate, appointment, null);
	}

	public CaseNoteTrackingConfigVo getCaseNoteTrackingConfig()
	{
		DomainFactory factory = getDomainFactory();
		String query = "select config from CaseNoteTrackingConfig as config ";
		
		List<?> list = factory.find(query);
		
		if(list != null && list.size() > 0 && list.get(0) != null)
		{
			return CaseNoteTrackingConfigVoAssembler.create((CaseNoteTrackingConfig) list.get(0));
		}
		
		return null;
		
	}

	//WDEV-19543
	public class ApptDateTimeComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public ApptDateTimeComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public ApptDateTimeComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		
		public int compare(Object ob1, Object ob2)
		{
			DateTime rez1 = null;
			DateTime rez2 = null;

			if (ob1 instanceof BookingAppointmentForLinkedAppointmentsVo)
			{
				BookingAppointmentForLinkedAppointmentsVo ps1 = (BookingAppointmentForLinkedAppointmentsVo) ob1;

				DateTime apptDateTime = new DateTime();

				if (ps1.getApptStartTimeIsNotNull())
					apptDateTime.setDateTime(ps1.getAppointmentDate(), ps1.getApptStartTime());
				
				rez1 = ps1.getAppointmentDate() != null ? apptDateTime : null;
			}

			if (ob2 instanceof BookingAppointmentForLinkedAppointmentsVo)
			{
				BookingAppointmentForLinkedAppointmentsVo ps2 = (BookingAppointmentForLinkedAppointmentsVo) ob2;

				DateTime apptDateTime = new DateTime();

				if (ps2.getApptStartTimeIsNotNull())
					apptDateTime.setDateTime(ps2.getAppointmentDate(), ps2.getApptStartTime());
				
				rez2 = ps2.getAppointmentDate() != null ? apptDateTime : null;
			}

			if (rez1 != null && rez2 != null)
				return rez1.compareTo(rez2) * direction;

			if (rez1 != null && rez2 == null)
				return direction;

			if (rez2 != null && rez1 == null)
				return (-1) * direction;

			return 0;
		}
	}

	//WDEV-19543
	public Boolean isAnyApptToBeLinked(CareContextRefVo careContextRef)
	{
		if(careContextRef == null || careContextRef.getID_CareContext() == null)
			return false;
		
		
		String query = "select count(appt.id) from Booking_Appointment as appt where ( appt.careContext.id = :careContextID and appt.apptStatus.id = :statusID and ((appt.appointmentDate > :apptDate) or (appt.appointmentDate = :apptDate and appt.apptStartTime > :apptTime)) and appt.theatreBooking = null)";
		DomainFactory factory = getDomainFactory();
		
		long count = factory.countWithHQL(query, new String[] {"careContextID","statusID","apptDate","apptTime"}, new Object[] {careContextRef.getID_CareContext(), Status_Reason.BOOKED.getID(), new java.util.Date(), new Time().toString()});
		
		if (count>0)
			return true;
		
		return false;
	}
	

	public PathwaysRTTClockImpact createRTTClockImpactRecord(PathwayClock initialClock,
			PathwayClock pathwayClock, 
			PathwayRTTStatus initialRTTStatus, 
			PathwayRTTStatus pathwayRTTStatus, 
			RTTStatusEventMapRefVo eventMapRefVo,
			PatientPathwayJourney patientPathwayJourney,
			RTTClockImpactSource source, boolean wasClockStarted, boolean wasClockStopped,
			LookupInstance initialClockState, LookupInstance finalClockState)
	{
		PathwaysRTTClockImpact clockImpact = new PathwaysRTTClockImpact();
		clockImpact.setInitialClock(initialClock);
		clockImpact.setFinalClock(pathwayClock);
		clockImpact.setInitialRTTStatus(initialRTTStatus);
		clockImpact.setFinalRTTStatus(pathwayRTTStatus);
		
		clockImpact.setInitialClockState(initialClockState);
		clockImpact.setFinalClockState(finalClockState);

		if (eventMapRefVo != null && eventMapRefVo.getID_RTTStatusEventMap() != null)
		{
			clockImpact.setOutcomeEvent((RTTStatusEventMap) getDomainFactory().getDomainObject(RTTStatusEventMap.class, eventMapRefVo.getID_RTTStatusEventMap()));
		}
		else
		{
			clockImpact.setOutcomeEvent(null);
		}

		clockImpact.setJourney(patientPathwayJourney);
		clockImpact.setSource(getDomLookup(source));

		clockImpact.setClockStarted(Boolean.FALSE);
		clockImpact.setClockStopped(Boolean.FALSE);


		// Case 1 - If there was no clock initially and one clock was created
		if (initialClock == null && pathwayClock != null)
		{
			// New clock has a start date - mark the ClockImpact
			if (pathwayClock.getStartDate() != null)
				clockImpact.setClockStarted(Boolean.TRUE);

			if (pathwayClock.getStopDate() != null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}


		// Case 2 - If there was a clock initially and there is no clock now
		if (initialClock != null && pathwayClock == null)
		{
			if (wasClockStopped == false)
				clockImpact.setClockStopped(Boolean.TRUE);
		}


		// Case 3 - If there was an initial clock and a clock is present now
		if (initialClock != null && pathwayClock != null)
		{
			// Case 3.1 - Initial and current clock are the same one
			if (initialClock.getId() == pathwayClock.getId())
			{
				if (!wasClockStopped && pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (wasClockStopped && pathwayClock.getStopDate() == null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (!wasClockStarted && pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
			}

			// Case 3.2 - Initial and current clock are not the same one
			if (initialClock.getId() != pathwayClock.getId())
			{
				if (!wasClockStopped)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
			}
		}

		return clockImpact;
	}
	
	public ServiceFunctionLiteVoCollection listServiceFunctionsLite(ServiceRefVo service)
	{
		if (service == null || service.getID_Service() == null)
			throw new CodingRuntimeException("service is null or id not provided for method listServiceFunctionsLite");
		
		List<?> list = getDomainFactory().find("select servFunct from ServiceFunction as servFunct left join servFunct.service as serv where servFunct.isActive = 1 and serv.id = :serviceID", 
				new String[] {"serviceID"}, new Object[] {service.getID_Service()});
		
		if (list != null && list.size() > 0)
			return ServiceFunctionLiteVoAssembler.createServiceFunctionLiteVoCollectionFromServiceFunction(list);
		
		return null;
	}

	public Boolean isActivityFlexible(ServiceRefVo serviceRef, ActivityRefVo activityRef)
	{
		if (activityRef == null || serviceRef == null || activityRef.getID_Activity() == null || serviceRef.getID_Service() == null)
			return false;
		
		List<?> list = getDomainFactory().find("select ServActivity from ServiceActivity as ServActivity left join ServActivity.activity as act left join ServActivity.service as serv where ServActivity.isActive = 1 and ServActivity.isFlexible = 1 and act.id = :activityID and serv.id = :serviceID", 
				new String[] {"serviceID","activityID"}, new Object[] {serviceRef.getID_Service(), activityRef.getID_Activity()});
		
		if (list != null && list.size() > 0)
			return true;
		
		return false;
	}

	//WDEV-20333
	public SessionShortVoCollection listFlexibleSessions(Date startDate, Date endDate, ActivityVo activity, ServiceRefVo service, LocationRefVo location, HcpLiteVo listOwner, ServiceFunctionRefVo clinicType, LocationRefVoCollection locationList, ProfileListType listType, LookupInstVo urgency, Boolean isWardAttendance)
	{
		// all params must be set
		if (startDate == null || endDate == null || activity == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listGenericSession");

		String hql = " select distinct session from Sch_Session as session left join session.sessionActivities as activities left join activities.activity as activity ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		StringBuffer condStr = new StringBuffer();
		
		condStr.append(" where (session.isFixed is null or session.isFixed = 0) and activity.id = :activityId and session.sessionDate >= :startDate and session.sessionDate <= :endDate and session.sessionStatus = :sessionStatus and session.sessionProfileType.id = :SESSION_TYPE and (session.isRIE is null or session.isRIE = 0)");

		// mandatory fields
		markers.add("activityId");
		values.add(activity.getID_Activity());
		
		markers.add("sessionStatus");
		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		
		markers.add("startDate");
		values.add(startDate.getDate());
		
		markers.add("endDate");
		values.add(endDate.getDate());
		
		if (Boolean.TRUE.equals(isWardAttendance))
		{
			markers.add("SESSION_TYPE");
			values.add(SchProfileType.WARD_ATTENDANCE.getID());
		}
		else
		{
			markers.add("SESSION_TYPE");
			values.add(SchProfileType.OUTPATIENT.getID());
		}

		if (service != null)
		{
			condStr.append(" and session.service.id = :idService");
			markers.add("idService");
			values.add(service.getID_Service());
		}
		
		if (listOwner != null)
		{
			hql += " left join session.listOwners as lowners left join lowners.hcp shcp left join session.parentChildSlots as slot left join slot.slotResp as slResp left join slResp.hcp as slHCP";
			
			condStr.append(" and shcp.id = :idListOwner and (slHCP.id = :idListOwner or slResp is null)");
			markers.add("idListOwner");
			values.add(listOwner.getID_Hcp());
			
		}
		
		if( listType != null)
		{
			condStr.append(" and session.listType.id = :idlistType ");
			markers.add("idlistType");
			values.add(getDomLookup(listType).getId());
			
		}
		
		if (location != null)
		{
			condStr.append(" and session.schLocation.id = :idLocation ");
			markers.add("idLocation");
			values.add(location.getID_Location());
			
		}
		else if(locationList != null)
		{
			List<String> locationIds = new ArrayList<String>();
			
			for(LocationRefVo voRef : locationList)
				locationIds.add(voRef.getID_Location().toString());

			condStr.append(" and session.schLocation.id in (" + getIdString(locationIds) + ")" );
		}
		
		if (urgency != null)
		{
			if (listOwner == null)
				hql += " left join session.parentChildSlots as slot ";
				
			hql += " left join slot.priority as priority ";
			
			condStr.append(" and priority.id = :idUrgency ");
			markers.add("idUrgency");
			values.add(urgency.getID());
			
		}

		hql += condStr.toString();
		
		DomainFactory factory = getDomainFactory();
		
		List<?> sessions = factory.find(hql, markers, values, 1000);

		if (sessions == null || sessions.size() == 0)
			return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(sessions);


		SessionShortVoCollection voCollSessionShort = new SessionShortVoCollection();

		for (int i = 0; i < sessions.size(); i++)
		{
			if (sessions.get(i) instanceof Sch_Session)
			{
				Sch_Session session = (Sch_Session) sessions.get(i);

				SessionShortVo sessionShort = SessionShortVoAssembler.create(session);

				if (session.getSessionSlots() != null)
				{
					sessionShort.setCalendarSlots(new SessionSlotWithStatusOnlyVoCollection());

					Iterator<?> slotIterator = session.getSessionSlots().iterator();

					while (slotIterator.hasNext())
					{
						Session_Slot slot = (Session_Slot) slotIterator.next();

						SessionSlotWithStatusOnlyVo sessionSlot = SessionSlotWithStatusOnlyVoAssembler.create(slot);

						if (sessionSlot.getActivity().equals(activity))
						{
							sessionShort.getCalendarSlots().add(sessionSlot);
						}
					}
				}

				voCollSessionShort.add(sessionShort);
			}
		}

		return voCollSessionShort.sort();
	}

	public SessionParentChildSlotListVoCollection listOutpatientFlexibleSlots(Sch_SessionRefVoCollection session, LookupInstVo urgency, HcpRefVo respHCP)
	{
		if (session == null || session.size() == 0)
			return null;
		
		StringBuilder query = new StringBuilder();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		StringBuffer condStr = new StringBuffer();
		
		query.append("SELECT slot FROM SessionParentChildSlot AS slot LEFT JOIN slot.session AS session LEFT JOIN session.schLocation as location ");
		condStr.append(" WHERE session.id in (");
		
		for (int i = 0; i < session.size(); i++)
		{
			condStr.append(session.get(i).getID_Sch_Session());
			
			if (i != session.size() - 1)
				condStr.append(", ");
		}
		
		condStr.append(")");
		
		if (urgency != null)
		{
			query.append( " LEFT JOIN slot.priority as priority ");
			condStr.append(" AND priority.id = :idUrgency ");
			
			paramNames.add("idUrgency");
			paramValues.add(urgency.getID());
			
		}

		if (respHCP != null)
		{
			query.append( " LEFT JOIN slot.slotResp as slResp LEFT JOIN slResp.hcp as slHCP ");
			condStr.append(" AND (slHCP.id = :idListOwner or slResp is null) ");
			
			paramNames.add("idListOwner");
			paramValues.add(respHCP.getID_Hcp());
		}
		
		condStr.append(" ORDER BY location.name ASC, session.name ASC, slot.startTime ASC ");
		
		query.append(condStr.toString());
		
		return SessionParentChildSlotListVoAssembler.createSessionParentChildSlotListVoCollectionFromSessionParentChildSlot(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public SessionParentChildSlotForBookingVo getSessionFlexibleSlot(SessionParentChildSlotRefVo flexibleSlot)
	{
		if (flexibleSlot == null || flexibleSlot.getID_SessionParentChildSlot() == null)
			return null;
		
		return SessionParentChildSlotForBookingVoAssembler.create((SessionParentChildSlot) getDomainFactory().getDomainObject(SessionParentChildSlot.class, flexibleSlot.getID_SessionParentChildSlot()));
	}

	public LocationLiteVoCollection getHospitals()
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from Location loc where loc.isActive = :active and loc.isVirtual = :virtual and loc.type.id = :locationTypeID order by loc.upperName asc ";
		
		List<?> locs = factory.find(hql, new String[]{"active", "virtual", "locationTypeID"}, new Object[]{Boolean.TRUE, Boolean.FALSE, LocationType.HOSP.getID()});
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locs);
	}

	public LocationLiteVoCollection getLocations(LocationRefVo hospital, Boolean isWardAttendance)
	{
		DomainFactory factory = getDomainFactory();
		
		if (hospital == null)
		{
			ArrayList markers = new ArrayList();
			ArrayList values = new ArrayList();

			String hql = "from Location loc where loc.isActive = :active and loc.isVirtual = :virtual ";

			markers.add("active");
			values.add(Boolean.TRUE);

			markers.add("virtual");
			values.add(Boolean.FALSE);

			if (Boolean.TRUE.equals(isWardAttendance))
			{
				hql += " and loc.type.id = :locationTypeID ";
				markers.add("locationTypeID");
				values.add(LocationType.WARD.getID());
			}
			else
			{
				hql += " and (loc.type.id = :locationTypeID1  or loc.type.id = :locationTypeID2) ";

				markers.add("locationTypeID1");
				values.add(LocationType.CLINIC.getID());

				markers.add("locationTypeID2");
				values.add(LocationType.OUTPATIENT_DEPT.getID());
			}

			hql += " order by loc.upperName asc";

			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(factory.find(hql, markers, values));
		}
		else 
		{
			//http://jira/browse/WDEV-21222
			OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
			String ids;
			if(Boolean.TRUE.equals(isWardAttendance)) //WDEV-21692
				ids =impl.getChildLocationsIdsForLocation(hospital.getBoId(),new int[]{ LocationType.WARD.getID()}, Boolean.TRUE);
			else
				ids= impl.getChildLocationsIdsForLocation(hospital.getBoId(),new int[]{LocationType.OUTPATIENT_DEPT.getID(), LocationType.CLINIC.getID()}, Boolean.TRUE);
			List locations = factory.find("select l from Location l where l.id in("+ids+")");
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
		}
	}
	

	//start WDEV-20279
	public Integer countFirstActivityAppointmentsForServices(CatsReferralRefVo referral, ServiceRefVoCollection services)
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("Cats Referral parameter is mandatory.");
		
		String cabQuery = "select cats from CatsReferral as cats where cats.id = :CATS_ID and cats.isCAB = 1 and cats.consultationActivityRequired = 1";
		List listCABReferral = getDomainFactory().find(cabQuery, new String[] {"CATS_ID"}, new Object[] {referral.getID_CatsReferral()});
		
		if(listCABReferral != null && listCABReferral.size() > 0)
			return 0;
		
		if (services == null || services.size() == 0)
			return 0;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT COUNT(appt.id) FROM CatsReferral AS referral ");
		query.append(" LEFT JOIN referral.appointments AS appt LEFT JOIN appt.activity AS activity ");
		query.append(" LEFT JOIN appt.session AS session LEFT JOIN session.service AS service ");
		query.append(" LEFT JOIN appt.currentStatusRecord AS currentStatus LEFT JOIN currentStatus.status AS status ");
		
		query.append(" WHERE ");
		
		query.append(" referral.id = :CATS_ID AND activity.firstAppointment = 1 AND status.id <> :APPT_CANCELLED AND status.id <> :APPT_DNA");
		
		paramNames.add("CATS_ID");					paramValues.add(referral.getID_CatsReferral());
		paramNames.add("APPT_CANCELLED");			paramValues.add(Status_Reason.CANCELLED.getID());
		paramNames.add("APPT_DNA");					paramValues.add(Status_Reason.DNA.getID());
		
		if (services != null && services.size() > 0)
		{
			query.append(" AND service.id IN ");
			query.append("(");
			
			for (int i = 0; i < services.size(); i++)
			{
				query.append(services.get(i).getID_Service());
				if (i !=  services.size() - 1) query.append(", ");
			}
			
			query.append(")");
		}
		
		return (int) getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
	}

	//WDEV-20643
	public void updateCatsReferralConsultationActivityRequired(CatsReferralRefVo catsReferral, Boolean consultationActivityRequired) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralConsultationActivityRequired(catsReferral, false);
	}

	public HcpLiteVo getHCPLite(HcpRefVo hcp)
	{
		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().getDomainObject(Hcp.class, hcp.getID_Hcp()));
	}

	public Boolean isCancerPathwayReferral(CatsReferralRefVo catsReferral)  //WDEV-21154 
	{
		if(catsReferral==null||catsReferral.getBoId()==null)
			return Boolean.FALSE;
		String hql = "select  cr.urgency.id from CatsReferral as cr where cr.id =:catsRef";
		List<?> list = getDomainFactory().find(hql,new String[]{"catsRef"},new Object[]{catsReferral.getBoId()});
		if(list!=null&&list.size()>0)
		{
			Integer obj=(Integer)list.get(0);
			if(obj!=null&&
				(obj.equals(Integer.valueOf(ReferralUrgency.TWO_WEEK_WAIT.getID()))
					||obj.equals(Integer.valueOf(ReferralUrgency.CONSULTANT_UPGRADE.getID()))
					||obj.equals(Integer.valueOf(ReferralUrgency.NATIONAL_SCREENING.getID())) ))
				return Boolean.TRUE;
		}
		return Boolean.FALSE;
	}

	@Override
	public Patient updateLocalPatientWithPds(Patient lpiPatient,
			Patient pdsPatient, ArrayList errors, String samlXml,
			IAppRole appRole, MissingMappingVoCollection missingMappingVoCollection) throws DomainInterfaceException,
			StaleObjectException, ForeignKeyViolationException {
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.updateLocalPatientWithPds(lpiPatient, pdsPatient, errors, samlXml, appRole, missingMappingVoCollection);
	}

	@Override
	public Patient getPatient(PatientShort patient) throws StaleObjectException {
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.getPatient(patient);
	}

	//WDEV-22314 
	// Referrals - Booking Appointments - The List Owner list should be based on the service selected (P2-618)
	@Override
	public HcpLiteVoCollection listHcpLiteByServiceFunction(ims.core.vo.HcpFilter filter, ims.core.clinical.vo.ServiceRefVo serviceRef, ims.core.vo.lookups.ServiceFunctionCollection functions)
	{
		Profiles impl = (Profiles) getDomainImpl(ProfilesImpl.class);
		return impl.listHcpLiteBySerbiceFunction(filter, serviceRef, functions);
	}

	@Override
	public PDSConfigurationVo getPDSConfiguration() {
		PatientSearchConfiguration impl = (PatientSearchConfiguration) getDomainImpl(PatientSearchConfigurationImpl.class);
		return impl.getPatientSearchConfig();
	}

	@Override
	public Session_ListOwnerVoCollection getListOwnerBySlots(Sch_SessionRefVo slotRef) 
	{
		
		if (slotRef == null || slotRef.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not supplied for method getListOwnerBySlots;");

		DomainFactory factory = getDomainFactory();
		List listOwners = factory.find("select s2_1 from Sch_Session as s1_1 left join s1_1.listOwners as s2_1 where s1_1.id =  "+ slotRef.getID_Sch_Session() );
		return Session_ListOwnerVoAssembler.createSession_ListOwnerVoCollectionFromSession_ListOwner(listOwners);
	}

	@Override
	public LocationLiteVo getHospitalForCurrentLocation(LocationRefVo locRef) 
	{
		if (locRef == null || locRef.getID_Location() == null)
			throw new CodingRuntimeException("locRef is null or id not supplied for method getHospitalForCurrentLocation;");
		
		SessionManagement impl = (SessionManagement)getDomainImpl(SessionManagementImpl.class);
		return impl.getHospitalForCurrentLocation(locRef.getID_Location());

	}
	
	@Override
	//WDEV-22486 WDEV-22807
	public BookingAppointmentLiteVoCollection getCurrentAppts(PatientRefVo patient, Date appointmentDate)
	{
		if (patient == null || patient.getID_Patient() == null || appointmentDate == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		List currentAppts = factory.find("select appt from Booking_Appointment as appt left join appt.patient as pat where pat.id = :patientID and appt.appointmentDate = :apptDate and appt.apptStatus = :bookedStatus and appt.theatreBooking is null )", new String[]{"patientID", "apptDate", "bookedStatus"}, new Object[]{patient.getID_Patient(), appointmentDate.getDate(), getDomLookup(Status_Reason.BOOKED)});
		return BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(currentAppts);
	}

	public SessionParentChildSlotListVoCollection addFlexibleSlotsToSession(SessionShortVo session, SessionParentChildSlotVoCollection flexibleSlots) throws StaleObjectException
	{
		if (session == null)
			throw new CodingRuntimeException("session is null in method addFlexibleSlotsToSession()");

		if (flexibleSlots == null || flexibleSlots.size() == 0)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Sch_Session doSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, session.getID_Sch_Session());
		
		for (int i = 0; i < flexibleSlots.size(); i++)
		{
			SessionParentChildSlot doSlot = SessionParentChildSlotVoAssembler.extractSessionParentChildSlot(factory, flexibleSlots.get(i));
			doSession.getParentChildSlots().add(doSlot);
		}
		
		factory.save(doSession);
		
		return SessionParentChildSlotListVoAssembler.createSessionParentChildSlotListVoCollectionFromSessionParentChildSlot(doSession.getParentChildSlots());
	}
}
