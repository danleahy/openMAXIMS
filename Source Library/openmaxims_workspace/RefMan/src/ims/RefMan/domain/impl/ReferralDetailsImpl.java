//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.65 build 3163.31063)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.ContractConfiguration;
import ims.RefMan.domain.ReferralStatusList;
import ims.RefMan.domain.ReferralWizard;
import ims.RefMan.domain.base.impl.BaseReferralDetailsImpl;
import ims.RefMan.domain.objects.CATSReferralStatus;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.OnwardReferralFromTriage;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.PresentationReferralSummary;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.domain.objects.WorkAllocation;
import ims.RefMan.vo.AdmissionDetailUndoClockImpactVo;
import ims.RefMan.vo.CATSReferralStatusRefVo;
import ims.RefMan.vo.CATSReferralStatusRefVoCollection;
import ims.RefMan.vo.CATSReferral_ClockImpactVo;
import ims.RefMan.vo.CatsReferralDetailsVo;
import ims.RefMan.vo.CatsReferralForRequestServiceVo;
import ims.RefMan.vo.CatsReferralMasterVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.CatsReferralStatusVo;
import ims.RefMan.vo.CatsReferralWizardVo;
import ims.RefMan.vo.ContractServiceLocationsConfigVo;
import ims.RefMan.vo.OnwardReferralFromTriageVo;
import ims.RefMan.vo.ReferralAppointmentDetailsVo;
import ims.RefMan.vo.WorkAllocationVo;
import ims.RefMan.vo.WorkAllocationVoCollection;
import ims.RefMan.vo.domain.AdmissionDetailUndoClockImpactVoAssembler;
import ims.RefMan.vo.domain.CATSReferral_ClockImpactVoAssembler;
import ims.RefMan.vo.domain.CatsReferralFlaggedForReviewVoAssembler;
import ims.RefMan.vo.domain.CatsReferralForRequestServiceVoAssembler;
import ims.RefMan.vo.domain.CatsReferralMasterVoAssembler;
import ims.RefMan.vo.domain.CatsReferralStatusVoAssembler;
import ims.RefMan.vo.domain.OnwardReferralFromTriageVoAssembler;
import ims.RefMan.vo.domain.PresentationReferralSummaryVoAssembler;
import ims.RefMan.vo.domain.ReferralAppointmentDetailsVoAssembler;
import ims.RefMan.vo.domain.WorkAllocationVoAssembler;
import ims.RefMan.vo.enums.ReferralAppointmentOutcomeAction;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ElectiveListStatusReason;
import ims.RefMan.vo.lookups.LookupHelper;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.RefMan.vo.lookups.ReferralRelationType;
import ims.RefMan.vo.lookups.ReferralUrgency;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.vo.ReferralLetterDetailsVo;
import ims.clinical.vo.domain.ReferralLetterDetailsVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.ReferralLetterDetails;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.vo.ContractConfigRefVo;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.impl.PatientCaseNotesImpl;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.OrgLiteVoCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.OrgLiteVoAssembler;
import ims.core.vo.domain.PatientLiteVoAssembler;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.SourceOfReferral;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.framework.enumerations.SortOrder;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.configuration.domain.objects.Target;
import ims.pathways.configuration.vo.TargetRefVo;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.AdminEvent;
import ims.pathways.domain.objects.PathwaysRTTClockImpact;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.AdminEventVo;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.EventVo;
import ims.pathways.vo.PathwayClockVo;
import ims.pathways.vo.PathwayClockVoCollection;
import ims.pathways.vo.PathwayRTTClockImpactUndoVo;
import ims.pathways.vo.PathwayRTTClockImpactVo;
import ims.pathways.vo.PathwayRTTClockImpactVoCollection;
import ims.pathways.vo.PathwayRTTStatusRefVoCollection;
import ims.pathways.vo.PathwayRTTStatusVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientEventVoCollection;
import ims.pathways.vo.PatientPathwayJourneyRefVo;
import ims.pathways.vo.RTTStatusEventMapRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.RTTStatusPointLiteVo;
import ims.pathways.vo.domain.AdminEventVoAssembler;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.EventVoAssembler;
import ims.pathways.vo.domain.PathwayRTTClockImpactUndoVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.domain.RTTStatusPointLiteVoAssembler;
import ims.pathways.vo.lookups.AdminEventOutcome;
import ims.pathways.vo.lookups.EventEncounterType;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.RTTClockImpactSource;
import ims.pathways.vo.lookups.RTTClockState;
import ims.scheduling.domain.AppointmentOutcomeDialog;
import ims.scheduling.domain.ExclusionDates;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.AppointmentOutcomeDialogImpl;
import ims.scheduling.domain.impl.ExclusionDatesImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.FutureAppointmentDetails;
import ims.scheduling.domain.objects.PendingEmergencyTheatre;
import ims.scheduling.helper.IEndOfCare;
import ims.scheduling.helper.IRecordRTTClockImpact;
import ims.scheduling.vo.AppointmentUndoClockImpactVo;
import ims.scheduling.vo.BookingAppointmentOutcomeVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.ExclusionDatesVo;
import ims.scheduling.vo.ReferralAppointmentDetailsBookingAppointmentVo;
import ims.scheduling.vo.ReferralAppointmentDetailsBookingAppointmentVoCollection;
import ims.scheduling.vo.domain.AppointmentUndoClockImpactVoAssembler;
import ims.scheduling.vo.domain.BookingAppointmentOutcomeVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.lookups.ApptOutcome;
import ims.scheduling.vo.lookups.FutureAppointmentStatus;
import ims.scheduling.vo.lookups.PendingEmergencyTheatreStatus;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.domain.DomainObjectMap;
import ims.vo.interfaces.IReferralApptDetail;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

public class ReferralDetailsImpl extends BaseReferralDetailsImpl implements IRecordRTTClockImpact, IEndOfCare
{
	private static final long serialVersionUID = 1L;

	
	private static final int NATIONAL_CODE_FOR_SUBSEQUENT_ACTIVITY_IN_RTT_PERIOD	= 20;
	private static final int NATIONAL_CODE_FOR_START_FIRST_DEFINITIVE_TREATMENT		= 30;
	private static final int NATIONAL_CODE_FOR_PATIENT_DID_NOT_ATTEND				= 33;
	private static final int NATIONAL_CODE_FOR_DECISION_NOT_TO_TREAT				= 34;

	private static final int TWO_WEEK_WAIT_TO_1ST_APP = 14;
	
	
	/**
	* getReferralDetail
	*/
	public ims.RefMan.vo.CatsReferralDetailsVo getReferralDetail(ims.RefMan.vo.CatsReferralRefVo catsReferral)
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferall is null or id not provided for method getReferralDetail");
		
		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		CatsReferralDetailsVo voCatsReferralDetail = new CatsReferralDetailsVo();
	
		if(doCatsReferral.getCurrentStatus() != null && doCatsReferral.getCurrentStatus().getReferralStatus() != null)
			voCatsReferralDetail.setReferralApptStatus(LookupHelper.getReferralApptStatusInstance(getLookupService(), doCatsReferral.getCurrentStatus().getReferralStatus().getId()));
		
		DomainObjectMap objMap = new DomainObjectMap();
		
		ReferralAppointmentDetailsVo appointmentDetails = ReferralAppointmentDetailsVoAssembler.create(objMap, doCatsReferral);
		
		voCatsReferralDetail.setAppointmentDetail(appointmentDetails);
		//WDEV-19207
		if (voCatsReferralDetail.getAppointmentDetail() != null && voCatsReferralDetail.getAppointmentDetail().getAppointments() != null && voCatsReferralDetail.getAppointmentDetail().getAppointments().size() > 0)
		{
			ReferralAppointmentDetailsBookingAppointmentVoCollection apptscoll = voCatsReferralDetail.getAppointmentDetail().getAppointments();
			for (ReferralAppointmentDetailsBookingAppointmentVo appt : apptscoll)
			{
				String comment = getBookingCommentForAppt(appt);
				appt.setBookingComments(comment);
			}
			voCatsReferralDetail.getAppointmentDetail().setAppointments(apptscoll);
			
		}
		
		ReferralLetterDetailsVo referralLetterDetails = ReferralLetterDetailsVoAssembler.create(objMap, doCatsReferral.getReferralDetails());
	
		voCatsReferralDetail.setLetterDetail(referralLetterDetails);
		List<?> list = factory.find("from PresentationReferralSummary prs where prs.catsReferral.id = '" + doCatsReferral.getId() + "'");
		if (list.size() > 0)
			voCatsReferralDetail.setPresentation( PresentationReferralSummaryVoAssembler.create((PresentationReferralSummary) list.get(0)));

		return voCatsReferralDetail;
	}
	
	private ims.scheduling.vo.ExclusionDatesVo listExclusionDates()
	{
		ExclusionDates impl = (ExclusionDates) getDomainImpl(ExclusionDatesImpl.class);
		return impl.listExclusionDates();
	}
	
	private ContractServiceLocationsConfigVo getContractServiceLocConf(ContractConfigRefVo contract, ServiceRefVo service)
	{
		ContractConfiguration impl = (ContractConfiguration) getDomainImpl(ContractConfigurationImpl.class);
		return impl.getContractServiceLocConfByContractService(contract,service);
	}
	
	//WDEV-19207
	private String getBookingCommentForAppt(ReferralAppointmentDetailsBookingAppointmentVo appt)
	{
		if (appt == null)
			return null;
		Object obj = getDomainFactory().find("select sch.bookingComments from Sch_Booking as sch left join sch.appointments as appts where appts.id = :APPTID", new String[]{"APPTID"},new Object[]{appt.getID_Booking_Appointment()}).get(0);

		return 	obj != null && obj instanceof String ? (String)obj : null;
			
	}

	public IReferralApptDetail getReferralApptDetail(CatsReferralRefVo catsReferral)
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferall is null or id not provided for method getReferralApptDetail");
		//WDEV-19207 --- start
		
		CatsReferral doCatsReferral = (CatsReferral) getDomainFactory().getDomainObject(catsReferral);
		ReferralAppointmentDetailsVo referralDetailsVo = ReferralAppointmentDetailsVoAssembler.create(doCatsReferral);
		
		ExclusionDatesVo voExDate = listExclusionDates();
		
		if (referralDetailsVo != null && referralDetailsVo.getAppointments() != null && referralDetailsVo.getAppointments().size() > 0)
		{
			ReferralAppointmentDetailsBookingAppointmentVoCollection apptscoll = referralDetailsVo.getAppointments();
			for (ReferralAppointmentDetailsBookingAppointmentVo appt : apptscoll)
			{
				String comment = getBookingCommentForAppt(appt);
				appt.setBookingComments(comment);
			}
			referralDetailsVo.setAppointments(apptscoll);			
		}
		return referralDetailsVo;
		//WDEV-19207 ---ends here
	}

	public CatsReferralWizardVo getCatsReferral(CatsReferralRefVo voCatsRef) 
	{
		ReferralWizard impl = (ReferralWizard) getDomainImpl(ReferralWizardImpl.class);
		return impl.getCatsReferral(voCatsRef);
	}

	public CatsReferralWizardVo saveCatsReferral(CatsReferralWizardVo record) throws DomainInterfaceException, StaleObjectException 
	{
		ReferralWizard impl = (ReferralWizard) getDomainImpl(ReferralWizardImpl.class);
		return impl.saveCatsReferral(record);
	}
	
	public ims.RefMan.vo.CatsReferralFlaggedForReviewVo getCatsReferralFlaggedForReview(ims.RefMan.vo.CatsReferralRefVo voCatsRef)
	{
		return CatsReferralFlaggedForReviewVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, voCatsRef.getID_CatsReferral()));
	}

	public Boolean getPatientICPForCareContext(CareContextRefVo ccRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(PatientICP.class, factory);
		imsc.equal("careContext.id", ccRefVo.getID_CareContext());
		List<?> icps = imsc.find();
		if (icps!=null && icps.size()>0)
			return true;

		return false;
	}

	public WorkAllocationVo getWorkAllocation(CatsReferralRefVo voCatRefVo, MemberOfStaffRefVo voMOS) 
	{
		DomainFactory factory = getDomainFactory();

		StringBuffer condStr = new StringBuffer();
		String hql = " from WorkAllocation as wa where wa.completedDateTime = null and wa.unallocatedDate = null " +
				"and wa.catsReferral.id = :catsID and wa.allocatedTo.id = :idWho ";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		markers.add("catsID");
		values.add(voCatRefVo.getID_CatsReferral());
		markers.add("idWho");
		values.add(voMOS.getID_MemberOfStaff());

		hql += condStr.toString();

		List<?> list = factory.find(hql.toString(), markers,values);
		if(list != null && list.size() > 0)
		{ 
			WorkAllocationVoCollection voColl = WorkAllocationVoAssembler.createWorkAllocationVoCollectionFromWorkAllocation(list);
			if(voColl != null && voColl.size() > 0)
				return voColl.get(0);
		}
		
		return null;
	}

	public WorkAllocationVo saveWorkAllocation(WorkAllocationVo voWorkAllocation) throws DomainInterfaceException, StaleObjectException 
	{
		if (voWorkAllocation != null)
		{
			if (!voWorkAllocation.isValidated())
				throw new DomainRuntimeException("voWorkAllocation not validated");
		}
		DomainFactory factory = getDomainFactory();

		
		//wdev-8480
		if (voWorkAllocation.getCompletedDateTimeIsNotNull())
		{
			CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(voWorkAllocation.getCatsReferral());
			doCatsReferral.setIsCurrentlyAllocated(Boolean.FALSE);
			factory.save(doCatsReferral);
		}
		
		WorkAllocation doWork = WorkAllocationVoAssembler.extractWorkAllocation(factory, voWorkAllocation);
		factory.save(doWork);
		return WorkAllocationVoAssembler.create(doWork);
	}

	public OrgLiteVoCollection listAllSuppliers()
	{
		List<?> orgs = getDomainFactory().find("from Organisation org where org.type.id = " + OrganisationType.SUPPLIER.getID() + "and org.isActive = " + Boolean.TRUE);
		return OrgLiteVoAssembler.createOrgLiteVoCollectionFromOrganisation(orgs);
	}

	public OnwardReferralFromTriageVo getOnwardReferralByCatsReferral(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method getOnwardReferralByCatsReferral");
		
		List<?> onwardReferrals = getDomainFactory().find("from OnwardReferralFromTriage orft where orft.catsReferral.id = " + catsReferral.getID_CatsReferral());
		if(onwardReferrals != null && onwardReferrals.size() > 0)
			return OnwardReferralFromTriageVoAssembler.create((OnwardReferralFromTriage) onwardReferrals.get(0));
		
		return null;
	}

	//set the boolean for IsOnwardReferralFromTriage to TRUE 
	@SuppressWarnings("unchecked")
	public void updateCatsReferralIsOnwardReferralFromTriage(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method updateCatsReferralIsOnwardReferralFromTriage");
		
		CatsReferral doCatsReferral = (CatsReferral)getDomainFactory().getDomainObject(catsReferral);
		
		//set current status to Referral ONWARDREFERRALREQUESTED and add to history
		CATSReferralStatus doStatus = new CATSReferralStatus();
		doStatus.setAuthoringUser((MemberOfStaff)getMosUser());
		doStatus.setReferralStatus(getDomLookup(ReferralApptStatus.ONWARDREFERRALREQUESTED));
		doStatus.setStatusDateTime(new DateTime().getJavaDate());
		
		doCatsReferral.getStatusHistory().add(doStatus);
	
		doCatsReferral.setIsOnwardReferralTriage(true);
		
		try
		{
			getDomainFactory().save(doCatsReferral);
		}
		catch (StaleObjectException e)
		{
			//unreachable code as get then update performed
		}
	}

	public OnwardReferralFromTriageVo saveOnwardReferral(OnwardReferralFromTriageVo voOnward) throws StaleObjectException
	{
		if (voOnward == null)
			throw new CodingRuntimeException("voOnward is null in method saveOnwardReferral");
		if (!voOnward.isValidated())
			throw new CodingRuntimeException("voOnward has not been validated in method saveOnwardReferral");
		
		OnwardReferralFromTriage doOnward = OnwardReferralFromTriageVoAssembler.extractOnwardReferralFromTriage(getDomainFactory(), voOnward);
		getDomainFactory().save(doOnward);
		return OnwardReferralFromTriageVoAssembler.create(doOnward);
	}
	
	
	public Integer undoAppointmentClockImpact(AppointmentUndoClockImpactVo appointment, PathwayRTTClockImpactVo clockImpactRef) throws DomainInterfaceException, StaleObjectException
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (clockImpactRef == null || clockImpactRef.getID_PathwaysRTTClockImpact() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		DomainFactory factory = getDomainFactory();
		PathwayRTTClockImpactUndoVo clockImpact = PathwayRTTClockImpactUndoVoAssembler.create((PathwaysRTTClockImpact) factory.getDomainObject(PathwaysRTTClockImpact.class, clockImpactRef.getID_PathwaysRTTClockImpact()));
		
		// Get CATS Referral recorded for appointment
		CATSReferral_ClockImpactVo referral = null;
		
		String query = "SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.appointments AS appointment WHERE appointment.id = :Appointment";
		List<?> doCatsList = factory.find(query, "Appointment", appointment.getID_Booking_Appointment());
		
		if (doCatsList == null || doCatsList.size() == 0 || doCatsList.get(0) == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (doCatsList.get(0) instanceof CatsReferral)
		{
			referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) doCatsList.get(0));
		}
		
		if (referral == null || referral.getJourney() == null || (!Boolean.TRUE.equals(referral.getRTTClockImpact()) && (referral.getDOS() == null || !Boolean.TRUE.equals(referral.getDOS().getRTTClockImpact()))))
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;


		// Test that the Clock Impact can be undone
		// Conditions so that the Clock Impact can be undone
		// 1 - RTT Status must be the one recorded in final status
		// 2 - Clock must be same as in the final clock
		if (!isLastClockImpact(referral, clockImpact))
		{
			return IRecordRTTClockImpact.NOT_LAST_IMPACT;
		}
		
		// Begin the process to undo the clock referral
		referral.getJourney().setCurrentClock(clockImpact.getInitialClock());

		if (Boolean.TRUE.equals(clockImpact.getClockStopped()))
		{
			referral.getJourney().getCurrentClock().setStopDate(null);
		}
		
		referral.setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		referral.getJourney().getCurrentClock().setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		referral.getJourney().getCurrentClock().getRTTStatusHistory().remove(clockImpact.getFinalRTTStatus());
		
		if ((clockImpact == null || clockImpact.getInitialClock().getID_PathwayClock() != clockImpact.getFinalClock().getID_PathwayClock()) && referral.getJourney().getClockHistory() != null)
		{
			referral.getJourney().getClockHistory().remove(clockImpact.getFinalClock());
		}

		// If there is an Undo Event saved against the map of the clock Impact then instantiate a Patient Event
		if (clockImpact.getOutcomeEvent() != null && clockImpact.getOutcomeEvent().getUndoEvent() != null)
		{
			// Attempt to create and instantiate a Patient Event
			try
			{
				@SuppressWarnings("unused")
				PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, clockImpact.getOutcomeEvent().getUndoEvent(), new DateTime());
			}
			// If an exception occurs at this point then log it in the system 
			catch (DomainInterfaceException exception)
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
			}
		}

		appointment.setBookedRTTClockImpact(null);
		Booking_Appointment appointmentDom = AppointmentUndoClockImpactVoAssembler.extractBooking_Appointment(factory, appointment);
		factory.save(appointmentDom);

		referral.getRTTClockImpacts().remove(clockImpactRef);
		CatsReferral catsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(factory, referral);
		factory.save(catsReferral);
			
		return IRecordRTTClockImpact.UNDO_CLOCK_IMPACT_SUCCESS;
	}
	
	
	public Integer undoAdmissionClockImpact(AdmissionDetailUndoClockImpactVo admissionDetail, PathwayRTTClockImpactVo clockImpactRef) throws DomainInterfaceException, StaleObjectException
	{
		if (admissionDetail == null || admissionDetail.getID_AdmissionDetail() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (clockImpactRef == null || clockImpactRef.getID_PathwaysRTTClockImpact() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;

		DomainFactory factory = getDomainFactory();
		PathwayRTTClockImpactUndoVo clockImpact = PathwayRTTClockImpactUndoVoAssembler.create((PathwaysRTTClockImpact) factory.getDomainObject(PathwaysRTTClockImpact.class, clockImpactRef.getID_PathwaysRTTClockImpact()));

		// Get CATS Referral recorded for Admission
		// If no referral record is found or the referral found is NOT subject to RTT Clock (or has no Journey) then terminate function
		CATSReferral_ClockImpactVo referral = null;
		
		String query = "SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.rTTClockImpacts AS clockImpacts WHERE clockImpacts.id = :ClockImpact";
		List<?> doCatsList = factory.find(query, new String[] {"ClockImpact"}, new Object[] {clockImpact.getID_PathwaysRTTClockImpact()});
		
		if (doCatsList == null || doCatsList.size() == 0 || doCatsList.get(0) == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (doCatsList.get(0) instanceof CatsReferral)
		{
			referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) doCatsList.get(0));
		}
		
		if (referral == null || referral.getJourney() == null || (!Boolean.TRUE.equals(referral.getRTTClockImpact()) && (referral.getDOS() == null || !Boolean.TRUE.equals(referral.getDOS().getRTTClockImpact()))))
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		// Test that the Clock Impact can be undone
		// Conditions so that the Clock Impact can be undone
		// 1 - RTT Status must be the one recorded in final status
		// 2 - Clock must be same as in the final clock
		if (!isLastClockImpact(referral, clockImpact))
		{
			return IRecordRTTClockImpact.NOT_LAST_IMPACT;
		}
		
		// Begin the process to undo the clock referral
		referral.getJourney().setCurrentClock(clockImpact.getInitialClock());

		if (Boolean.TRUE.equals(clockImpact.getClockStopped()))
		{
			referral.getJourney().getCurrentClock().setStopDate(null);
		}
		
		referral.setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		referral.getJourney().getCurrentClock().setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		referral.getJourney().getCurrentClock().getRTTStatusHistory().remove(clockImpact.getFinalRTTStatus());
		
		if ((clockImpact.getInitialClock() == null || clockImpact.getInitialClock().getID_PathwayClock() != clockImpact.getFinalClock().getID_PathwayClock()) && referral.getJourney().getClockHistory() != null)
		{
			referral.getJourney().getClockHistory().remove(clockImpact.getFinalClock());
		}

		
		// If there is an Undo Event saved against the map of the clock Impact then instantiate a Patient Event
		if (clockImpact.getOutcomeEvent() != null && clockImpact.getOutcomeEvent().getUndoEvent() != null)
		{
			// Attempt to create and instantiate a Patient Event
			try
			{
				@SuppressWarnings("unused")
				PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, clockImpact.getOutcomeEvent().getUndoEvent(), new DateTime());
			}
			// If an exception occurs at this point then log it in the system 
			catch (DomainInterfaceException exception)
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
			}
			
			// Refresh referral record
			referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, referral.getID_CatsReferral()));
		}

		admissionDetail.setAdmissionRTTOutcome(null);
		AdmissionDetail admissionDetailDom = AdmissionDetailUndoClockImpactVoAssembler.extractAdmissionDetail(factory, admissionDetail);
		factory.save(admissionDetailDom);

		referral.getRTTClockImpacts().remove(clockImpactRef);
		CatsReferral catsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(factory, referral);
		factory.save(catsReferral);
			
		return IRecordRTTClockImpact.UNDO_CLOCK_IMPACT_SUCCESS;
	}



	public Integer undoAdminEventClockImpact(AdminEventVo adminEvent, PathwayRTTClockImpactVo clockImpactRef) throws DomainInterfaceException, StaleObjectException
	{
		if (adminEvent == null || adminEvent.getID_AdminEvent() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (clockImpactRef == null || clockImpactRef.getID_PathwaysRTTClockImpact() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		DomainFactory factory = getDomainFactory();
		PathwayRTTClockImpactUndoVo clockImpact = PathwayRTTClockImpactUndoVoAssembler.create((PathwaysRTTClockImpact) factory.getDomainObject(PathwaysRTTClockImpact.class, clockImpactRef.getID_PathwaysRTTClockImpact()));
		
		// Get CATS Referral record for AdminEvent
		// If no referral record is found or the referral found is NOT subject to RTT Clock (or has no Journey) then terminate function
		CATSReferral_ClockImpactVo referral = null;
		
		String query = "SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.adminEvent AS event LEFT JOIN event.rTTClockImpact AS clockImpact WHERE event.id = :AdminEvent";
		List<?> doCatsList = factory.find(query, new String[] {"AdminEvent"}, new Object[] {adminEvent.getID_AdminEvent()});
		
		if (doCatsList == null || doCatsList.size() == 0 || doCatsList.get(0) == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (doCatsList.get(0) instanceof CatsReferral)
		{
			referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) doCatsList.get(0));
		}
		
		if (referral == null || referral.getJourney() == null || (!Boolean.TRUE.equals(referral.getRTTClockImpact()) && (referral.getDOS() == null || !Boolean.TRUE.equals(referral.getDOS().getRTTClockImpact()))))
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		// Test that the Clock Impact can be undone
		// Conditions so that the Clock Impact can be undone
		// 1 - RTT Status must be the one recorded in final status
		// 2 - Clock must be same as in the final clock
		if (!isLastClockImpact(referral, clockImpact))
		{
			return IRecordRTTClockImpact.NOT_LAST_IMPACT;
		}
		
		
		// Begin process to UNDO the RTT clock & RTT status impact
		referral.getJourney().setCurrentClock(clockImpact.getInitialClock());

		if (Boolean.TRUE.equals(clockImpact.getClockStopped()))
		{
			referral.getJourney().getCurrentClock().setStopDate(null);
		}
		
		referral.setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		
		if (referral.getJourney().getCurrentClock() != null)
		{
			referral.getJourney().getCurrentClock().setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
			referral.getJourney().getCurrentClock().getRTTStatusHistory().remove(clockImpact.getFinalRTTStatus());
		}
		
		if ((clockImpact.getInitialClock() == null || clockImpact.getInitialClock().getID_PathwayClock() != clockImpact.getFinalClock().getID_PathwayClock()) && referral.getJourney().getClockHistory() != null)
		{
			referral.getJourney().getClockHistory().remove(clockImpact.getFinalClock());
		}
		
		// If there is an Undo Event saved against the map of the clock Impact then instantiate a Patient Event
		if (clockImpact.getOutcomeEvent() != null && clockImpact.getOutcomeEvent().getUndoEvent() != null)
		{
			// Attempt to create and instantiate a Patient Event
			try
			{
				PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, clockImpact.getOutcomeEvent().getUndoEvent(), new DateTime());
				referral.setJourney(patientEventVo.getJourney());
				if (referral.getJourney() != null && referral.getJourney().getCurrentClock() != null)
				{
					referral.setCurrentRTTStatus(patientEventVo.getJourney().getCurrentClock().getCurrentRTTStatus());
				}
			}
			// If an exception occurs at this point then log it in the system 
			catch (DomainInterfaceException exception)
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
			}
		}
		
		if (AdminEventOutcome.DECISION_NOT_TO_TREAT.equals(adminEvent.getOutcome()) || AdminEventOutcome.PATIENT_REFUSES_TREATMENT.equals(adminEvent.getOutcome()))
		{
			if (ReferralApptStatus.END_OF_CARE.equals(referral.getCurrentStatus().getReferralStatus()))
			{
				referral.getStatusHistory().remove(referral.getCurrentStatus());
				
				referral.getStatusHistory().sort(SortOrder.DESCENDING);
				CATSReferralStatusRefVo referralStatus = referral.getStatusHistory().get(0);
				// Quick & dirty - it should be ok as the referral status is saved as a RefVo
				referral.setCurrentStatus(new CatsReferralStatusVo(referralStatus.getID_CATSReferralStatus(), referralStatus.getVersion_CATSReferralStatus()));
				referral.setEndOfCareDate(null);
			}
		}

		referral.getRTTClockImpacts().remove(clockImpactRef);
		CatsReferral catsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(factory, referral);
		factory.save(catsReferral);

		adminEvent.setRTTClockImpact(null);
		AdminEvent adminEventDom = AdminEventVoAssembler.extractAdminEvent(factory, adminEvent);
		factory.save(adminEventDom);
		factory.markAsRie(AdminEvent.class, adminEvent.getID_AdminEvent(), null, null, null, null, "Undo Clock Impact saved.");
			
		return IRecordRTTClockImpact.UNDO_CLOCK_IMPACT_SUCCESS;
	}
	
	
	public Integer undoAppointmentOutcomeClockImpact(BookingAppointmentOutcomeVo appointmentOutcome, PathwayRTTClockImpactVo clockImpactRef, ApptOutcome outcomeBeeingReverted) throws DomainInterfaceException, StaleObjectException
	{
		// Check for valid parameters
		if (appointmentOutcome == null || appointmentOutcome.getID_Booking_Appointment() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		DomainFactory factory = getDomainFactory();
		
		// Get CATS Referral record by appointment
		// If no referral record is found or the referral found is NOT subject to RTT Clock (or has no Journey) then terminate function 
		CATSReferral_ClockImpactVo referral = null;
		
		String query = "SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.appointments AS appts WHERE appts.id = :BookAppointment";
		List<?> doCatsList = factory.find(query, new String[] {"BookAppointment"}, new Object[] {appointmentOutcome.getID_Booking_Appointment()});
		
		if (doCatsList == null || doCatsList.size() == 0 || doCatsList.get(0) == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		if (doCatsList.get(0) instanceof CatsReferral)
		{
			referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) doCatsList.get(0));
		}
		
		if (referral == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		// Undo Cats Referral End Of Care
		if (ApptOutcome.DECISION_NOT_TO_TREAT.equals(outcomeBeeingReverted)
				|| ApptOutcome.PATIENT_DECLINED_OFFER.equals(outcomeBeeingReverted))
		{
			referral = undoReferralEndOfCare(referral);
		}


		if (clockImpactRef == null || clockImpactRef.getID_PathwaysRTTClockImpact() == null)
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;

		PathwayRTTClockImpactUndoVo clockImpact = PathwayRTTClockImpactUndoVoAssembler.create((PathwaysRTTClockImpact) factory.getDomainObject(PathwaysRTTClockImpact.class, clockImpactRef.getID_PathwaysRTTClockImpact()));
		
		if (referral.getJourney() == null || (!Boolean.TRUE.equals(referral.getRTTClockImpact()) && (referral.getDOS() == null || !Boolean.TRUE.equals(referral.getDOS().getRTTClockImpact()))))
			return IRecordRTTClockImpact.NO_CLOCK_IMPACT;
		
		
		// Test that the Clock Impact can be undone
		// Conditions so that the clock Impact can be undone
		// 1 - RTT Status must be the one recorded in final status
		// 2 - Clock must be same as in the final clock
		if (!isLastClockImpact(referral, clockImpact))
		{
			return IRecordRTTClockImpact.NOT_LAST_IMPACT;
		}
		
		// Begin the process to undo the clock referral
		referral.getJourney().setCurrentClock(clockImpact.getInitialClock());
		
		// Check the initial state of the clock, not the clock impact
		if (RTTClockState.STARTED.equals(clockImpact.getInitialClockState()) && referral.getJourney().getCurrentClock() != null)
		{
			referral.getJourney().getCurrentClock().setStopDate(null);
		}
		
		referral.setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
		
		if (referral.getJourney().getCurrentClock() != null)
		{
			referral.getJourney().getCurrentClock().setCurrentRTTStatus(clockImpact.getInitialRTTStatus());
			referral.getJourney().getCurrentClock().getRTTStatusHistory().remove(clockImpact.getFinalRTTStatus());
		}
		
		if ((clockImpact.getInitialClock() == null || clockImpact.getInitialClock().getID_PathwayClock() != clockImpact.getFinalClock().getID_PathwayClock()) && referral.getJourney().getClockHistory() != null)
		{
			referral.getJourney().getClockHistory().remove(clockImpact.getFinalClock());
		}

		boolean undoEventInstantiated = false;
		
		// If there is an Undo Event saved against the map of the clock Impact then instantiate a Patient Event
		if (clockImpact.getOutcomeEvent() != null && clockImpact.getOutcomeEvent().getUndoEvent() != null)
		{
			// Attempt to create and instantiate a Patient Event
			try
			{
				PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, clockImpact.getOutcomeEvent().getUndoEvent(), new DateTime());
				referral.setJourney(patientEventVo.getJourney());
				undoEventInstantiated = true;
			}
			// If an exception occurs at this point then log it in the system 
			catch (DomainInterfaceException exception)
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
			}
		}
		
		if (!undoEventInstantiated)
		{
			// create Undo DNA hard coded event - WDEV-19772 
			if (ApptOutcome.PATIENT_DID_NOT_ATTEND.equals(outcomeBeeingReverted) || Status_Reason.BOOKED.equals(appointmentOutcome.getApptStatus()))
			{
				EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.APPOINTMENTUNDNA.getID());
				if (hardCodedEvent != null)
				{
    				try
    				{
    					PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, hardCodedEvent, new DateTime());
    					referral.setJourney(patientEventVo.getJourney());
    				}
    					// If an exception occurs at this point then log it in the system 
    				catch (DomainInterfaceException exception)
    				{
    					createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
    				}
				}
			}
		}

		appointmentOutcome.setOutcomeHasRTTClockImpact(Boolean.FALSE);
		appointmentOutcome.setRTTClockImpact(null);
		Booking_Appointment appointmentOutcomeDom = BookingAppointmentOutcomeVoAssembler.extractBooking_Appointment(factory, appointmentOutcome);
		factory.save(appointmentOutcomeDom);

		referral.getRTTClockImpacts().remove(clockImpactRef);
		CatsReferral catsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(factory, referral);
		factory.save(catsReferral);
			
		return IRecordRTTClockImpact.UNDO_CLOCK_IMPACT_SUCCESS;
	}
	

	private boolean isLastClockImpact(CATSReferral_ClockImpactVo referral, PathwayRTTClockImpactUndoVo clockImpact)
	{
		if (clockImpact == null || referral == null || referral.getJourney() == null)
			return false;
		
		if (clockImpact.getFinalClock() == null && referral.getJourney().getCurrentClock() != null)
			return false;
		
		if (clockImpact.getFinalClock() != null && referral.getJourney().getCurrentClock() == null)
			return false;
		
		if (clockImpact.getFinalClock() != null && referral.getJourney().getCurrentClock() != null
				&& !clockImpact.getFinalClock().equals(referral.getJourney().getCurrentClock()))
			return false;
		
		
		//WDEV-20093
		if (clockImpact.getFinalRTTStatus() == null && referral.getJourney().getCurrentClock() != null && referral.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
			return false;
		
		if (clockImpact.getFinalRTTStatus() != null)
		{
			if (referral.getJourney().getCurrentClock() != null && !clockImpact.getFinalRTTStatus().equals(referral.getJourney().getCurrentClock().getCurrentRTTStatus()))
				return false;
			
			if (referral.getJourney().getCurrentClock() == null && !clockImpact.getFinalRTTStatus().equals(referral.getCurrentRTTStatus()))
				return false;
		}

		return true;
	}
	
	
	
	public boolean recordAppointmentOutcomeClockImpact(BookingAppointmentOutcomeVo appointmentOutcome, EventLiteVo firstDefinitiveTreatmentEvent) throws DomainInterfaceException, StaleObjectException
	{
		if (appointmentOutcome == null || appointmentOutcome.getID_Booking_Appointment() == null)
			return false;
		Date referralDate = null;
		
		PatientEventVoCollection patientEventCollection = new PatientEventVoCollection();
		
		CATSReferral_ClockImpactVo referral = null;
		
		String query = "SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.appointments AS appts WHERE appts.id = :BookAppointment";
		List<?> doCatsList = getDomainFactory().find(query, new String[] {"BookAppointment"}, new Object[] {appointmentOutcome.getID_Booking_Appointment()});
		
		if (doCatsList == null || doCatsList.size() == 0 || doCatsList.get(0) == null)
			return false;
		
		if (doCatsList.get(0) instanceof CatsReferral)
		{
			CatsReferral catsReferral = (CatsReferral) doCatsList.get(0);
			referral = CATSReferral_ClockImpactVoAssembler.create(catsReferral); //WDEV-21454
			if(catsReferral.getReferralDetails() != null
				&& catsReferral.getReferralDetails().getDateOfReferral() != null)
			{
				referralDate = new Date(catsReferral.getReferralDetails().getDateOfReferral());
			}
		}
		

		// For DECISION NOT TO TREAT and PATIENT DECLINED OFFERRED TREATMENT - also set the referral as End Of Care 
//		if (ApptOutcome.DECISION_NOT_TO_TREAT.equals(appointmentOutcome.getOutcome())
//				|| ApptOutcome.PATIENT_DECLINED_OFFER.equals(appointmentOutcome.getOutcome()))
//		{
//			referral = setReferralEndOfCare(referral);
//		}
		
		if (referral.getJourney() == null)
		{
			// Check if referral needs to be set to End of Care and cancel appointments and TCIs
			checkReferralSetEndOfCareTerminateAppointments(referral, appointmentOutcome);
			
			return false;
		}
		

		PathwayClockVo initialClock =null;
		if(referral.getJourney()!=null)
			initialClock = referral.getJourney().getCurrentClock() != null ? (PathwayClockVo) referral.getJourney().getCurrentClock().clone() : null;
		PathwayRTTStatusVo initialRTTStatus = referral.getCurrentRTTStatus();
		
	
		// Set the final RTTStatus to current referral status
		// If there is no RTTEventMap configured, this will ensure that the RTTStatus will be unchanged
		PathwayRTTStatusVo finalRTTStatus = referral.getCurrentRTTStatus();

		// The initial Event Outcome Map configuration used is null
		// and will be updated only if one is used
		RTTStatusEventMapVo appointmentOutcomeMap = null;

		boolean appointmentOutcomeAnalyzed = false;
		
		boolean cancerReferral = (referral.getReferralDetails().getReferrerType() != null && SourceOfReferral.NATIONAL_SCREENING.getId() == referral.getReferralDetails().getReferrerType().getID())
									|| (referral.getUrgency() != null && ReferralUrgency.TWO_WEEK_WAIT.getId() == referral.getUrgency().getId())
									|| (referral.getUrgency() != null && ReferralUrgency.CONSULTANT_UPGRADE.getId() == referral.getUrgency().getId());
		
		PatientLiteVo patient = PatientLiteVoAssembler.create((Patient) getDomainFactory().getDomainObject(referral.getPatient()));
		Integer patientAge = patient.calculateAge();
		boolean paediatricPatient = patientAge != null && ConfigFlag.GEN.PAEDIATRIC_AGE.getValue() > patientAge;  

		
		// For Non-Pediatric patients and Non-cancer referrals
		if (!cancerReferral && !paediatricPatient)
		{
			// If the appointment is the First Consultation Appointment and it's clock is the current clock
			// and the appointment is DNA then STOP current clock to 33
			if (Boolean.TRUE.equals(appointmentOutcome.getFirstConsultationActivity())
					&& appointmentOutcome.getApptStatusIsNotNull() && Status_Reason.DNA.equals(appointmentOutcome.getApptStatus())
					&& appointmentClockIsSameClock(appointmentOutcome, referral))
			{
				if (referral.getJourney() != null && referral.getJourney().getCurrentClock() != null)
				{
					if(ApptOutcome.SEND_AGAIN.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;
						
						// Set the status to 33 - National code
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_PATIENT_DID_NOT_ATTEND, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);
					
						// Stop clock for everything EXCEPT pediatric patient where the outcome is send again	
						if(!(referralDate != null
							&&referral.getJourney().getPatient() != null	
							&&referral.getJourney().getPatient().isPaediatricOn(referralDate))) 
						{
							referral.getJourney().getCurrentClock().setStopDate(appointmentOutcome.getAppointmentDate());
						}
					}
					else if(ApptOutcome.DISCHARGED_BACK_TO_GP.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;
					
						// Set the status to 33 - National code
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_PATIENT_DID_NOT_ATTEND, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);
						
						referral.getJourney().getCurrentClock().setStopDate(appointmentOutcome.getAppointmentDate()); 
					}
					
					if ((referral != null && referral.getJourney() != null) 
							&& appointmentOutcome.getApptStatusIsNotNull() && Status_Reason.DNA.equals(appointmentOutcome.getApptStatus()) 
							&& appointmentOutcome.getActivity() != null && Boolean.TRUE.equals(appointmentOutcome.getActivity().getFirstAppointment())
							&& Boolean.TRUE.equals(appointmentOutcome.getSession().getService().getIsSubjectToRTTClock())) //WDEV-20279
					{
						PatientEventVo patientEvent = instantiatePatientEventForDidNotAttend(referral, appointmentOutcome);  //http://jira/browse/WDEV-21815
						patientEventCollection.add(patientEvent);
						
						// Refresh referral record
						referral.setJourney(patientEvent.getJourney());
					}
				}
			}
			else if (Status_Reason.DNA.equals(appointmentOutcome.getApptStatus()))
			{
				if (referral.getJourney() != null && referral.getJourney().getCurrentClock() != null)
				{
					if (ApptOutcome.SEND_AGAIN.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;

						// Set the status to 20
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_SUBSEQUENT_ACTIVITY_IN_RTT_PERIOD, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);
					}
					else if (ApptOutcome.DISCHARGED_BACK_TO_GP.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;

						// Set the status to 34 - National code
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_DECISION_NOT_TO_TREAT, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);

						referral.getJourney().getCurrentClock().setStopDate(appointmentOutcome.getAppointmentDate()); 
					}

					if ((referral != null && referral.getJourney() != null) 
							&& appointmentOutcome.getApptStatusIsNotNull()&&Status_Reason.DNA.equals(appointmentOutcome.getApptStatus()) 
							&& appointmentOutcome.getActivity() != null && Boolean.TRUE.equals(appointmentOutcome.getActivity().getFirstAppointment())
							&& Boolean.TRUE.equals(appointmentOutcome.getSession().getService().getIsSubjectToRTTClock())) //WDEV-20279
					{
						PatientEventVo patientEvent = instantiatePatientEventForDidNotAttend(referral, appointmentOutcome);  //http://jira/browse/WDEV-21815
						patientEventCollection.add(patientEvent);

						// Refresh referral record
						referral.setJourney(patientEvent.getJourney());
					}
				}
			}
		}
		else if (cancerReferral || paediatricPatient)
		{
			if (referral.getJourney() != null && referral.getJourney().getCurrentClock() != null)
			{
				if (Status_Reason.DNA.equals(appointmentOutcome.getApptStatus()))
				{
					if (ApptOutcome.SEND_AGAIN.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;

						// Set the status to 20
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_SUBSEQUENT_ACTIVITY_IN_RTT_PERIOD, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);
					}
					else if (ApptOutcome.DISCHARGED_BACK_TO_GP.equals(appointmentOutcome.getOutcome()))
					{
						appointmentOutcomeAnalyzed = true;

						// Set the status to 34 - National code
						finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_DECISION_NOT_TO_TREAT, appointmentOutcome.getOutcomeDateTime());
						// Set the referral Current RTT Status
						referral.setCurrentRTTStatus(finalRTTStatus);

						referral.getJourney().getCurrentClock().setStopDate(appointmentOutcome.getAppointmentDate()); 
					}

					if ((referral != null && referral.getJourney() != null) 
							&& appointmentOutcome.getApptStatusIsNotNull()&&Status_Reason.DNA.equals(appointmentOutcome.getApptStatus()) 
							&& appointmentOutcome.getActivity() != null && Boolean.TRUE.equals(appointmentOutcome.getActivity().getFirstAppointment())
							&& Boolean.TRUE.equals(appointmentOutcome.getSession().getService().getIsSubjectToRTTClock())) //WDEV-20279
					{
						PatientEventVo patientEvent = instantiatePatientEventForDidNotAttend(referral, appointmentOutcome);  //http://jira/browse/WDEV-21815
						patientEventCollection.add(patientEvent);

						// Refresh referral record
						referral.setJourney(patientEvent.getJourney());
					}
				}
			}
		}
		
			

		// Get final RTT Clock Impact as Patient Event instantiation might have changed it
		PathwayClockVo finalClock = null;
		if(referral.getJourney()!=null)
			finalClock = referral.getJourney().getCurrentClock();

		if (appointmentOutcomeAnalyzed == false)
		{
			// Get the RTTStatusEventMap for the AppointmentOutcome
			appointmentOutcomeMap = getRTTStatusEventMapByEncounter(appointmentOutcome.getOutcome());

			if (appointmentOutcomeMap != null)
			{
				// If there is an event in the map settings then 
				if (appointmentOutcomeMap.getEvent() != null)
				{
					// Attempt to create and instantiate a Patient Event
					try
					{
						PatientEventVo patientEvent = createAndInstantiatePatientEvent(referral, appointmentOutcomeMap.getEvent(), new DateTime(appointmentOutcome.getAppointmentDate(), appointmentOutcome.getApptStartTime()));
						patientEventCollection.add(patientEvent);
						appointmentOutcomeAnalyzed = true;

						// Refresh referral record
						referral.setJourney(patientEvent.getJourney());
					}
					// If an exception occurs at this point then log it in the system 
					catch (DomainInterfaceException exception)
					{
						createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
					}
				}

				// WDEV-20947 - Set RTT status only if referral subject to RTT
				if (referral.getRTTClockImpactIsNotNull() && referral.getRTTClockImpact().booleanValue() == true)
				{
					// Create RTT Status for referral
					finalRTTStatus = createRTTStatus(appointmentOutcomeMap, appointmentOutcome.getOutcomeDateTime());
					// Set the referral CurrentRTTStatus if 
					referral.setCurrentRTTStatus(finalRTTStatus);
				}
			}
		}
		
		// Get final RTT Clock Impact as Patient Event instantiation might have changed it
		if(referral.getJourney()!=null)
			finalClock = referral.getJourney().getCurrentClock();

		// Update Clock depending on the Appointment Outcome - hard-coded style
		if (appointmentOutcomeAnalyzed == false)
		{
			if (ApptOutcome.DECISION_TO_TREAT.equals(appointmentOutcome.getOutcome()) 
				|| ApptOutcome.DECISIONTREATACTIVEMONITORING.equals(appointmentOutcome.getOutcome()))
			{
				// If there is no clock or the clock is stopped, then start a new clock - as a hardcoded requirement
				// WDEV-20947 - New clock only required if the Referral is subject to RTT!
				if ((finalClock == null || finalClock.getStopDate() != null) && referral.getRTTClockImpactIsNotNull() && referral.getRTTClockImpact().booleanValue() == true)
				{
					finalClock = new PathwayClockVo();

					finalClock.setStartDate(new Date());
					finalClock.setStopDate(null);
					finalClock.setTargetClockEnd(getTargetClockEnd(finalClock.getStartDate(), referral));

					int X = getNumberOfClocks(referral.getJourney().getClockHistory());
					finalClock.setExtClockId("MAXIMS_" + (X + 1));
					finalClock.setExtClockName("MaximsClock_" + (X + 1));

					finalClock.setRTTStatusHistory(new PathwayRTTStatusRefVoCollection());
					
					if (referral.getJourney().getClockHistory() == null)
						referral.getJourney().setClockHistory(new PathwayClockVoCollection());

					referral.getJourney().setCurrentClock(finalClock);
					referral.getJourney().getClockHistory().add(finalClock);
				}
			}
			else if (ApptOutcome.START_ACTIVE_MONITORING_BY_PATIENT.equals(appointmentOutcome.getOutcome())
					|| ApptOutcome.START_ACTIVE_MONITORING_BY_CARE_PROF.equals(appointmentOutcome.getOutcome())
					|| ApptOutcome.DECISION_NOT_TO_TREAT.equals(appointmentOutcome.getOutcome())
					|| ApptOutcome.PATIENT_DECLINED_OFFER.equals(appointmentOutcome.getOutcome()))
			{
				// If there is a clock and the clock is not stopped, then stop the clock - as a hardcoded requirement
				if (finalClock != null && finalClock.getStopDate() == null)
				{
					finalClock.setStopDate(new Date());
				}
			}
			else if ((ApptOutcome.PATIENT_DID_NOT_ATTEND.equals(appointmentOutcome.getOutcome()) || Status_Reason.DNA.equals(appointmentOutcome.getApptStatus())) 
					&& appointmentOutcome.getActivity() != null && Boolean.TRUE.equals(appointmentOutcome.getActivity().getFirstAppointment()) && Boolean.TRUE.equals(appointmentOutcome.getSession().getService().getIsSubjectToRTTClock())) //WDEV-20279
			{
				// HERE
				
				// Create DNA hard coded event 
				EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.APPOINTMENTDNA.getID());
				if (hardCodedEvent != null)
				{
					try
					{
						PatientEventVo patientEvent = createAndInstantiatePatientEvent(referral, hardCodedEvent, new DateTime(appointmentOutcome.getAppointmentDate(), appointmentOutcome.getApptStartTime()));
						patientEventCollection.add(patientEvent);
						appointmentOutcomeAnalyzed = true;

						// Refresh referral record
						referral.setJourney(patientEvent.getJourney());
						
						// Refresh final clock as the 'Hard coded DNA event' might have changed
						if(referral.getJourney()!=null)
							finalClock = referral.getJourney().getCurrentClock();
					}
					// If an exception occurs at this point then log it in the system 
					catch (DomainInterfaceException exception)
					{
						createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
					}
				}
			}
		}
		
		// Update the RTT Status in final clock also (test if necessary, but it should be necessary)
		if (finalClock != null)
		{
			if (finalClock.getRTTStatusHistory() == null)
				finalClock.setRTTStatusHistory(new PathwayRTTStatusRefVoCollection());

			finalClock.setCurrentRTTStatus(finalRTTStatus);
			finalClock.getRTTStatusHistory().add(finalRTTStatus);
			
		}
		
		
		
		if (Boolean.TRUE.equals(appointmentOutcome.getWasFirstDefinitiveTreatment()))
		{
			boolean firstDefinitiveTreatementPatientEventCreated = false;
			
			// RTTStatusEventMap for FirstTreatment - it should be used the one for the configured Event
			RTTStatusEventMapVo firstTreatmentMap = null;
			
			if (firstDefinitiveTreatmentEvent != null)
			{
				// Get RTTStatusEventMap for FirstTreatmentEvent
				firstTreatmentMap = getRTTStatusEventMapByEvent(firstDefinitiveTreatmentEvent);

				// Attempt to create and instantiate a Patient Event
				try
				{
					PatientEventVo patientEventVo = createAndInstantiatePatientEvent(referral, firstDefinitiveTreatmentEvent, new DateTime(appointmentOutcome.getAppointmentDate(), appointmentOutcome.getApptStartTime()));
					patientEventCollection.add(patientEventVo);
					firstDefinitiveTreatementPatientEventCreated = true;

					// Refresh referral record
					referral.setJourney(patientEventVo.getJourney());
				}
				// If an exception occurs at this point then log it in the system 
				catch (DomainInterfaceException exception)
				{
					createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
				}
			}
			
			
			// Refresh final RTT Clock as the 'First Definitive Treatment' Patient Event might have changed it
			finalClock = referral.getJourney().getCurrentClock();

			if (firstDefinitiveTreatementPatientEventCreated == false)
			{
    			// If the clock was not stopped, then it means that the function createAndInstantiatePatientEvent
    			// did not stop the clock, so stop it now - as a hardcoded requirement
    			if (finalClock != null && finalClock.getStartDate() != null && finalClock.getStopDate() == null)
    			{
    				finalClock.setStopDate(new Date());
    			}
			}
			
			if (firstTreatmentMap != null && firstTreatmentMap.getTargetRTTStatus() != null)	// If we have a RTT Map & we have a Target RTT status
			{
				finalRTTStatus = createRTTStatus(firstTreatmentMap, appointmentOutcome.getOutcomeDateTime());		// And a RTT Status is created
			}
			else		// If no RTT Map is found or the RTT Map target status is null, then set the RTT Status to '30 - Start of First Definitive Treatment'
			{
				finalRTTStatus = createRTTStatus(NATIONAL_CODE_FOR_START_FIRST_DEFINITIVE_TREATMENT, appointmentOutcome.getOutcomeDateTime());
			}

			referral.setCurrentRTTStatus(finalRTTStatus);				// update the RTT Status in referral
			
			// Update the RTT Status in final clock also (test if necessary, but it should be necessary)
			if (finalRTTStatus != null && finalRTTStatus.getRTTStatus() != null
					&& finalClock != null && finalClock.getCurrentRTTStatus() != null && finalClock.getCurrentRTTStatus().getRTTStatus() != null
					&& !finalClock.getCurrentRTTStatus().getRTTStatus().equals(finalRTTStatus.getRTTStatus()))																
			{
				if (finalClock.getRTTStatusHistory() == null)
					finalClock.setRTTStatusHistory(new PathwayRTTStatusRefVoCollection());

				finalClock.setCurrentRTTStatus(finalRTTStatus);
				finalClock.getRTTStatusHistory().add(finalRTTStatus);
			}
		}
		
		// Analyze the impact on the RTT Status & Clock
		// Create PathwayClockImpact 
		// WDEV-20947 create clock impact record only if this referral is subject to RTT
		if (Boolean.TRUE.equals(referral.getRTTClockImpact()))
		{
			PathwayRTTClockImpactVo clockImpact = createRTTClockImpactRecord(initialClock, finalClock, initialRTTStatus, finalRTTStatus, appointmentOutcomeMap, referral.getJourney(), RTTClockImpactSource.APPOINTMENT_OUTCOME, appointmentOutcome.getOutcome());
		
			if (referral.getRTTClockImpacts() == null)
				referral.setRTTClockImpacts(new PathwayRTTClockImpactVoCollection());
			referral.getRTTClockImpacts().add(clockImpact);
			
			referral.getReferralDetails().setEnd18WW(finalClock != null ? finalClock.getTargetClockEnd() : getTargetClockEnd(new Date(), referral));

			appointmentOutcome.setOutcomeHasRTTClockImpact(Boolean.TRUE);
			appointmentOutcome.setRTTClockImpact(clockImpact);
		}
		
		@SuppressWarnings("rawtypes")
		HashMap hashMap = new HashMap(); // http://jira/browse/WDEV-21815
		CatsReferral domReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(getDomainFactory(), referral, hashMap);
		Booking_Appointment domBooking = BookingAppointmentOutcomeVoAssembler.extractBooking_Appointment(getDomainFactory(), appointmentOutcome, hashMap);
		
		
		EventVo event = checkIfAPatientEventIsEndsPathways(patientEventCollection);//appointmentOutcomeMap != null && appointmentOutcomeMap.getEvent() != null && Boolean.TRUE.equals(appointmentOutcomeMap.getEvent().getEndsPathway()))
		if (event != null || ApptOutcome.PATIENT_DECLINED_OFFER.equals(appointmentOutcome.getOutcome()) || ApptOutcome.DECISION_NOT_TO_TREAT.equals(appointmentOutcome.getOutcome()))
		{
			setReferralEndOfCareAndCancelAllFutureApptAndTCI(domReferral, event);
		}
		
		getDomainFactory().save(domReferral);
		getDomainFactory().save(domBooking);
		
		
		// WDEV-18475 // WDEV-18602 
		// If this is a cancer pathway or Referral Urgency is 'Two Week Wait' or 'Consultant Upgrade'
		// and decision to treat or waiting list outcome, we want the 31 day target
		if (ApptOutcome.DECISION_TO_TREAT.equals(appointmentOutcome.getOutcome()) || ApptOutcome.DECISIONTREATACTIVEMONITORING.equals(appointmentOutcome))
		{
			// This only applies for non-diagnostic appointments TODO Ask if this is correct
			if (appointmentOutcome.getActivity() != null && !Boolean.TRUE.equals(appointmentOutcome.getActivity().getDiagnostic()))
			{
				
				//  This only applies to Cancer Pathway and Pathway Cancer     this a Cancer Pathway and non-diagnostic
				if (Boolean.TRUE.equals(referral.getJourney().getIsCancerPathway()) || 
						(ReferralUrgency.CONSULTANT_UPGRADE.equals(referral.getUrgency())) || ReferralUrgency.TWO_WEEK_WAIT.equals(referral.getUrgency()))
				{
					// Find the Target 31Day
					HL7PathwayIf hl7Impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
					try 
					{
						TargetRefVo target = hl7Impl.getTargetByTaxonomyMap(TaxonomyType.PAS, "DTT31");  // WDEV-20636 new target to be instantiated on Decision to Treat

						if (target != null)
							hl7Impl.bringTargetIntoScopeWithoutEvent(domReferral.getJourney(), null, (Target) getDomainFactory().getDomainObject(Target.class, target.getID_Target()), new DateTime(), 31);
						
					}
					catch (DomainInterfaceException e) 
					{
						super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, e.getMessage());
					}
				}
			}
		}
		

//		if (appointmentOutcome.getOutcome() != null && (appointmentOutcome.getOutcome().getId() == ApptOutcome.DECISION_TO_TREAT.getId() ||
//											appointmentOutcome.getOutcome().getId() == ApptOutcome.DECISIONTREATACTIVEMONITORING.getId()))//WDEV-20319
//		{
//				// Is this a Cancer Pathway and non-diagnostic
//				if (appointmentOutcome.getActivity() != null && appointmentOutcome.getActivity().isDiagnostic() != null && !appointmentOutcome.getActivity().isDiagnostic())
//				{
//					if ((parentReferral.getJourney() != null && parentReferral.getJourney().isIsCancerPathway() != null && parentReferral.getJourney().isIsCancerPathway()) ||
//						(parentReferral.getUrgency() != null && (parentReferral.getUrgency().getId() == ReferralUrgency.CONSULTANT_UPGRADE.getID() || parentReferral.getUrgency().getId() == ReferralUrgency.TWO_WEEK_WAIT.getID())))
//					{
//						// Find the Target 31Day
//						HL7PathwayIf hl7Impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
//						try 
//						{
//							TargetRefVo target = hl7Impl.getTargetByTaxonomyMap(TaxonomyType.PAS, "DTT31");  // WDEV-20636 new target to be instantiated on Decision to Treat
//							if (target != null)
//								hl7Impl.bringTargetIntoScopeWithoutEvent(target, new PatientPathwayJourneyRefVo(parentReferral.getJourney().getId(), parentReferral.getJourney().getVersion()), new ims.framework.utils.Date());
//							
//						}
//						catch (DomainInterfaceException e) 
//						{
//							super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, e.getMessage());
//						}
//					}
//				}
//		}
		
		
		return true;
	}
	

	private void checkReferralSetEndOfCareTerminateAppointments(CATSReferral_ClockImpactVo referral, BookingAppointmentOutcomeVo appointmentOutcome) throws StaleObjectException
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			return;
		
		if (appointmentOutcome == null)
			return;
		
		CatsReferral domReferral = (CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, referral.getID_CatsReferral());
		
		// Get configured event for outcome
		RTTStatusEventMapVo eventMap = getRTTStatusEventMapByEncounter(appointmentOutcome.getOutcome());
		
		if (eventMap != null && eventMap.getEvent() != null && Boolean.TRUE.equals(eventMap.getEvent().getEndsPathway()))
		{
			setReferralEndOfCareAndCancelAllFutureApptAndTCI(domReferral, eventMap.getEvent());
		}
		else if (ApptOutcome.DECISION_NOT_TO_TREAT.equals(appointmentOutcome.getOutcome()) 
					|| ApptOutcome.PATIENT_DECLINED_OFFER.equals(appointmentOutcome.getOutcome()))
		{
			setReferralEndOfCareAndCancelAllFutureApptAndTCI(domReferral, null);
		}

		getDomainFactory().save(domReferral);
	}

	private EventVo checkIfAPatientEventIsEndsPathways(PatientEventVoCollection patientEventCollection)
	{
		if(patientEventCollection == null || patientEventCollection.size() == 0)
			return null;
		
		String patientEventIds = getPatientEventIds(patientEventCollection);
		
		if(patientEventIds == null)
			return null;
		
		DomainFactory fatory = getDomainFactory();
		String query = "select ev from PatientEvent as pe left join pe.event as ev where pe.id in (" + patientEventIds + ") and ev.endsPathway = 1 ";
		
		List eventsLis = fatory.find(query);
		
		if(eventsLis != null && eventsLis.size() > 0)
		{
			return EventVoAssembler.create((Event) eventsLis.get(0));
		}
		
		return null;
	}

	private String getPatientEventIds(PatientEventVoCollection patientEventCollection)
	{
		if(patientEventCollection == null || patientEventCollection.size() == 0)
			return null;
		
		StringBuilder st = new StringBuilder();
		
		for(PatientEventVo patientEvent : patientEventCollection)
		{
			if(patientEvent == null)
				continue;
			
			if(st.length() > 0)
				st.append(",");
			
			st.append(patientEvent.getID_PatientEvent());
		}
		
		return st.length() > 0 ? st.toString() : null;
	}

	public void setReferralEndOfCareAndCancelAllFutureApptAndTCI(CatsReferral catsReferral, EventLiteVo event) throws StaleObjectException
	{
		if(catsReferral == null)
			return;
		
		cancelAllFutureAppt(catsReferral, event);
		removeAllPatientElectiveListAndCancelFutureTCI(catsReferral, event);
		markAsRemovedFutureAppointments(catsReferral);
		markAsRemovedPendingEmergencyTheatre(catsReferral);
		setReferralToEndOfCare(catsReferral);
	}
	
	private void markAsRemovedPendingEmergencyTheatre(CatsReferral catsReferral) throws StaleObjectException
	{
		if(catsReferral == null || catsReferral.getId() == null)
			return;
		
		DomainFactory factory = getDomainFactory();
		String query = "select pet from PendingEmergencyTheatre as pet left join pet.catsReferral as cats left join pet.currentStatus as cs where cats.id = :CatsId and cs.id = :StatusId ";
		
		List pendingEmergencyTheatreList = factory.find(query, new String[] {"CatsId", "StatusId"}, new Object[] {catsReferral.getId(), PendingEmergencyTheatreStatus.THEATRE_SLOT_TO_BE_BOOKED.getID()});
		
		if(pendingEmergencyTheatreList == null)
			return;
		
		for(int i=0; i<pendingEmergencyTheatreList.size(); i++)
		{
			if(pendingEmergencyTheatreList.get(i) == null)
				continue;
			
			PendingEmergencyTheatre record = (PendingEmergencyTheatre) pendingEmergencyTheatreList.get(i);
			
			record.setCurrentStatus(getDomLookup(PendingEmergencyTheatreStatus.REMOVED));
			
			factory.save(record);
		}
	}

	private void setReferralToEndOfCare(CatsReferral catsReferral)
	{
		if(catsReferral == null)
			return;
		
		CatsReferralStatusVo status = new CatsReferralStatusVo();
		status.setReferralStatus(ReferralApptStatus.END_OF_CARE);
		status.setStatusDateTime(new DateTime());
		status.setAuthoringUser((MemberOfStaffRefVo) getMosUser());
		status.setComment(null);
		
		CATSReferralStatus domCatsReferralStatus = CatsReferralStatusVoAssembler.extractCATSReferralStatus(getDomainFactory(), status);

		catsReferral.setCurrentStatus(domCatsReferralStatus);
		
		if (catsReferral.getStatusHistory() == null)
			catsReferral.setStatusHistory(new HashSet());
		
		catsReferral.getStatusHistory().add(domCatsReferralStatus);
		
		catsReferral.setEndOfCareDate((new Date()).getDate());
	}

	private void removeAllPatientElectiveListAndCancelFutureTCI(CatsReferral catsReferral, EventLiteVo event) throws StaleObjectException
	{
		if(catsReferral == null)
			return;
		
		DomainFactory factory = getDomainFactory();
		
		String hqlString = "select list from PatientElectiveList as list left join list.referral as referral left join list.electiveListStatus as elStatus left join elStatus.electiveListStatus as stat where referral.id = :ReferralId and stat.id <> :StatusId" ;
		List<?> electiveList = factory.find(hqlString, new String[] { "ReferralId", "StatusId" }, new Object[] { catsReferral.getId(), WaitingListStatus.REMOVED.getID() });

		if(electiveList == null || electiveList.size() == 0)
			return;
		
		PatientElectiveList doPatientElectiveList = null;

		MemberOfStaff domainMOS = null;
		Object mosUser = getMosUser();

		if(mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
		}

		Date currentDate = new Date();

		for(int i = 0; i < electiveList.size(); i++)
		{
			doPatientElectiveList = (PatientElectiveList) electiveList.get(i);

			if (doPatientElectiveList != null)
			{
				ElectiveListStatus status = new ElectiveListStatus();
				status.setElectiveListStatus(getDomLookup(WaitingListStatus.REMOVED));
				status.setRemovalReason(getDomLookup(ElectiveListStatusReason.PATIENT_REMOVED_FOR_OTHER_REASONS));
				status.setAuthoringUser(domainMOS);
				status.setStatusDateTime(new java.util.Date());

				doPatientElectiveList.setElectiveListStatus(status);

				if(doPatientElectiveList.getElectiveListStatusHistory() == null)
				{
					doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());
				}

				doPatientElectiveList.getElectiveListStatusHistory().add(status);

				TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();
				
				if(doTCIDetails != null && doTCIDetails.isIsActive() && doTCIDetails.getTCIDate() != null && currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) <= 0)
				{
					doPatientElectiveList.setTCIDetails(null);
					
					TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();

					if(event != null)
					{
    					if(Status_Reason.HOSPITALCANCELLED.equals(event.getCancellationType()))
    					{
        					if(currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) < 0)
        					{
        						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_BEFORE_6));
        					}
        					else if(currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) == 0)
        					{
        						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
        					}
    					}
    					else if(Status_Reason.PATIENTCANCELLED.equals(event.getCancellationType()))
    					{
    						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_PATIENT_2));
    					}
					}
					else
					{
						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.NOT_APPLICABLE_OR_REMOVED_ETC_9));
					}

					newOutcome.setChangeBy(domainMOS);
					newOutcome.setStatusDateTime(new java.util.Date());
					newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.CANCELLEDBYREMOVALOFELECTIVELISTRECORD));
					newOutcome.setCancellationReason(event != null ? getDomLookup(event.getCancellationReason()) : null);

					doTCIDetails.setCurrentOutcome(newOutcome);
					doTCIDetails.setIsActive(false);

					if(doTCIDetails.getOutcomeHistory() == null)
					{
						doTCIDetails.setOutcomeHistory(new ArrayList());
					}

					doTCIDetails.getOutcomeHistory().add(newOutcome);
					
					if(doPatientElectiveList.getTCIHistory() == null)
						doPatientElectiveList.setTCIHistory(new ArrayList());
					
					doPatientElectiveList.getTCIHistory().add(doTCIDetails);
				}
				
				factory.save(doPatientElectiveList);
			}
		}
	}
	
	
	private void cancelAllFutureAppt(CatsReferral catsReferral, EventLiteVo event) throws StaleObjectException
	{
		try
		{
			if(catsReferral == null)
				return;

			Date currentDate = new Date();
			
			Iterator it = catsReferral.getAppointments().iterator();
			while(it.hasNext())
			{
				Object record = it.next();
				if(record instanceof Booking_Appointment)
				{
					Booking_Appointment appt = (Booking_Appointment) record;

					if(appt != null && getDomLookup(Status_Reason.BOOKED).equals(appt.getApptStatus()) && currentDate.getDate().compareTo(appt.getAppointmentDate()) <= 0)
					{
						cancelAppointment(appt, event);
					}
				}
			}

			if (catsReferral.getConsultationAppt() != null && getDomLookup(Status_Reason.BOOKED).equals(catsReferral.getConsultationAppt().getApptStatus()) && currentDate.getDate().compareTo(catsReferral.getConsultationAppt().getAppointmentDate()) <= 0)
			{
				cancelAppointment(catsReferral.getConsultationAppt(), event);
			}
		}
		catch (DomainInterfaceException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void markAsRemovedFutureAppointments(CatsReferral catsReferral) throws StaleObjectException
	{
		if(catsReferral == null)
			return;
		
		String query = "select fda from FutureAppointmentDetails as fda left join fda.referral as cats left join fda.currentStatus as fdacs left join fdacs.pendingStatus as ps where cats.id = :CatsId and ps.id = :StatusId";
		DomainFactory factory = getDomainFactory();
		
		List futureAppts = factory.find(query, new String[] {"CatsId", "StatusId"}, new Object[] {catsReferral.getId(), FutureAppointmentStatus.OPEN.getID()});
	
		if(futureAppts == null || futureAppts.size() == 0)
			return;
		
		Object mos = getMosUser();
		MemberOfStaffShortVo mosUser = null;
		
		if(mos instanceof MemberOfStaffShortVo)
		{
			mosUser  = (MemberOfStaffShortVo) mos;
		}
		
		for(int i = 0; i<futureAppts.size(); i++)
		{
			if(futureAppts.get(i) == null)
				continue;
			
			FutureAppointmentDetails futureAppt = (FutureAppointmentDetails) futureAppts.get(i);
			
			ims.scheduling.domain.objects.FutureAppointmentStatus status = new ims.scheduling.domain.objects.FutureAppointmentStatus();
			status.setPendingStatus(getDomLookup(FutureAppointmentStatus.REMOVED));
			status.setStatusDateTime(new java.util.Date());
			status.setAuthoringUser(MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, (MemberOfStaffShortVo) mosUser));
			
			futureAppt.setCurrentStatus(status);
			
			if(futureAppt.getStatusHistory() == null)
			{
				futureAppt.setStatusHistory(new ArrayList());
			}
			
			futureAppt.getStatusHistory().add(status);
			
			factory.save(futureAppt);
		}
	}

	private void cancelAppointment(Booking_Appointment doBookAppt, EventLiteVo event) throws StaleObjectException, DomainInterfaceException
	{
		if(doBookAppt == null)
			return;
		
		doBookAppt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));
		doBookAppt.setApptStatusReas(event != null ? getDomLookup(event.getCancellationType()) : null);

		if (doBookAppt.getCurrentStatusRecord() != null)
		{
			Appointment_Status newStatus = new Appointment_Status();

			populateOldFields(doBookAppt, newStatus);

			newStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
			newStatus.setCancellationReason(event != null ? getDomLookup(event.getCancellationReason()) : null);
			newStatus.setStatusReason(event != null ? getDomLookup(event.getCancellationType()) : null);
			newStatus.setStatusChangeDateTime(new java.util.Date());

			if (doBookAppt.getApptStatusHistory() == null)
				doBookAppt.setApptStatusHistory(new HashSet());

			doBookAppt.setCurrentStatusRecord(newStatus);
			doBookAppt.getApptStatusHistory().add(newStatus);
		}

		Booking_AppointmentVo bookingApptVo = Booking_AppointmentVoAssembler.create(doBookAppt);
		if (bookingApptVo.getSessionSlot() != null)
		{
			bookingApptVo.getSessionSlot().setStatus(bookingApptVo.getSession().getAppropiateSessionSlotStatus()); 
		}

		cancelAppt(bookingApptVo, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested when Ends Pathway = True");
	}
	
	private void populateOldFields(Booking_Appointment doBookAppt, Appointment_Status newStatus)
	{
		newStatus.setStatusReason(doBookAppt.getCurrentStatusRecord().getStatusReason());
		newStatus.setApptDate(doBookAppt.getCurrentStatusRecord().getApptDate());
		newStatus.setApptTime(doBookAppt.getCurrentStatusRecord().getApptTime());
		newStatus.setPASClinic(doBookAppt.getCurrentStatusRecord().getPASClinic());
		newStatus.setDoS(doBookAppt.getCurrentStatusRecord().getDoS());
		newStatus.setPriority(doBookAppt.getCurrentStatusRecord().getPriority());
		newStatus.setCancellationReason(doBookAppt.getCurrentStatusRecord().getCancellationReason());
		newStatus.setComment(doBookAppt.getCurrentStatusRecord().getComment());
		newStatus.setRebookSelected(doBookAppt.getCurrentStatusRecord().isRebookSelected());
		newStatus.setUniqueLineRefNo(doBookAppt.getCurrentStatusRecord().getUniqueLineRefNo());
		newStatus.setWasOutputtedToWeeklyReport(doBookAppt.getCurrentStatusRecord().isWasOutputtedToWeeklyReport());
		newStatus.setWasOutputtedToMonthlyReport(doBookAppt.getCurrentStatusRecord().isWasOutputtedToMonthlyReport());
		newStatus.setEarliestOfferedDate(doBookAppt.getCurrentStatusRecord().getEarliestOfferedDate());
		//WDEV-23185
		if (doBookAppt.getSession() != null)
		{
			newStatus.setSession(doBookAppt.getSession());
		} //WDEV-23185
	}

	private boolean appointmentClockIsSameClock(BookingAppointmentOutcomeVo appointmentOutcome, CATSReferral_ClockImpactVo referral)
	{
		if (appointmentOutcome == null || referral == null)
			return false;
		
		if (appointmentOutcome.getPathwayClock() == null || referral.getJourney() == null || referral.getJourney().getCurrentClock() == null)
			return false;

		if (appointmentOutcome.getPathwayClock().equals(referral.getJourney().getCurrentClock()))
			return true;
		
		return false;
	}

	private CATSReferral_ClockImpactVo undoReferralEndOfCare(CATSReferral_ClockImpactVo referral) throws StaleObjectException
	{
		if (referral == null)
			return null;
		
		referral.setEndOfCareDate(null);
		
		// Referral current status is no longer End of Care - leave referral as it is
		if (referral.getCurrentStatus() == null || !ReferralApptStatus.END_OF_CARE.equals(referral.getCurrentStatus().getReferralStatus()))
			return referral;

		
		StringBuffer query = new StringBuffer("SELECT referralStatus FROM CatsReferral AS referral LEFT JOIN referral.statusHistory AS referralStatus ");
		query.append(" WHERE referral.id = :CATS_ID AND referralStatus.id <> :CURRENT_STATUS_ID ORDER BY referralStatus.statusDateTime DESC");
		
		ArrayList<String> paramNames = new ArrayList<String>();				ArrayList<Object> paramValues = new ArrayList<Object>();

		paramNames.add("CATS_ID");											paramValues.add(referral.getID_CatsReferral());
		paramNames.add("CURRENT_STATUS_ID");								paramValues.add(referral.getCurrentStatus().getID_CATSReferralStatus());


		CatsReferralStatusVo previousStatus = CatsReferralStatusVoAssembler.create((CATSReferralStatus) getDomainFactory().findFirst(query.toString(), paramNames, paramValues)); 

		referral.getStatusHistory().remove(referral.getCurrentStatus());
		referral.setCurrentStatus(previousStatus);
		
		CatsReferral domCatsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(getDomainFactory(), referral);
		getDomainFactory().save(domCatsReferral);

		return CATSReferral_ClockImpactVoAssembler.create(domCatsReferral);
	}
	
	private CATSReferral_ClockImpactVo setReferralEndOfCare(CATSReferral_ClockImpactVo referral) throws StaleObjectException
	{
		CatsReferralStatusVo status = new CatsReferralStatusVo();
		status.setReferralStatus(ReferralApptStatus.END_OF_CARE);
		status.setStatusDateTime(new DateTime());
		status.setAuthoringUser((MemberOfStaffRefVo) getMosUser());
		status.setComment(null);
		
		CATSReferralStatus domCatsReferralStatus = CatsReferralStatusVoAssembler.extractCATSReferralStatus(getDomainFactory(), status);
		getDomainFactory().save(domCatsReferralStatus);
		status = CatsReferralStatusVoAssembler.create(domCatsReferralStatus);

		referral.setCurrentStatus(status);
		if (referral.getStatusHistory() == null)
			referral.setStatusHistory(new CATSReferralStatusRefVoCollection());
		referral.getStatusHistory().add(status);
		referral.setEndOfCareDate(new Date());
		
		@SuppressWarnings("rawtypes")
		HashMap domHashMap = new HashMap();
		CatsReferral domReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(getDomainFactory(), referral, domHashMap);
		getDomainFactory().save(domReferral);
		return CATSReferral_ClockImpactVoAssembler.create(domReferral);
	}
	
	
	private PatientEventVo instantiatePatientEventForDidNotAttend(CATSReferral_ClockImpactVo referral, BookingAppointmentOutcomeVo appointmentOutcome) throws StaleObjectException ////http://jira/browse/WDEV-21815
	{
		if (referral == null || referral.getJourney() == null)
			return null;//http://jira/browse/WDEV-21815

		if (appointmentOutcome == null)
			return null; //http://jira/browse/WDEV-21815
//Removed for WDEV-21815		if (!ApptOutcome.PATIENT_DID_NOT_ATTEND.equals(appointmentOutcome.getOutcome()))
//Removed for WDEV-21815			return false;																

		// Get the RTTStatusEventMap for the AppointmentOutcome
		RTTStatusEventMapVo appointmentOutcomeMap = getRTTStatusEventMapByEncounter(appointmentOutcome.getOutcome());

		if (appointmentOutcomeMap != null)
		{
			// If there is an event in the map settings then 
			if (appointmentOutcomeMap.getEvent() != null)
			{
				// Attempt to create and instantiate a Patient Event
				try
				{
					@SuppressWarnings("unused")
					PatientEventVo patientEvent = createAndInstantiatePatientEvent(referral, appointmentOutcomeMap.getEvent(), new DateTime(appointmentOutcome.getAppointmentDate(), appointmentOutcome.getApptStartTime()));
					return patientEvent; //http://jira/browse/WDEV-21815
				}
				// If an exception occurs at this point then log it in the system 
				catch (DomainInterfaceException exception)
				{
					createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
				}
			}
		}

		// Create DNA hard coded event 
		EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.APPOINTMENTDNA.getID());
		if (hardCodedEvent != null)
		{
			try
			{
				@SuppressWarnings("unused")
				PatientEventVo patientEvent = createAndInstantiatePatientEvent(referral, hardCodedEvent, new DateTime(appointmentOutcome.getAppointmentDate(), appointmentOutcome.getApptStartTime()));

				return patientEvent; //http://jira/browse/WDEV-21815
			}
			// If an exception occurs at this point then log it in the system 
			catch (DomainInterfaceException exception)
			{
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "'HL7PathwayIfImpl.instantiatePatientEvent()' threw a DomainInterfaceException" + exception.getMessage());
			}
		}

		return null; //http://jira/browse/WDEV-21815
	}
	
	
	private int getNumberOfClocks(PathwayClockVoCollection clockHistory)
	{
		if (clockHistory == null)
			return 0;

		return clockHistory.size();
	}
	
	
	
	/**
	 * Function will instantiate the RTTStatus but it will not commit it to database
	 * @param appointmentOutcomeMap
	 * @param eventDateTime 
	 * @return
	 */
	private PathwayRTTStatusVo createRTTStatus(RTTStatusEventMapVo appointmentOutcomeMap, DateTime eventDateTime)
	{
		if (appointmentOutcomeMap == null || appointmentOutcomeMap.getTargetRTTStatus() == null)
			return null;
		
		PathwayRTTStatusVo rttStatus = new PathwayRTTStatusVo();
		rttStatus.setRTTStatus(appointmentOutcomeMap.getTargetRTTStatus());
		rttStatus.setStatusDateTime(eventDateTime);
		
		Object mos = getMosUser();
		if (mos instanceof MemberOfStaffLiteVo)
		{
			rttStatus.setStatusBy((MemberOfStaffRefVo) mos);
		}

		return rttStatus;
	}
	
	
	private PathwayRTTStatusVo createRTTStatus(Integer nationalCode, DateTime eventDateTime)
	{
		if (nationalCode == null)
			return null;
		
		PathwayRTTStatusVo rttStatus = new PathwayRTTStatusVo();
		rttStatus.setRTTStatus(getRTTStatusPoint(nationalCode));
		rttStatus.setStatusDateTime(eventDateTime);
		
		Object mos = getMosUser();
		if (mos instanceof MemberOfStaffLiteVo)
		{
			rttStatus.setStatusBy((MemberOfStaffRefVo) mos);
		}

		return rttStatus;
	}
	
	
	
	
	private RTTStatusPointLiteVo getRTTStatusPoint(Integer nationalCode)
	{
		if (nationalCode == null)
			return null;
		
		String query = "SELECT statusPoint FROM RTTStatusPoint AS statusPoint WHERE statusPoint.nationalCode = :NAT_CODE";
		
		return RTTStatusPointLiteVoAssembler.create((RTTStatusPoint) getDomainFactory().findFirst(query, "NAT_CODE", nationalCode));
	}
	
	private RTTStatusEventMapVo getRTTStatusEventMapByEncounter(ApptOutcome outcome)
	{
		if (outcome == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT rttMap ");
		query.append(" FROM RTTStatusEventMap AS rttMap LEFT JOIN rttMap.encounterType AS encType LEFT JOIN rttMap.encounterInstance AS encInstance ");
		query.append(" WHERE encType.id = :EncounterType AND encInstance.id = :EncounterInstance AND rttMap.active = 1");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("EncounterType");		paramValues.add(EventEncounterType.CLINICAL_APPOINTMENT.getID());
		paramNames.add("EncounterInstance");	paramValues.add(outcome.getID());
		
		List<?> listRTTMap = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}

	
	private RTTStatusEventMapVo getRTTStatusEventMapByEvent(EventLiteVo event)
	{
		if (event == null || event.getID_Event() == null)
			return null;
		
		
		String query = "SELECT map FROM RTTStatusEventMap AS map LEFT JOIN map.event AS event WHERE map.active = 1 AND event.id = :EVENT_ID AND (map.isRIE = 0 OR map.isRIE is null)";
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("EVENT_ID");
		paramValues.add(event.getID_Event());
		
		List<?> list = getDomainFactory().find(query, paramNames, paramValues);
		
		if (list != null && list.size() > 0 && list.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) list.get(0));
		}
		
		return null;
	}
	
	
	
	public PathwayRTTClockImpactVo createRTTClockImpactRecord(PathwayClockVo initialClock,
															  PathwayClockVo finalClock, 
															  PathwayRTTStatusVo initialRTTStatus, 
															  PathwayRTTStatusVo finalRTTStatus, 
															  RTTStatusEventMapRefVo eventMap,
															  PatientPathwayJourneyRefVo journey,
															  RTTClockImpactSource source, ApptOutcome outcome)
	{
		PathwayRTTClockImpactVo clockImpact = new PathwayRTTClockImpactVo();
		clockImpact.setInitialClock(initialClock);
		clockImpact.setFinalClock(finalClock);
		clockImpact.setInitialRTTStatus(initialRTTStatus);
		clockImpact.setFinalRTTStatus(finalRTTStatus);
		clockImpact.setOutcomeEvent(eventMap);
		clockImpact.setJourney(journey);
		clockImpact.setSource(source);
		
		clockImpact.setInitialClockState(getClockState(initialClock));
		clockImpact.setFinalClockState(getClockState(finalClock));
		
		clockImpact.setClockStarted(Boolean.FALSE);
		clockImpact.setClockStopped(Boolean.FALSE);
		
		clockImpact.setOutcomeDescription(outcome.getText());
		
		
		// Case 1 - If there was no clock initially and one clock was created
		if (initialClock == null && finalClock != null)
		{
			// New clock has a start date - mark the ClockImpact
			if (finalClock.getStartDate() != null)
				clockImpact.setClockStarted(Boolean.TRUE);
			
			if (finalClock.getStopDate() != null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}
		
		
		// Case 2 - If there was a clock initially and there is no clock now
		if (initialClock != null && finalClock == null)
		{
			if (initialClock.getStopDate() == null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}
		
		
		// Case 3 - If there was an initial clock and a clock is present now
		if (initialClock != null && finalClock != null)
		{
			// Case 3.1 - Initial and current clock are the same one
			if (initialClock.getID_PathwayClock() == finalClock.getID_PathwayClock())
			{
				if (initialClock.getStopDate() == null && finalClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
				
				if (initialClock.getStopDate() != null && finalClock.getStopDate() == null)
					clockImpact.setClockStarted(Boolean.TRUE);
				
				if (initialClock.getStartDate() == null && finalClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
			}
			
			// Case 3.2 - Initial and current clock are not the same one
			if (initialClock.getID_PathwayClock() != finalClock.getID_PathwayClock())
			{
				if (initialClock.getStopDate() == null)
					clockImpact.setClockStopped(Boolean.TRUE);
				
				if (finalClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
				
				if (finalClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
			}
		}
		
		return clockImpact;
	}
	
	
	private RTTClockState getClockState(PathwayClockVo clock)
	{
		if (clock == null)
			return RTTClockState.NOT_PRESENT;
		
		if (clock.getStopDate() != null)
			return RTTClockState.STOPPED;
		
		return RTTClockState.STARTED;
	}
	
	private PatientEventVo createAndInstantiatePatientEvent(CATSReferral_ClockImpactVo cats, EventLiteVo eventLiteVo, DateTime eventDateTime) throws DomainInterfaceException, StaleObjectException
	{
		
		
		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient(new PatientRefVo(cats.getPatient().getID_Patient(), cats.getPatient().getVersion_Patient()));
		patEvent.setEvent(eventLiteVo);
		patEvent.setEventDateTime(eventDateTime);
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(cats.getJourney());
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		return impl.instantiatePatientEvent(patEvent, null, cats.getRTTClockImpact());
	}
	
	public EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[] {"eventID", "statusID"},new Object[] {event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID()});
		
		if (list == null || list.size() == 0)
			return null;
		
		return EventLiteVoAssembler.create((Event)list.get(0));
	}
	

	
	//wdev-19933, wdev-19930
	public CatsReferralForRequestServiceVo getChildCatsReferralForTransferOfCare(CatsReferralRefVo catsRef)
	{
		if( catsRef == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT c1_1 FROM ");
		query.append(" CatsReferral as p1_1 left join p1_1.linkedReferrals as l1_1 left join l1_1.referral as c1_1  left join l1_1.referralRelationType as l2_1 ");
		query.append(" WHERE( (c1_1.isRIE = 0 OR c1_1.isRIE is null) and l2_1.id = :ActionType and p1_1.id = :parentCatsReferralID) ");
				
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("parentCatsReferralID");		paramValues.add(catsRef.getID_CatsReferral());
		paramNames.add("ActionType");				paramValues.add(ReferralRelationType.TRANSFER_OF_CARE.getID());
		
		CatsReferral catsReferral = (CatsReferral) getDomainFactory().findFirst(query.toString(), paramNames, paramValues);
		if( catsReferral != null)
		{
			
				return CatsReferralForRequestServiceVoAssembler.create(catsReferral);
			
		}

		
		return null;
	}
	
	
	//wdev-19930, wdev-19933
	public void saveChildCatsReferral(CatsReferralForRequestServiceVo record, CatsReferralRefVo parentCatsRef, ReferralAppointmentOutcomeAction action) throws DomainInterfaceException, StaleObjectException
	{
		if( record == null || action == null )
			throw new DomainRuntimeException("Invalid referral to save");
		
		if(action.equals(ReferralAppointmentOutcomeAction.TRANSFER_OF_CARE))
		{
			AppointmentOutcomeDialog impl =  (AppointmentOutcomeDialog)getDomainImpl(AppointmentOutcomeDialogImpl.class);
			impl.saveChildCatsReferralForTransferOfCare(record, parentCatsRef, null);
		}
	}

	
	//wdev-19930,wdev-19933
	public CatsReferralMasterVo getParentCatsReferrall(CatsReferralRefVo catsRef)
	{
		if( catsRef == null )
			return null;
			
		CatsReferral doCatsReferral = (CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, catsRef.getID_CatsReferral());
		
		return CatsReferralMasterVoAssembler.create(doCatsReferral);
	}
	
	/**
	* WDEV-20119
    * saveConsultantUpgrade
    * This method is mark the patient journey as a cancer pathway, set cancer pathway date and bring the 62day target into scope as long as source of referral is GP
    */
	public CatsReferralRefVo saveConsultantUpgrade(CatsReferralRefVo referral, Date upgradeDate) throws StaleObjectException 
	{
		if (referral == null || upgradeDate == null)
			return referral;
	
		DomainFactory factory = getDomainFactory();
		
		CatsReferral domReferral = (CatsReferral)factory.getDomainObject(CatsReferral.class, referral.getID_CatsReferral());
		if (domReferral != null && domReferral.getJourney() != null)
		{
				
			PatientPathwayJourney domJourney = (PatientPathwayJourney)factory.getDomainObject(PatientPathwayJourney.class, domReferral.getJourney().getId());
			domJourney.setIsCancerPathway(true);
			domJourney.setCancerPathwayDate(upgradeDate.getDate());
			factory.save(domJourney);
		}
		
			// Urgency also needs to be set to Consultant Upgrade
		domReferral.setUrgency(getDomLookup(ReferralUrgency.CONSULTANT_UPGRADE));

		// We now need to  check the referral type for the associated CatsReferral.  If it is GP, then we want the 62 day target in scope
		ReferralLetterDetails domRefLetter = domReferral.getReferralDetails();
		if (domRefLetter != null && domRefLetter.getReferrerType() != null && domRefLetter.getReferrerType().getId() == SourceOfReferral.GP.getId())
		{
			try 
			{
				// Find the Target 62Day
				HL7PathwayIf hl7Impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				TargetRefVo target = hl7Impl.getTargetByTaxonomyMap(TaxonomyType.PAS, "62D");
				hl7Impl.bringTargetIntoScopeWithoutEvent(target, new PatientPathwayJourneyRefVo(domReferral.getJourney().getId(), domReferral.getJourney().getVersion()), upgradeDate);
			}
			catch (DomainInterfaceException e) 
			{
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "saveConsultantUpgrade - " + e.getMessage());
			}
		}
	    
		return new CatsReferralRefVo(domReferral.getId(), domReferral.getVersion());
	}

	public Boolean hasLocationDiagnosicContracts(LocationRefVo location)
	{
		ReferralStatusList impl = (ReferralStatusList)getDomainImpl(ReferralStatusListImpl.class);
		return impl.hasLocationDiagnosicContracts(location);
	}

	//WDEV-21973
	public void createCaseNoteFolderIfNone(PatientRefVo patient)
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		impl.createCaseNoteFolderIfNone(patient);
		
	}

	
	private Date getTargetClockEnd(Date date, CATSReferral_ClockImpactVo referral)
	{
		Date startDate = new ims.framework.utils.Date(date);

		int daysToRttBreachDate = 0;

		if (referral != null && referral.getReferralDetails() != null)
		{
			ContractServiceLocationsConfigVo contrServiceLocationConf = getContractServiceLocConf(referral.getContract(), referral.getReferralDetails().getService());

			if (contrServiceLocationConf != null && contrServiceLocationConf.getDaysToRTTBreachDate() != null)
			{
				daysToRttBreachDate = contrServiceLocationConf.getDaysToRTTBreachDate();
			}
			else if (referral.getContract() != null)
			{
				daysToRttBreachDate = referral.getContract().getDaysToRTTBreachDate();
			}
		}
		
		return startDate.addDay(daysToRttBreachDate);
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		return impl.cancelAppt(appt, requestType, requestSource);
	}
}
