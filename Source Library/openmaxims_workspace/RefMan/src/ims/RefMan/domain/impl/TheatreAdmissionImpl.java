//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.70 build 3454.29123)
// Copyright (C) 1995-2009 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.HcpAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.TheatreList;
import ims.RefMan.domain.base.impl.BaseTheatreAdmissionDialogImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.vo.CatsReferralWizardVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.domain.CatsReferralWizardVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.vo.AdmissionDetailRefVo;
import ims.core.admin.pas.vo.AdmissionDetailRefVoCollection;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.domain.ADT;
import ims.core.domain.impl.ADTImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.place.domain.objects.Location;
import ims.core.vo.CareContextLiteVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.InpatientEpisodeVo;
import ims.core.vo.LocShortMappingsVo;
import ims.core.vo.LocShortVo;
import ims.core.vo.MedicLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.domain.CareContextLiteVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.LocShortMappingsVoAssembler;
import ims.core.vo.domain.LocShortVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.PasEventVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.Specialty;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.lookups.LookupInstance;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.DateTime;
import ims.icp.vo.PatientICPFullVo;
import ims.icp.vo.domain.PatientICPFullVoAssembler;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PathwaysRTTClockImpact;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.RTTClockImpactSource;
import ims.pathways.vo.lookups.RTTClockState;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Appointment_StatusVo;
import ims.scheduling.vo.BookingAppointmentTheatreVo;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

public class TheatreAdmissionImpl extends BaseTheatreAdmissionDialogImpl
{

	private static final long serialVersionUID = 1L;
	private static final int START_OF_FIRST_DEFINITIVE_TREATMENT = 30;
	private static final int ACTIVITY_REFERRAL_TREATMENT_PERIOD = 20;

	public ims.core.vo.LocShortMappingsVoCollection listActiveWardsForHospital(ims.core.resource.place.vo.LocationRefVo hospital)
	{
		OrganisationAndLocation implLoc = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return implLoc.listActiveWardsForHospital(hospital);
	}

	public CareContextShortVo admitPatient(PatientShort patVo, InpatientEpisodeVo episVo, Booking_AppointmentRefVo bookingApptVoRef, CatsReferralWizardVo voCats, Boolean readmitted, PatientElectiveListBedAdmissionVo patientElectiveList, PatientElectiveListBedAdmissionVoCollection patientElectiveListToBeCancelled) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		if (bookingApptVoRef == null || bookingApptVoRef.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("bookingApptVoRef is null or id not provide for method admitPatient");

		//WDEV-18592
		DomainFactory factory = getDomainFactory();
		
		ElectiveListReason electiveListReason = null;
		
		// Get PatientElectiveList domain object
		if (patientElectiveList != null)
		{
			electiveListReason = patientElectiveList.getElectiveListReason();
			
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap();
			PatientElectiveList domPatientElectiveList = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(factory, patientElectiveList, domMap);
			factory.save(domPatientElectiveList);
			patientElectiveList = PatientElectiveListBedAdmissionVoAssembler.create(domPatientElectiveList);

			if (patientElectiveListToBeCancelled != null)
			{
				for (PatientElectiveListBedAdmissionVo patientElectiveListToCancel : patientElectiveListToBeCancelled)
				{
					PatientElectiveList domPatientElectiveListToCancel = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(factory, patientElectiveListToCancel, domMap);
					factory.save(domPatientElectiveListToCancel);
				}
			}
		}
		
		
		ADT implLoc = (ADT)getDomainImpl(ADTImpl.class);
		InpatientEpisodeVo voIP = Boolean.TRUE.equals(readmitted) ? implLoc.readmitPatient(patVo, episVo) : implLoc.admitPatient(patVo, episVo, null);//	WDEV-13307
		AdmissionDetail admissionDetails = (AdmissionDetail) factory.getDomainObject(AdmissionDetail.class, voIP.getAdmissionDetails().getID_AdmissionDetail());
		
		if (patientElectiveList != null)
		{
			// Need to refresh the Patient Elective List as the ADT Impl admit function will update the patient record
			patientElectiveList = PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
			if (patientElectiveList.getAdmissions() == null)
				patientElectiveList.setAdmissions(new AdmissionDetailRefVoCollection());
			
			patientElectiveList.getAdmissions().add(new AdmissionDetailRefVo(admissionDetails.getId(), admissionDetails.getVersion()));
			
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap();
			PatientElectiveList domPatientElectiveList = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(factory, patientElectiveList, domMap);
			factory.save(domPatientElectiveList);
			patientElectiveList = PatientElectiveListBedAdmissionVoAssembler.create(domPatientElectiveList);
		}
		
		if ( !voIP.getAdmissionDateTime().equals(episVo.getAdmissionDateTime()))
		{
			throw new DomainInterfaceException("Patient is already an inpatient. Cannot Admit.");
		}

		//wdev-8305
		CatsReferral domCats = (CatsReferral) factory.getDomainObject(CatsReferral.class, voCats.getID_CatsReferral());
		if (domCats != null)
		{
			domCats.setRequiresDischargeRep(null);
			domCats.setDischargeDate(null);
			
			// WDEV-19126
			// Get AdmissionDetail record and associated with the referral 
			List pasEvtLst = AdmissionDetail.listAdmissionDetailByPasEvent(factory, PasEventVoAssembler.extractPASEvent(factory, voIP.getPasEvent()));
			if (pasEvtLst != null)
			{
				if (domCats.getAdmissions() == null)
					domCats.setAdmissions(pasEvtLst);
				else
					domCats.getAdmissions().addAll(pasEvtLst);
			}
		}
		
		
		
		//WDEV-18316
		if (Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue()) && Boolean.TRUE.equals(domCats.isRTTClockImpact()))
		{
			// Place holders for clock Impact variables
			PathwaysRTTClockImpact clockImpact = null;
			PathwayClock initialClock = null;
			PathwayRTTStatus initialRTTStatus = null;
			boolean wasClockStarted = false; // since we can't create a copy of the initial clock and it's possible it will be changed
			boolean wasClockStopped = false; // retain in these 2 boolean variables the state of the initial clock
			LookupInstance initialClockState = getDomLookup(RTTClockState.NOT_PRESENT);

			if (domCats.getJourney() != null)
			{
				initialClock = domCats.getJourney().getCurrentClock();
				wasClockStarted = initialClock != null && initialClock.getStartDate() != null;
				wasClockStopped = initialClock != null && initialClock.getStopDate() != null;
				initialClockState = getClockState(initialClock);
			}
			initialRTTStatus = domCats.getCurrentRTTStatus();

			// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
			// When a patient is admitted, always use admission date time
			Date eventDateTime = admissionDetails.getAdmissionDateTime();
			PathwayRTTStatus rttStatus = createPathwayRTTStatus(domCats, electiveListReason, eventDateTime);
			domCats.setCurrentRTTStatus(rttStatus);

			if (rttStatus != null)
			{
				RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus.getRTTStatus());

				if (rttMap != null && rttMap.getEvent() != null)
				{
					PatientEventVo patEvent = new PatientEventVo();
					patEvent.setPatient(PatientListVoAssembler.create(domCats.getPatient()));
					patEvent.setEvent(rttMap.getEvent());
					patEvent.setEventDateTime(new DateTime());
					patEvent.setEventStatus(EventStatus.ACTIVE);
					patEvent.setJourney(PatientJourneyVoAssembler.create(domCats.getJourney()));

					HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
					PatientEventVo patientEvent = impl.instantiatePatientEvent(patEvent);
				}
			}
			
			// If the event didn't stop the clock - then stop the clock now
			if (domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null && domCats.getJourney().getCurrentClock().getStopDate() == null)
			{
				domCats.getJourney().getCurrentClock().setStopDate(new Date());
			}
			
			if (domCats.getJourney() != null)
			{
				LookupInstance finalClockState = getClockState(domCats.getJourney().getCurrentClock());
				clockImpact = createRTTClockImpactRecord(initialClock, domCats.getJourney().getCurrentClock(), initialRTTStatus, domCats.getCurrentRTTStatus(), null, domCats.getJourney(), RTTClockImpactSource.ADMISSION, wasClockStarted, wasClockStopped, initialClockState, finalClockState);
			}
			/*else //WDEV-20086 property value exception if journey is null 
				clockImpact = createRTTClockImpactRecord(initialClock, null, initialRTTStatus, domCats.getCurrentRTTStatus(), rttMap, domCats.getJourney(), RTTClockImpactSource.ADMISSION, wasClockStarted, wasClockStopped);*/
			
			if (clockImpact != null)
			{
				factory.save(clockImpact);
				
				if (domCats.getRTTClockImpacts() == null)
				{
					domCats.setRTTClockImpacts(new ArrayList());
				}
				
				admissionDetails.setAdmissionRTTOutcome(clockImpact);
				domCats.getRTTClockImpacts().add(clockImpact);
				
				factory.save(admissionDetails);
			}			
		}
		
		factory.save(domCats);

		//Update the Status of the Appointment
		BookingAppointmentTheatreVo vo = BookingAppointmentTheatreVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(bookingApptVoRef));
		if (vo != null)
		{
			vo.getApptStatusHistory().add(vo.getCurrentStatusRecord());

			Appointment_StatusVo voApptStat = new Appointment_StatusVo();
			voApptStat.setStatus(Status_Reason.ADMITTED);
			//voApptStat.setStatusChangeDateTime(new DateTime());//WDEV-12760
			voApptStat.setStatusChangeDateTime(episVo.getAdmissionDateTime());//WDEV-12760
			vo.setCurrentStatusRecord(voApptStat);
			vo.setApptStatus(Status_Reason.ADMITTED);
			
			vo.setPASEvent(voIP.getPasEvent());//wdev-18155
			
			Booking_Appointment doAppt = BookingAppointmentTheatreVoAssembler.extractBooking_Appointment(factory, vo);
			factory.save(doAppt);
		}
		
		// Update the CareContext with PASEvent (WDEV-8364)
		CareContextLiteVo careContext = CareContextLiteVoAssembler.create((CareContext) getDomainFactory().getDomainObject(CareContext.class, voCats.getCareContext().getID_CareContext()));
		careContext.setPasEvent(voIP.getPasEvent());
		
		CareContext domCareContext = CareContextLiteVoAssembler.extractCareContext(factory, careContext);
		factory.save(domCareContext);
		
		//Update the ICP with PASEVent
		List<?> picps = getDomainFactory().find("select picp from PatientICP picp left join picp.appointments as appts where appts.id = '" + bookingApptVoRef.getID_Booking_Appointment() + "' and picp.completedDateTime = null");
		if (picps != null && picps.size() == 1)
		{
			PatientICPFullVo voPatientICP = PatientICPFullVoAssembler.create((PatientICP) picps.get(0));
			if (voPatientICP != null)
			{
				voPatientICP.setPasEvent(voIP.getPasEvent());

				PatientICP doICP = PatientICPFullVoAssembler.extractPatientICP(factory, voPatientICP);

				factory.save(doICP);
			}
		}
		
		return CareContextShortVoAssembler.create(domCareContext);
	}

	private LookupInstance getClockState(PathwayClock clock)
	{
		if (clock == null)
			return getDomLookup(RTTClockState.NOT_PRESENT);
		
		if (clock.getStopDate() != null)
			return getDomLookup(RTTClockState.STOPPED);
		
		return getDomLookup(RTTClockState.STARTED);
	}

	public PathwaysRTTClockImpact createRTTClockImpactRecord(PathwayClock initialClock, PathwayClock pathwayClock, PathwayRTTStatus initialRTTStatus, PathwayRTTStatus pathwayRTTStatus, RTTStatusEventMapRefVo eventMapRefVo, PatientPathwayJourney patientPathwayJourney, RTTClockImpactSource source, boolean wasClockStarted, boolean wasClockStopped, LookupInstance initialClockState, LookupInstance finalClockState)
	{
		PathwaysRTTClockImpact clockImpact = new PathwaysRTTClockImpact();
		clockImpact.setInitialClock(initialClock);
		clockImpact.setFinalClock(pathwayClock);
		clockImpact.setInitialRTTStatus(initialRTTStatus);
		clockImpact.setFinalRTTStatus(pathwayRTTStatus);
		
		clockImpact.setInitialClockState(initialClockState);
		clockImpact.setFinalClockState(finalClockState);

		if (eventMapRefVo != null && eventMapRefVo.getID_RTTStatusEventMap() != null)
		{
			clockImpact.setOutcomeEvent((RTTStatusEventMap) getDomainFactory().getDomainObject(RTTStatusEventMap.class, eventMapRefVo.getID_RTTStatusEventMap()));
		}
		else
		{
			clockImpact.setOutcomeEvent(null);
		}

		clockImpact.setJourney(patientPathwayJourney);
		clockImpact.setSource(getDomLookup(source));

		clockImpact.setClockStarted(Boolean.FALSE);
		clockImpact.setClockStopped(Boolean.FALSE);

		// Case 1 - If there was no clock initially and one clock was created
		if (initialClock == null && pathwayClock != null)
		{
			// New clock has a start date - mark the ClockImpact
			if (pathwayClock.getStartDate() != null)
				clockImpact.setClockStarted(Boolean.TRUE);

			if (pathwayClock.getStopDate() != null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}

		// Case 2 - If there was a clock initially and there is no clock now
		if (initialClock != null && pathwayClock == null)
		{
			if (wasClockStopped == false)
				clockImpact.setClockStopped(Boolean.TRUE);
		}

		// Case 3 - If there was an initial clock and a clock is present now
		if (initialClock != null && pathwayClock != null)
		{
			// Case 3.1 - Initial and current clock are the same one
			if (initialClock.getId() == pathwayClock.getId())
			{
				if (!wasClockStopped && pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (wasClockStopped && pathwayClock.getStopDate() == null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (!wasClockStarted && pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
			}

			// Case 3.2 - Initial and current clock are not the same one
			if (initialClock.getId() != pathwayClock.getId())
			{
				if (!wasClockStopped)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
			}
		}

		return clockImpact;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;
		
		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1 and rttMap.encounterType is null";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}

	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral domCats, ElectiveListReason electiveListReason, Date eventDateTime)
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if (domCats == null || electiveListReason == null)
			return null;
		
		RTTStatusPoint rttStatusPoint = null;
		
		if (ElectiveListReason.TREATMENT.equals(electiveListReason) || ElectiveListReason.MATERNITY.equals(electiveListReason))
		{
			rttStatusPoint = getRTTStatusPoint(START_OF_FIRST_DEFINITIVE_TREATMENT);
		}
		else if (ElectiveListReason.DIAGNOSTIC.equals(electiveListReason))
		{
			rttStatusPoint = getRTTStatusPoint(ACTIVITY_REFERRAL_TREATMENT_PERIOD);
		}
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(eventDateTime);
		if(rttStatusPoint!=null)
		{
			pathwayRTTStatus.setSetting("I");//WDEV-23292
		}
		if(domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null)
    	{
			domCats.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(domCats.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			domCats.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		domCats.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
    	}
		
		return pathwayRTTStatus;
	}

	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}

	public MedicLiteVoCollection listActiveMedics(String szName)
	{
		HcpAdmin implHCP = (HcpAdmin)getDomainImpl(HcpAdminImpl.class);
		return implHCP.listActiveMedics(szName);
	}

	public CatsReferralWizardVo getCatsReferral(Booking_AppointmentRefVo voBookingRefVo)
	{
		if(voBookingRefVo == null)
			throw new CodingRuntimeException("voBookingRefVo is null");
		
		DomainFactory factory = getDomainFactory();
		List<?> lstCatsRef = factory.find("from CatsReferral catsRef where catsRef.appointments.id = '" + voBookingRefVo.getID_Booking_Appointment() + "'");
		if(lstCatsRef != null && lstCatsRef.size() == 1)
		{
			CatsReferral doCatsRef = (CatsReferral) lstCatsRef.get(0);
			return CatsReferralWizardVoAssembler.create(doCatsRef);
		}
		return null;
	}

	
	public CatsReferralWizardVo getCatsReferralWizardVoForCareContext(CareContextRefVo voCarecontext) 
	{
		if(voCarecontext == null || voCarecontext.getID_CareContext() == null)
			throw new CodingRuntimeException("CareContextRefVo is null or id not provide for CareContextRefVo");
		
		DomainFactory factory = getDomainFactory();
		List<?> catsRef = factory.find("select catsRef from CatsReferral as catsRef where catsRef.careContext.id = '" + voCarecontext.getID_CareContext() + "')");
		if(catsRef != null && catsRef.size() > 0)
		{
			 CatsReferral val = (CatsReferral) catsRef.get(0);
			if(val != null)
			{
				return CatsReferralWizardVoAssembler.create(val);
			}
		}	
		return null;
	}

	public Booking_AppointmentVo getBookingAppt(Booking_AppointmentRefVo bookingApptRefVo) 
	{
		TheatreList impl = (TheatreList)getDomainImpl(TheatreListImpl.class);
		return impl.getBookingAppt(bookingApptRefVo);
	}

	public Boolean isNotACurrentInpatient(PatientRefVo voPatRef) 
	{
		TheatreList impl = (TheatreList)getDomainImpl(TheatreListImpl.class);
		return impl.isNotACurrentInpatient(voPatRef);
	}

	// WDEV-12293 
	public Specialty getReferralSpecialty(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || !appointment.getID_Booking_AppointmentIsNotNull())
			return null;
		
		String query = "select service from CatsReferral as referral left join referral.referralDetails as details left join details.service as service left join referral.appointments as appt where appt.id = :ID";
		
		ArrayList<String> paramNames = new ArrayList<String>(); paramNames.add("ID");
		ArrayList<Object> paramValues = new ArrayList<Object>(); paramValues.add(appointment.getID_Booking_Appointment());
		
		ServiceShortVo service = ServiceShortVoAssembler.create((Service) getDomainFactory().findFirst(query, paramNames, paramValues));
		
		return service.getSpecialty();
	}

	//WDEV-18007
	public LocShortVo getCurrentHospital(ILocation currentLocation)
	{
		if(currentLocation == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, currentLocation.getID()));
		
		if(currentHospital instanceof Location)
			return LocShortVoAssembler.create((Location) currentHospital);
		
		return null;
	}

	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public LocShortMappingsVo getBookingApptSessionLocation(Integer apptId) 
	{
		if (apptId == null)
			return null;
		DomainFactory factory = getDomainFactory();		
		 
		ArrayList<String> marques = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		marques.add("id");
		values.add(apptId);	
		marques.add("locTypeWardID");
		values.add(LocationType.WARD.getID());
		
		String query = " select sessionLocation from Booking_Appointment as apptDetails left join apptDetails.session as sessionDetails left join sessionDetails.schLocation as sessionLocation left join sessionLocation.type as locationType where ( apptDetails.id = :id and sessionLocation.isActive = 1 and locationType.id = :locTypeWardID ) ";
		List<?> sessionLoc = factory.find(query, marques, values);
		
		if(sessionLoc != null && sessionLoc.size() > 0 && sessionLoc.get(0) instanceof Location)
			return LocShortMappingsVoAssembler.create((Location) sessionLoc.get(0));
		
		return null;
	}


	public PatientElectiveListBedAdmissionVo getPatientElectiveListForAppointment(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		String query = "SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID";
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}


	public PatientElectiveListBedAdmissionVoCollection getDifferentPatientElectiveListForService(PatientRefVo patient, PatientElectiveListRefVo patientElectiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		if (service == null || service.getID_Service() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS serv LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND serv.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(patientElectiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public Boolean hasPatientElectiveListsToBeCancelled(PatientRefVo patient, PatientElectiveListRefVo patientElectiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (service == null || service.getID_Service() == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS serv LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND serv.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(patientElectiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}
}
