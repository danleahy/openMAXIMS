//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.80 build 5007.25751)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.ReferralCoding;
import ims.RefMan.domain.base.impl.BaseInpatientClinicalCodingWorklistImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.AdmissionDetailForCoderWorklistVo;
import ims.RefMan.vo.AdmissionDetailForCoderWorklistVoCollection;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.InpatientClinicalCodingWorklistSearchCriteriaVo;
import ims.RefMan.vo.domain.AdmissionDetailForCoderWorklistVoAssembler;
import ims.RefMan.vo.domain.DischargedEpisodeForClinicalCodingWorklistVoAssembler;
import ims.clinical.vo.lookups.CodingCommentStatus;
import ims.clinical.vo.lookups.HistologyStatus;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.CodingStatus;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PatIdType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.vo.LookupInstanceCollection;

import java.util.ArrayList;
import java.util.List;

public class InpatientClinicalCodingWorklistImpl extends BaseInpatientClinicalCodingWorklistImpl
{
	private static final long serialVersionUID = 1L;

	public ims.RefMan.vo.AdmissionDetailForCoderWorklistVoCollection listEpisodes(ims.RefMan.vo.InpatientClinicalCodingWorklistSearchCriteriaVo criteria) //WDEV-19783
	{
		if(criteria == null || new InpatientClinicalCodingWorklistSearchCriteriaVo().equals(criteria))
			throw new DomainRuntimeException("At least one search criteria must be provided");
		
		DomainFactory factory = getDomainFactory();
		
		StringBuilder hqlJoins = new StringBuilder();
		StringBuilder hqlConditions = new StringBuilder();	
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
			
		String and = " and ";
		
		hqlJoins.append("select dischargeEpis from DischargedEpisode as dischargeEpis left join dischargeEpis.admissionDetail as admissionDet left join admissionDet.pasEvent as pasEvent ");
		hqlConditions.append(" where (dischargeEpis.isRIE is null or dischargeEpis.isRIE = 0) and (admissionDet.isRIE is null or admissionDet.isRIE = 0) ");	
					
		if (criteria.getSpecialty() != null)
		{
			hqlJoins.append(" left join pasEvent.specialty as spec ");
			hqlConditions.append(and);
			hqlConditions.append(" spec.id = :SpecialtyId ");
			paramNames.add("SpecialtyId");
			paramValues.add(criteria.getSpecialty().getID());
			and = " and ";
		}
		
		if (criteria.getDischargeWards() != null && criteria.getDischargeWards().size() > 0)
		{
			hqlJoins.append(" left join pasEvent.location as loc ");
			hqlConditions.append(and);
			hqlConditions.append(" loc.id in (" + getWardsIds(criteria.getDischargeWards()) + ")");
			and = " and ";
		}
		else if(criteria.getHospital() != null && (criteria.getDischargeWards() == null || criteria.getDischargeWards().size() == 0)) //WDEV-20395
		{
			hqlJoins.append(" left join pasEvent.location as loc ");
			LocationLiteVoCollection wards = listWards(criteria.getHospital(), null);
			if (wards.size() > 0)
			{	
				hqlConditions.append(and);
				hqlConditions.append(" (pasEvent.location.id in (" + getWardIds(wards) + ") " );
				hqlConditions.append(" OR ");
			}
			
			hqlConditions.append((wards.size() > 0 ? "" : and) + " pasEvent.location.parentLocation.id = :Hospital" + (wards.size() > 0 ? ")" : ""));
			paramNames.add("Hospital");
			paramValues.add(criteria.getHospital().getID_Location());
			and = " and ";
		}
		
		if (criteria.getUser() != null)
		{
			hqlJoins.append(" ,ReferralCoding as refCoding left join refCoding.pasEvent as refCodingPasEvent left join refCoding.authoringMOS as refCodingMOS ");
			hqlConditions.append(and);
			hqlConditions.append(" pasEvent.id = refCodingPasEvent.id and refCodingMOS.id = :AuthoringMOSId ");
			paramNames.add("AuthoringMOSId");
			paramValues.add(criteria.getUser().getIMosId());
			and = " and ";
		}
		
		if (criteria.getDateFrom() != null)
		{
			hqlConditions.append(and);
			hqlConditions.append(" dischargeEpis.dischargeDateTime >= :FromDate ");
			paramNames.add("FromDate");
			paramValues.add(new DateTime(criteria.getDateFrom(), new Time("00:00:00")).getJavaDate());
			and = " and ";
		}
		
		if (criteria.getDateTo() != null)
		{
			hqlConditions.append(and);
			hqlConditions.append(" dischargeEpis.dischargeDateTime <= :ToDate ");
			paramNames.add("ToDate");
			paramValues.add(new DateTime(criteria.getDateTo(), new Time("23:59:59")).getJavaDate());
			and = " and ";
		}
		
		if(searchAfterUncoded(criteria.getCodingStatuses()))
		{
			hqlConditions.append(and);
			hqlConditions.append(" ((admissionDet.codingStatus.id = :Uncoded or admissionDet.codingStatus is null) and admissionDet.histologyStatus is null) ");
			paramNames.add("Uncoded");
			paramValues.add(CodingStatus.UNCODED.getID());
			and = " and ";
		}
		else if (criteria.getCodingStatusesIsNotNull() || Boolean.TRUE.equals(criteria.getAwaitingHistology()))
		{
			hqlConditions.append(and);
			hqlConditions.append("(");
			
			String or = "";
			
			if(searchAfterInProgress(criteria.getCodingStatuses()))
			{
				hqlConditions.append(" (admissionDet.codingStatus.id = :InProgress or ((admissionDet.codingStatus.id = :Uncoded or admissionDet.codingStatus is null) and admissionDet.histologyStatus.id is :ReceivedHistology)) ");
				paramNames.add("InProgress");
				paramValues.add(CodingStatus.INPROGRESS.getID());
				paramNames.add("Uncoded");
				paramValues.add(CodingStatus.UNCODED.getID());
				paramNames.add("ReceivedHistology");
				paramValues.add(HistologyStatus.RECEIVED.getID());
				or = " or ";
			}
			String codingIds = getCodingStatusesLookupIDs(criteria.getCodingStatuses());
			if(criteria.getCodingStatusesIsNotNull() && codingIds != null && codingIds.length() > 0)
			{
				hqlConditions.append(or);
				hqlConditions.append(" admissionDet.codingStatus.id in (" + codingIds + ")");
				or = " or ";
			}
				
			if(Boolean.TRUE.equals(criteria.getAwaitingHistology()))
			{
				hqlJoins.append(" left join admissionDet.histologyStatus as histStatus");
				hqlConditions.append(or);
				hqlConditions.append(" histStatus.id = :AwaitingHistology ");
				paramNames.add("AwaitingHistology");
				paramValues.add(HistologyStatus.AWAITING.getID());
			}
			
			hqlConditions.append(")");	
			and = " and ";
		}
		if (criteria.getCommentsIsNotNull() && criteria.getComments().size() > 0)
		{
			if(Boolean.TRUE.equals(criteria.getAllComments()))
			{
				hqlJoins.append(" left join admissionDet.codingComments as comms left join comms.commentStatus as commsStatus ");
				hqlConditions.append(and);
				hqlConditions.append(" comms.structuredComment.id in (" + getLookupIDs(criteria.getComments()) +  ") and commsStatus.id <> :Superceded " );
				paramNames.add("Superceded");
				paramValues.add(CodingCommentStatus.SUPERCEDED.getID());
			
				and = " and ";
			}
			else if(Boolean.TRUE.equals(criteria.getLastComment()))
			{
				hqlJoins.append(" left join admissionDet.lastComment as lastcomms ");
				hqlConditions.append(and);
				hqlConditions.append(" lastcomms.structuredComment.id in (" + getLookupIDs(criteria.getComments()) +  ") " );
			
				and = " and ";
			}
		}
		
		if(criteria.getMRNNumbers() != null || criteria.getCaseNoteLocation() != null)
		{
			hqlJoins.append(" left join pasEvent.patient as pat ");
		}
		
		if(criteria.getMRNNumbers() != null )
		{
			String formatedMRNNumbers = getMRNNumbers(criteria.getMRNNumbers());
			
			if(formatedMRNNumbers != null && formatedMRNNumbers.length() > 0)
			{
				hqlJoins.append(" left join pat.identifiers as ident left join ident.type as identType ");
				hqlConditions.append(and);
				hqlConditions.append(" identType.id = :MRNType and ident.value in (" + formatedMRNNumbers + ")");
				paramNames.add("MRNType");
				paramValues.add(PatIdType.MRNNUM.getID());
				and = " and ";
			}
		}
		
		if(criteria.getCaseNoteLocation() != null)
		{
			hqlJoins.append(" left join pat.currentCaseNoteLocation as pcnLoc ");
			hqlConditions.append(and);
			hqlConditions.append(" pcnLoc.id in (" + getWardsIds(criteria.getCaseNoteLocation()) + ")");
			and = " and ";
		}
					
		hqlConditions.append(" order by dischargeEpis.dischargeDateTime asc ");

		List<?> list = factory.find(hqlJoins.append(hqlConditions.toString()).toString(), paramNames, paramValues, ConfigFlag.DOM.CODING_RECORDS_RETURNED_MAX_SIZE.getValue());
		
		if(list == null)
			return null;
		
		AdmissionDetailForCoderWorklistVoCollection coll = new AdmissionDetailForCoderWorklistVoCollection();
		
		for(int i=0; i<list.size(); i++)
		{
			Object record = list.get(i);
			
			AdmissionDetailForCoderWorklistVo item = null;
			
			if (record instanceof DischargedEpisode)
			{
				DischargedEpisode episodeDO = (DischargedEpisode) record;
				
				item = AdmissionDetailForCoderWorklistVoAssembler.create(episodeDO.getAdmissionDetail());
				
				if(item != null)
				{
					item.setDischargedEpisodeLinked((DischargedEpisodeForClinicalCodingWorklistVoAssembler.create(episodeDO)));
				}
			}
			
			if(item != null)
			{
				coll.add(item);
			}
		}
		
		return coll;
	}

	private String getMRNNumbers(String MRNNumbers)
	{
		if(MRNNumbers == null || MRNNumbers.length() == 0)
			return null;
		
		String[] MRNNumbersArray = MRNNumbers.split(",");
		StringBuffer formatedMRNNumbers = new StringBuffer();
		
		for(int i=0; i<MRNNumbersArray.length; i++)
		{
			if(MRNNumbersArray[i] == null || MRNNumbersArray[i].length() == 0)
				continue;
			
			formatedMRNNumbers.append(formatedMRNNumbers.length() > 0 ? "," : "");
			formatedMRNNumbers.append("'" + MRNNumbersArray[i].trim() + "'");
		}
		
		return formatedMRNNumbers.toString();
	}

	private String getWardIds(LocationLiteVoCollection wards)
	{
		if(wards == null || wards.size()==0)
		return null;
	
		StringBuffer ids = new StringBuffer();
	
    	for(int i=0;i<wards.size();i++)
		{
			if(wards.get(i) == null)
				continue;
			
			if(ids.length() > 0)
				ids.append(",");
			
			ids.append(wards.get(i).getID());
		}
    
    	return ids.toString();
	}

	
	private String getCodingStatusesLookupIDs(LookupInstanceCollection codingStatuses)
	{
		if(codingStatuses == null)
			return null;
		
		int stSize = codingStatuses.size();
		
		if (stSize == 0)
			return null;
		
		StringBuilder str = new StringBuilder();
		String commaStr = "";
		for (int i=0;i<stSize;i++)
		{
			if (codingStatuses.getIndex(i) == null)
				continue;
			
			if((codingStatuses.getIndex(i).getID() == CodingStatus.UNCODED.getID()) || (codingStatuses.getIndex(i).getID() == CodingStatus.INPROGRESS.getID()))
				continue;
			
			str.append(commaStr + codingStatuses.getIndex(i).getID());
			commaStr = ", ";
		}
		
		return str.toString();
	}

	private boolean searchAfterUncoded(LookupInstanceCollection codingStatuses)
	{
		if(codingStatuses == null)
			return false;
		
		for(int i=0; i<codingStatuses.size(); i++)
		{
			if(codingStatuses.getIndex(i) == null)
				continue;
			
			if(CodingStatus.UNCODED.getID() == codingStatuses.getIndex(i).getID())
				return true;
		}
		
		return false;
	}
	
	private boolean searchAfterInProgress(LookupInstanceCollection codingStatuses)
	{
		if(codingStatuses == null)
			return false;
		
		for(int i=0; i<codingStatuses.size(); i++)
		{
			if(codingStatuses.getIndex(i) == null)
				continue;
			
			if(CodingStatus.INPROGRESS.getID() == codingStatuses.getIndex(i).getID())
				return true;
		}
		
		return false;
	}

	//WDEV-20395
	private String getWardsIds(LocationLiteVoCollection coll)
	{
		if(coll == null || coll.size() == 0)
			return null;
		
		StringBuffer ids = new StringBuffer();
		
		for(LocationLiteVo ward : coll)
		{
			if(ward == null)
				continue;
			
			ids.append(ids.length() > 0 ? "," : "");
			ids.append(ward.getID_Location());
		}
		
		return ids.toString();
	}

	private String getLookupIDs(LookupInstanceCollection collInstances)
	{
		int stSize = collInstances.size();
		if (stSize == 0)
			return null;
		StringBuilder str = new StringBuilder();
		String commaStr = "";
		for (int i=0;i<stSize;i++)
		{
			if (collInstances.getIndex(i) == null)
				continue;
			str.append(commaStr + collInstances.getIndex(i).getID());
			commaStr = ", ";
		}
		return str.toString();
	}

	public LocationLiteVo getCurrentHospital(ILocation location)
	{
		if(location == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, location.getID()));
		
		if(currentHospital instanceof Location)
			return LocationLiteVoAssembler.create((Location) currentHospital);
		
		return null;
	}
	
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public LocationLiteVoCollection listWards(LocationRefVo hospital, String wardName) //WDEV-20395
	{
		OrganisationAndLocation orgLoc = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return orgLoc.listActiveWardsForHospitalByNameLite(hospital, wardName);
	}

	public PatientShort getPatientShort(PatientRefVo patientRef)
	{
		if (patientRef == null)
			throw new CodingRuntimeException("Cannot get Patient on null Id");
		
		Patient patBo = (Patient) getDomainFactory().getDomainObject(Patient.class, patientRef.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}

	//WDEV-19610
	public Boolean hasPatientReferralCodings(PatientRefVo patientRef)
	{
		if(patientRef == null || patientRef.getID_Patient() == null)
			return false;
		
		ReferralCoding	impl = (ReferralCoding) getDomainImpl(ReferralCodingImpl.class);
		return  impl.hasPatientMoreReferralCodings(patientRef, null);
	}

	public LocationLiteVoCollection listHospitals()
	{
		return listLocations(null, LocationType.HOSP);
	}
	
	private LocationLiteVoCollection listLocations(String name, LocationType locType)
	{
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "from Location loc where (loc.type.id = :typeId";
		names.add("typeId");
		values.add(new Integer(locType.getId()));
		
		if (name != null)
		{
			hql += " and loc.upperName like :name ";
			names.add("name");
			values.add(name.toUpperCase() + "%");
		}
		hql += (" and loc.isVirtual = :virtual and loc.isActive = 1) order by loc.upperName asc");
		names.add("virtual");
		values.add(Boolean.FALSE);
		
		List<?> l = this.getDomainFactory().find(hql, names, values);
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(l);
	}

	public LocationLiteVoCollection listCaseNoteFolderLocations(LocationRefVo hospital, String searchLoc)
	{
		//WDEV-20395
		OrganisationAndLocation orgLoc = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return orgLoc.listLocationsByTheParentLocation(null, hospital, Boolean.TRUE, null, null,Boolean.TRUE, searchLoc);//WDEV-22088
	}

	public CatsReferralRefVo getCatsReferral(PASEventRefVo pasEvent)
	{
		if(pasEvent == null || pasEvent.getID_PASEvent() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		EpisodeOfCare ep = null;
		
		String query = "select ep from CareContext as cc left join cc.episodeOfCare as ep left join cc.pasEvent as pe where pe.id = :PasEventId";
		List listEpisodeOfCare = factory.find(query, new String[] {"PasEventId"}, new Object[] {pasEvent.getID_PASEvent()});
		
		if(listEpisodeOfCare != null && listEpisodeOfCare.size() > 0 && listEpisodeOfCare.get(0) instanceof EpisodeOfCare)
		{
			ep = (EpisodeOfCare) listEpisodeOfCare.get(0);
		}
		
		if(ep != null)
		{
    		String querySec = "select catsReferral from CatsReferral as catsReferral left join catsReferral.careContext as cc left join cc.episodeOfCare as epCare where epCare.id = :EpisodeOfCareId";
    		
    		List listCatsReferral = factory.find(querySec, new String[] {"EpisodeOfCareId"}, new Object[] {ep.getId()});
    		
    		if(listCatsReferral != null && listCatsReferral.size() > 0 && listCatsReferral.get(0) instanceof CatsReferral)
    		{
    			return new CatsReferralRefVo(((CatsReferral) listCatsReferral.get(0)).getId(), ((CatsReferral) listCatsReferral.get(0)).getVersion());
    		}
		}
		
		return null;
	}
}
