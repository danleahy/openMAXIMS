//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Alexie Ursache using IMS Development Environment (version 1.54 build 2714.21485)
// Copyright (C) 1995-2007 IMS MAXIMS plc. All rights reserved.

package ims.ccosched.domain.impl;

import ims.admin.domain.LookupTree;
import ims.admin.domain.impl.LookupTreeImpl;
import ims.ccosched.domain.ClinicView;
import ims.ccosched.domain.base.impl.BaseActivityViewImpl;
import ims.ccosched.vo.PatTreatmentPlanLiteVo;
import ims.core.domain.Demographics;
import ims.core.domain.impl.DemographicsImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.Patient;
import ims.core.vo.PatientShort;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupMapping;
import ims.dto.Result;
import ims.dto.client.Clinical_team;
import ims.dto.client.Go_ptreatpl;
import ims.dto.client.Lkup;
import ims.dto.client.Sd_aalst;
import ims.dto.client.Sd_aalst.Sd_aalstRecord;
import ims.dto.client.Sd_aalst_pb;
import ims.dto.client.Sd_aalst_pb.Sd_aalst_pbRecord;
import ims.dto.client.Sd_activity;
import ims.dto.client.Sd_activity_action;
import ims.dto.client.Sd_activity_grp;
import ims.framework.exceptions.CodingRuntimeException;
import ims.vo.LookupInstVo;
import ims.vo.LookupInstanceCollection;
import ims.vo.LookupMappingVo;
import ims.vo.LookupMappingVoCollection;
import ims.vo.LookupTypeVo;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class ActivityViewImpl extends BaseActivityViewImpl
{
	private static final long serialVersionUID = 1L;

	public Sd_activity_grp listActivityGroups(String act_ind_grp) throws DomainInterfaceException
	{
		Sd_activity_grp activityGroups = (Sd_activity_grp)getDTOInstance(Sd_activity_grp.class);
		activityGroups.Filter.clear();
		activityGroups.Filter.Act_ind_grp = act_ind_grp;

		Result result = activityGroups.list();
		if (result != null)
			throw new DomainInterfaceException(result.getMessage());
		
		return activityGroups;
	}

	public Sd_activity listActivities(String act_ind, String grp_act_ind) throws DomainInterfaceException
	{
		Sd_activity activities = (Sd_activity)getDTOInstance(Sd_activity.class);
		activities.Filter.clear();
		activities.Filter.Act_ind = act_ind;
		activities.Filter.Grp_act_ind = grp_act_ind;

		Result result = activities.list();
		if (result != null)
		{
			throw new DomainInterfaceException(result.getMessage());
		}
		
		return activities;
	}

	public Sd_activity_action listActivityAction(String act_ind, String action_act_ind) throws DomainInterfaceException
	{
		Sd_activity_action actions = (Sd_activity_action)getDTOInstance(Sd_activity_action.class); 
		actions.Filter.clear();
		actions.Filter.Act_ind = act_ind;
		actions.Filter.Action_act_ind =action_act_ind;
		Result result = actions.list();
		if (result != null)
		{
			throw new DomainInterfaceException(result.getMessage());
		}
		
		return actions;
	}


	public Clinical_team listHcps(String cons_firm_id) throws DomainInterfaceException
	{
		Clinical_team hcps = (Clinical_team)getDTOInstance(Clinical_team.class);
		hcps.Filter.clear();
		hcps.Filter.Cons_firm_id = cons_firm_id;
		Result result = hcps.list();
		if (result != null)
		{
			throw new DomainInterfaceException(result.getMessage());
		}
		
		return hcps;
	}

	public Sd_aalst_pb listBookedPatients(String appt_head_id, String eb_isbooked, String activitygrp, String activity_id, String eststartdt, String opa_date, String action_id, String act_priorty, String act_consult, String act_status, String actstat, String actdstat) throws DomainInterfaceException
	{
		Sd_aalst_pb patients = (Sd_aalst_pb)getDTOInstance(Sd_aalst_pb.class);
		
		patients.Filter.clear();
		//13/05/2005 - filter the not booked once (the records with Further Appointments)
		patients.Filter.Appt_head_id = appt_head_id;
		patients.Filter.Eb_isbooked  = eb_isbooked;
		//---------------------------------
		
		patients.Filter.Activitygrp = activitygrp;
		patients.Filter.Activity_id = activity_id;
		if(eststartdt != null)
			patients.Filter.Eststartdt = eststartdt;
		patients.Filter.Opa_date	   = opa_date;
		if (action_id != null)
			patients.Filter.Action_id = action_id;
		if (act_priorty != null)
			patients.Filter.Act_priorty = act_priorty;
		if (act_consult != null)
			patients.Filter.Act_consult = act_consult;
		if(act_status != null)
			patients.Filter.Act_status = act_status; //"!-220||-224";

		patients.Filter.Actstat  = actstat;
		patients.Filter.Actdstat = actdstat;
		Result result = patients.list();
		if (result != null)
		{
			throw new DomainInterfaceException(result.getMessage());
		}
		
//		if(act_status == "!-220||-221||-224")
//			return excludeDelayed(patients);
		
		return patients;
	}

	private Sd_aalst_pb excludeDelayed(Sd_aalst_pb patients) {
		
		Sd_aalst_pb excludedList = (Sd_aalst_pb)getDTOInstance(Sd_aalst_pb.class);			
	
		for (int i = 0; i < patients.DataCollection.count(); ++i)
		{
			Sd_aalst_pbRecord sd_aalst_pbRecord = patients.DataCollection.get(i);
			
			//get delayed records and check ecad date
			if(sd_aalst_pbRecord.Act_status.equals("-221")){
				
				Go_ptreatpl tp = (Go_ptreatpl)getDTOInstance(Go_ptreatpl.class);
				tp.Filter.clear();
				tp.Filter.Unid = sd_aalst_pbRecord.Pt_tp_id;
				Result result = tp.get();
				if (result != null)
				{
				
				}
				else if(!tp.DataCollection.get(0).Ecad_date.equals(""))
					excludedList.DataCollection.add(patients.DataCollection.get(i));
			}
			else
				excludedList.DataCollection.add(patients.DataCollection.get(i));
		}
		return excludedList;
	}

	public Sd_aalst lisPatients(String appt_head_id, String activitygrp, String activity_id, String eststartdt, 
								String opa_date, String action_id, String act_priorty, String act_consult, String act_status, String actstat, String actdstat) throws DomainInterfaceException
	{
		Sd_aalst patients = (Sd_aalst)getDTOInstance(Sd_aalst.class);
		
		patients.Filter.clear();
		patients.Filter.Appt_head_id = appt_head_id;
		patients.Filter.Activitygrp = activitygrp;
		patients.Filter.Activity_id = activity_id;
		if(eststartdt != null)
			patients.Filter.Eststartdt = eststartdt;
		patients.Filter.Opa_date	   = opa_date;
		if (action_id != null)
			patients.Filter.Action_id = action_id;
		if (act_priorty != null)
			patients.Filter.Act_priorty = act_priorty;
		if (act_consult != null)
			patients.Filter.Act_consult = act_consult;
		//ICCO702
		if(act_status != null)
			patients.Filter.Act_status = act_status; //"!-220||-224";

		patients.Filter.Actstat = actstat;
		patients.Filter.Actdstat = actdstat;
		
		Result result = patients.list();
		if (result != null)
		{
			throw new DomainInterfaceException(result.getMessage());
		}
		
	//	if(act_status == "!-220||-221||-224")
	//		return excludeDelayed(patients);
		
		return patients;
	}

	private Sd_aalst excludeDelayed(Sd_aalst patients) {
		Sd_aalst excludedList = (Sd_aalst)getDTOInstance(Sd_aalst.class);			
		
		for (int i = 0; i < patients.DataCollection.count(); ++i)
		{
			Sd_aalstRecord sd_aalstRecord = patients.DataCollection.get(i);
			
			//get delayed records and check ecad date
			if(sd_aalstRecord.Act_status.equals("-221")){
				
				Go_ptreatpl tp = (Go_ptreatpl)getDTOInstance(Go_ptreatpl.class);
				tp.Filter.clear();
				tp.Filter.Unid = sd_aalstRecord.Pt_tp_id;
				Result result = tp.get();
				if (result != null)
				{
				
				}
				else if(!tp.DataCollection.get(0).Ecad_date.equals(""))
					excludedList.DataCollection.add(patients.DataCollection.get(i));
			}
			else
				excludedList.DataCollection.add(patients.DataCollection.get(i));
		}
		return excludedList;
	}

	public ims.core.vo.PatientShort getPatient(PatientRefVo patient) throws DomainInterfaceException, StaleObjectException
	{
		Demographics demographicsImpl = (Demographics) getDomainImpl(DemographicsImpl.class);
		return demographicsImpl.getPatient(patient);
	} 
	
	public Patient getPatient(PatientShort patient) throws StaleObjectException, DomainInterfaceException
	{
		Demographics demographicsImpl = (Demographics) getDomainImpl(DemographicsImpl.class);
		return demographicsImpl.getPatient(patient);
	}

	public ims.dto.client.Patient getPatient(String pkey) throws DomainInterfaceException
	{
		if(pkey == null)
			throw new DomainRuntimeException("Cannot get Patient for null pkey");
		
		ims.dto.client.Patient patient = (ims.dto.client.Patient)getDTOInstance(ims.dto.client.Patient.class);
		patient.Filter.clear();
		patient.Filter.Pkey = pkey;
		
		Result result = patient.get();
		if (result != null)
		{
			if(result.getId() == -2)
				throw new DomainInterfaceException("Error Getting Patient Details for pkey = " + pkey);

			throw new DomainInterfaceException(result.getMessage());
		}

		if (patient.DataCollection.count()!= 1)
			throw new DomainInterfaceException("Failed to get patient record.");
		
		return patient;
	}
	
	public PatTreatmentPlanLiteVo getTreatmentPlan(Integer actionIdFromDTO) 
	{
		ClinicView implClinicView = (ClinicView)getDomainImpl(ClinicViewImpl.class);
		return implClinicView.getTreatmentPlan(actionIdFromDTO);
	}

	//wdev-14544
	public HcpLiteVoCollection listHCPs() 
	{
		DomainFactory factory = getDomainFactory();
		
		List hcps = null;
		String hql = "";
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();	
		StringBuffer condStr = new StringBuffer();
	
		
		hql = " select hp from StaffActivity as s1_1 left join s1_1.mos as m1_1 left join m1_1.hcp as hp ";

		condStr.append(" s1_1.active =:active");
		markers.add("active");
		values.add("Y");
		
		condStr.append(" order by hp.mos.name.upperSurname,hp.mos.name.upperForename");
		hql += " where ";
		hql += condStr.toString();
		hcps = factory.find(hql, markers, values);

		HcpLiteVoCollection voCollHcps = new HcpLiteVoCollection();
		if(hcps != null)
		{			
			for(int i=0;i<hcps.size();i++)
			{
				Hcp hcp = (Hcp)hcps.get(i);
				if (Medic.class.isAssignableFrom(hcp.getClass()))
					voCollHcps.add(HcpLiteVoAssembler.create((Medic)hcp));
			}
		}
		
		return voCollHcps;
	}

	public Lkup getLookupInstance(String lkup_type)
	{
		if(lkup_type == null || lkup_type.length() == 0)
			throw new CodingRuntimeException("Cannot get lookup for null lookup type"); 
			
		Lkup lkup = (Lkup)getDTOInstance(Lkup.class);
		lkup.Filter.Lkup_typ = lkup_type;
		
		Result res = lkup.list();
		
		if(res != null && res.getId() != -2)
		{
			throw new DomainRuntimeException(res.getMessage());
		}
		
		return lkup;
	}
	

	public LookupInstVo getMappings(LookupInstVo instance)
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.LookupInstance doInst = factory.getLookupInstance(instance.getId());
		Set mappings = doInst.getMappings();
		LookupMappingVoCollection mapColl = new LookupMappingVoCollection();
		Iterator iter = mappings.iterator();
		LookupMapping doMapping;
		while (iter.hasNext())
		{
			doMapping = (LookupMapping) iter.next();
			mapColl.add(new LookupMappingVo(doMapping.getExtSystem(), doMapping.getExtCode()));
		}
		mapColl.sort();
		instance.setMappings(mapColl);
		return instance;
	}

	public LookupInstanceCollection getLookupInstances(LookupTypeVo type)
	{
		LookupTree implLookupTree = (LookupTree)getDomainImpl(LookupTreeImpl.class);
		return implLookupTree.getLookupInstances(type);
	}
}
