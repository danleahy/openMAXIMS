//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Sean Nesbitt using IMS Development Environment (version 1.80 build 4198.17562)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.ccosched.domain.impl;

import ims.ccosched.domain.PatTreatmentPlanAction;
import ims.ccosched.vo.PatTreatmentPlanLiteVo;
import ims.ccosched.vo.PatTreatmentPlanVo;
import ims.ccosched.vo.domain.PatTreatmentPlanVoAssembler;
import ims.ccosched.vo.lookups.SeenAt;
import ims.ccosched.vo.lookups.SeenAtCollection;
import ims.ccosched.vo.lookups.Status;
import ims.ccosched.vo.lookups.StatusCollection;
import ims.ccosched.vo.lookups.TreatmentIntent;
import ims.ccosched.vo.lookups.TreatmentIntentCollection;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.vo.EpisodeofCareShortVo;
import ims.core.vo.domain.EpisodeofCareShortVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupService;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.client.Rad_treatment;
import ims.dtomove.vo.GroupVoCollection;
import ims.dtomove.vo.domain.GroupVoAssembler;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.Image;
import ims.framework.utils.ImagePath;
import ims.framework.utils.Time;
import ims.framework.utils.TimeFormat;
import ims.oncology.domain.objects.PatTreatmentPlan;
import ims.oncology.vo.PrimaryTumourDetailsVo;
import ims.oncology.vo.PrimaryTumourDetailsVoCollection;
import ims.oncology.vo.TreatmentGroupTechniqueConfigVoCollection;
import ims.oncology.vo.domain.PrimaryTumourDetailsVoAssembler;
import ims.oncology.vo.lookups.SurgeryRequired;
import ims.oncology.vo.lookups.SurgeryRequiredCollection;
import ims.oncology.vo.lookups.TreatmentGroupSite;
import ims.oncology.vo.lookups.TreatmentGroupSiteCollection;
import ims.vo.LookupInstVo;
import ims.vo.LookupInstanceCollection;
import ims.vo.LookupTypeVo;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

public class PatTreatmentPlanUpdateImpl extends DTODomainImplementation implements ims.ccosched.domain.PatTreatmentPlanUpdate, ims.domain.impl.Transactional
{

	private static final long serialVersionUID = 1L;

	/**
	* Lists all Episode of Care records for the given patient
	*/
	public ims.core.vo.EpisodeofCareShortVoCollection listEpisodesForPatient(ims.core.patient.vo.PatientRefVo patient)
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> names = new ArrayList<String>();
		ArrayList values = new ArrayList();

		names.add("patient");
		values.add(patient.getID_Patient());

		List  lst = factory.find("select epis from EpisodeOfCare epis join epis.careSpell cs left join epis.currentStatus as currentStatus where (cs.patient.id = :patient and (currentStatus is null or currentStatus.status.id <> -2218))", names, values); //WDEV-14326
		if (lst != null && lst.size() > 0)
			return EpisodeofCareShortVoAssembler.createEpisodeofCareShortVoCollectionFromEpisodeOfCare(lst);
		return null;
	}

	/**
	* Lists all Consultants
	*/
	public ims.core.vo.HcpLiteVoCollection listConsultants()
	{
		PatTreatmentPlanAction impl = (PatTreatmentPlanAction) getDomainImpl(PatTreatmentPlanActionImpl.class);
		return impl.listConsultants();
	}

	public PatTreatmentPlanVo saveTreatmentPlan(PatTreatmentPlanVo voTreatmentPlan, Date ecadDate) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		Date oldEcadDate = voTreatmentPlan.getEcad_date();
		
		if (!voTreatmentPlan.isValidated())
		{
			throw new DomainRuntimeException("voTreatmentPlan VO has not be validated.");
		}

		DomainFactory factory = getDomainFactory();
		
		//set ecaddate
		voTreatmentPlan.setEcad_date(ecadDate);
		
		PatTreatmentPlan patTP = PatTreatmentPlanVoAssembler.extractPatTreatmentPlan(factory, voTreatmentPlan);
		
		try
		{
			factory.save(patTP);
		} 
		catch (UnqViolationUncheckedException e) 
		{	
			throw (e);
		}
		if (ecadDate != null)// && oldEcadDate != null)
		{
			if(voTreatmentPlan.getRkeyIsNotNull()
				&& (oldEcadDate == null
					|| (oldEcadDate != null
						&& !ecadDate.equals(oldEcadDate) ) ) )
			{		
				Rad_treatment rad_treatmentDto = (Rad_treatment)getDTOInstance(Rad_treatment.class);
				rad_treatmentDto.DataCollection.add();
				if(oldEcadDate == null)
					rad_treatmentDto.DataCollection.get(0).New_date = "1";
				else
					rad_treatmentDto.DataCollection.get(0).New_date = "0";
	
				Calendar dt = rad_treatmentDto.Connection.getDateTime();
				if(dt != null)
				{
					//Rdat
					rad_treatmentDto.DataCollection.get(0).Rdat  = getServerDate(dt);
					//Rtim
					rad_treatmentDto.DataCollection.get(0).Rtim = getServerTime(dt);
				}			
				rad_treatmentDto.DataCollection.get(0).Rkey = voTreatmentPlan.getRkeyIsNotNull()?voTreatmentPlan.getRkey().toString():"";
				rad_treatmentDto.DataCollection.get(0).Pkey = voTreatmentPlan.getPkeyIsNotNull()?voTreatmentPlan.getPkey().toString():"";
				rad_treatmentDto.DataCollection.get(0).Ecad_date = voTreatmentPlan.getEcad_dateIsNotNull()?GetStringFromDate(voTreatmentPlan.getEcad_date()):"";
				
				Result result = rad_treatmentDto.insert();
				if (result.getId() < 0)
					throw new DomainInterfaceException("Attempt to save rad_treatmentDto failed " + result.getMessage());
			
			}
		}
		
		return PatTreatmentPlanVoAssembler.create(patTP);
	}

	private String getServerTime(Calendar dateTime)
	{
		if(dateTime != null)
		{
			Time tm = new Time(dateTime.getTime());
			return tm.toString(TimeFormat.FLAT6);
		}
			
		return "";
	}
	
	private String getServerDate(Calendar dateTime)
	{
		if(dateTime != null)
		{
			Date dt = new Date(dateTime.getTime());
			return dt.toString(DateFormat.ISO);
		}
			
		return "";
	}
	
	private String GetStringFromDate(Date date)
	{
		if(date != null)
			return date.toString(DateFormat.ISO);
		return "";
	}
	
	public GroupVoCollection listGTS() 
	{
		DomainFactory factory = getDomainFactory();

		List<?> grpList = factory.find("from Group as grp");
		
		if(grpList == null || grpList.size() == 0)
			return null;
		

		return GroupVoAssembler.createGroupVoCollectionFromGroup(grpList);
	}

	public PatTreatmentPlanVo getTreatmentPlan(PatTreatmentPlanLiteVo voTreatmentPlan) 
	{
		if(voTreatmentPlan == null)
			throw new DomainRuntimeException("Cannot get PatTreatmentPlanLiteVo for null voTreatmentPlan");
		
		DomainFactory factory = getDomainFactory();
		PatTreatmentPlan doPTP = (PatTreatmentPlan)factory.getDomainObject(PatTreatmentPlan.class,voTreatmentPlan.getID_PatTreatmentPlan());
		return PatTreatmentPlanVoAssembler.create(doPTP);
	}

	public Integer getRKEYForEpisode(EpisodeOfCareRefVo episodeRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("select r1_1.extReferralKey from EpisodeOfCare as eoc left join eoc.currentReferral as r1_1 where "); 
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		hql.append(" eoc.id = :rId");
		markers.add("rId");
		values.add(episodeRefVo.getID_EpisodeOfCare());

		hql.append(" and eoc.isRIE is null");

		List listEpisodes = factory.find(hql.toString(), markers,values);
		if(listEpisodes != null && listEpisodes.size() > 0)
		{ 
			String element = (String) listEpisodes.get(0);
			if (element != null && element != null)
				return (Integer)new Integer(element);
			else
				return null;
		}
		return null;
	}

	public PrimaryTumourDetailsVo getTumourDetails(EpisodeOfCareRefVo episodeRefVo) 
	{
		if (episodeRefVo == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		String filter = " from PrimaryTumourDetails ptd ";
		StringBuffer filterString = new StringBuffer();

		ArrayList markerNames = new ArrayList();
		ArrayList markerValues = new ArrayList();

		filterString.append(" where ptd.episodeOfCare.id = :eps");
		markerNames.add("eps");
		markerValues.add(episodeRefVo.getID_EpisodeOfCare());
		
		filter += filterString.toString();
		filter += " order by ptd.authoringInformation.authoringDateTime desc";

		java.util.List listPTD = factory.find(filter, markerNames, markerValues);
		PrimaryTumourDetailsVoCollection voColl = PrimaryTumourDetailsVoAssembler.createPrimaryTumourDetailsVoCollectionFromPrimaryTumourDetails(listPTD);

		if (voColl != null && voColl.size() > 0)
			return voColl.get(0);
		else
			return null;
	}

	public TreatmentGroupTechniqueConfigVoCollection listTreatmentGroupTechniqueConfigVo()
	{
		// TODO Auto-generated method stub
		return null;
	}

	public LookupInstanceCollection loadGroupSiteLookup(LookupService lookupService)
	{
		LookupTypeVo vo = new LookupTypeVo();
		vo.setId(TreatmentGroupSite.TYPE_ID);
		
		LookupInstanceCollection lkpColl = getLookupInstances(vo);
		
		return lkpColl;
	}

	public SeenAtCollection loadSeenAtLookup() 
	{
		LookupTypeVo vo = new LookupTypeVo();
		vo.setId(SeenAt.TYPE_ID);
		
		LookupInstanceCollection lkpColl = getLookupInstances(vo);
		
		return SeenAtCollection.buildFromBeanCollection(lkpColl.getBeanCollection());
				
	}
	
	public StatusCollection loadPatientStatusLookup() 
	{
		LookupTypeVo vo = new LookupTypeVo();
		vo.setId(Status.TYPE_ID);
		
		LookupInstanceCollection lkpColl = getLookupInstances(vo);
		
		return StatusCollection.buildFromBeanCollection(lkpColl.getBeanCollection());
	}

	public SurgeryRequiredCollection loadSurgeryRequired() 
	{
		LookupTypeVo vo = new LookupTypeVo();
		vo.setId(SurgeryRequired.TYPE_ID);
		
		LookupInstanceCollection lkpColl = getLookupInstances(vo);
		
		return SurgeryRequiredCollection.buildFromBeanCollection(lkpColl.getBeanCollection());
		
	}

	public TreatmentIntentCollection loadTreatmentIntent() 
	{
		LookupTypeVo vo = new LookupTypeVo();
		vo.setId(TreatmentIntent.TYPE_ID);
		
		LookupInstanceCollection lkpColl = getLookupInstances(vo);
		
		return TreatmentIntentCollection.buildFromBeanCollection(lkpColl.getBeanCollection());
	}	
	
	public LookupInstanceCollection getLookupInstances(LookupTypeVo typeVo)
	{
		LookupInstanceCollection collection = new LookupInstanceCollection();
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup lookupType = factory.getLookup(typeVo.getId());
		if (null != lookupType)
		{
			java.util.Set set = lookupType.getInstances();
			for (Iterator iter = set.iterator(); iter.hasNext();)
			{
				LookupInstance element = (LookupInstance) iter.next();
				LookupInstVo valueObject = createLookupinstanceVo(element);
				collection.add(valueObject);
			}
		}
		return collection;
	}
	private LookupInstVo createLookupinstanceVo(LookupInstance element)
	{
		if (element == null)
			return null;
		Image img = null;
		Image regImage = element.getImage();
		if (regImage != null)
		{
			img = new ImagePath(regImage.getImageId(), regImage.getImagePath());
		}
		LookupInstVo valueObject = new LookupInstVo(element.getId(), element.getText(), element.isActive(), null, img, element.getColor(), element.getOrder());
		LookupInstance doParent = element.getParent();
		if (doParent != null)
		{
			LookupInstVo voParent = createLookupinstanceVo(doParent);
			valueObject.setParentInstance(voParent);
		}
		return valueObject;
	}

	//WDEV-14326
	public EpisodeofCareShortVo getEpisodeOfCare(EpisodeOfCareRefVo episodeRefVo) 
	{
		if (episodeRefVo == null || episodeRefVo.getID_EpisodeOfCare() == null)
		{
			throw new CodingRuntimeException("Cannot get EpisodeOfCareRefVo on null Id ");
		}

		DomainFactory factory = getDomainFactory();

		EpisodeOfCare domainEpisodeOfCare = (EpisodeOfCare) factory.getDomainObject(EpisodeOfCare.class, episodeRefVo.getID_EpisodeOfCare());
	
		return EpisodeofCareShortVoAssembler.create(domainEpisodeOfCare);
	}
	
	
}
