//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.45 build 2257.23328)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.ocs_if.domain.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;





import ims.admin.vo.DemographicFeedVo;
import ims.admin.vo.EDAttendanceFeedVo;
import ims.admin.vo.InPatientADTFeedVo;
import ims.admin.vo.domain.DemographicFeedVoAssembler;
import ims.admin.vo.domain.EDAttendanceFeedVoAssembler;
import ims.admin.vo.domain.InPatientADTFeedVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.clinical.domain.objects.NonUniqueTaxonomyMap;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.GpRefVo;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.GeneralQuestionAnswerVo;
import ims.core.vo.GeneralQuestionAnswerVoCollection;
import ims.core.vo.IfPatientDocumentMessageVo;
import ims.core.vo.Patient;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.domain.GeneralQuestionAnswerVoAssembler;
import ims.core.vo.domain.IfPatientDocumentMessageVoAssembler;
import ims.core.vo.domain.PatientAssembler;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.core.vo.lookups.QueueType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupInstance;
import ims.dtomove.vo.RadioTherapySchedQueueVo;
import ims.dtomove.vo.domain.RadioTherapySchedQueueVoAssembler;
import ims.emergency.vo.ifEDAttendanceVo;
import ims.framework.exceptions.CodingRuntimeException;
import ims.hl7.vo.ElectiveListMessageQueueVo;
import ims.hl7.vo.GPMessageQueueVo;
import ims.hl7.vo.GPPracticeMessageQueueVo;
import ims.hl7.vo.MOSMessageQueueVo;
import ims.hl7.vo.WardMessageQueueVo;
import ims.hl7.vo.domain.ElectiveListMessageQueueVoAssembler;
import ims.hl7.vo.domain.GPMessageQueueVoAssembler;
import ims.hl7.vo.domain.GPPracticeMessageQueueVoAssembler;
import ims.hl7.vo.domain.MOSMessageQueueVoAssembler;
import ims.hl7.vo.domain.WardMessageQueueVoAssembler;
import ims.hl7adtout.domain.objects.AppointmentMessageQueue;
import ims.hl7adtout.domain.objects.DemographicsMessageQueue;
import ims.hl7adtout.domain.objects.EdAttendanceMessageQueue;
import ims.hl7adtout.domain.objects.ElectiveListMessageQueue;
import ims.hl7adtout.domain.objects.GPMessageQueue;
import ims.hl7adtout.domain.objects.GPPracticeMessageQueue;
import ims.hl7adtout.domain.objects.InPatientADTMessageQueue;
import ims.hl7adtout.domain.objects.MOSMessageQueue;
import ims.hl7adtout.domain.objects.PatientDocumentMessageQueue;
import ims.hl7adtout.domain.objects.RadioTherapySchedQueue;
import ims.hl7adtout.domain.objects.InpatientEpisodeQueue;
import ims.hl7adtout.domain.objects.WardMessageQueue;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.configuration.vo.InvestigationRefVo;
import ims.core.hl7interface.domain.objects.Hl7OutboundRegister;
import ims.ocrr.orderingresults.domain.objects.CategoryQuestionAnswer;
import ims.ocrr.orderingresults.domain.objects.InvestigationQuestionAnswer;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderChangeResponseQueue;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderMessage;
import ims.ocrr.orderingresults.domain.objects.OrderSpecimen;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.domain.objects.ServiceQuestionAnswer;
import ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.orderingresults.vo.OrderSpecimenRefVo;
import ims.ocrr.vo.ProviderSystemVo;
import ims.ocrr.vo.domain.ProviderSystemVoAssembler;
import ims.ocrr.vo.lookups.AuthorisationOrderStatus;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.InvEventType;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.ocs_if.domain.base.impl.BaseOcsIfImpl;
import ims.ocs_if.helper.IQueueHandler;
import ims.ocs_if.vo.Hl7OutboundRegVo;
import ims.ocs_if.vo.IfOrderInvCurrentStatusVo;
import ims.ocs_if.vo.IfOrderInvestigationVo;
import ims.ocs_if.vo.IfOrderMessageVo;
import ims.ocs_if.vo.IfOrderMessageVoCollection;
import ims.ocs_if.vo.IfOutOcsOrderVo;
import ims.ocs_if.vo.InpatientEpisodeQueueVo;
import ims.ocs_if.vo.OrderChangeResponseVo;
import ims.ocs_if.vo.QueuedEventVo;
import ims.ocs_if.vo.domain.Hl7OutboundRegVoAssembler;
import ims.ocs_if.vo.domain.IfOrderInvCurrentStatusVoAssembler;
import ims.ocs_if.vo.domain.IfOrderInvestigationVoAssembler;
import ims.ocs_if.vo.domain.IfOrderMessageVoAssembler;
import ims.ocs_if.vo.domain.IfOutOcsOrderVoAssembler;
import ims.ocs_if.vo.domain.InpatientEpisodeQueueVoAssembler;
import ims.ocs_if.vo.domain.OrderChangeResponseVoAssembler;
import ims.scheduling.vo.AppointmentMessageQueueVo;
import ims.scheduling.vo.domain.AppointmentMessageQueueVoAssembler;
import ims.vo.LookupInstVo;
import ims.vo.interfaces.IHL7OutboundMessageHandler;

public class OcsIfImpl extends BaseOcsIfImpl implements IQueueHandler
{
	private static final long serialVersionUID = 1L;
	private static final Logger			LOG		= Logger.getLogger(OcsIfImpl.class);


	public IfOutOcsOrderVo getOrder(ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo orderRef)
	{
		DomainFactory factory = getDomainFactory();
		return IfOutOcsOrderVoAssembler.create((OcsOrderSession)factory.getDomainObject(OcsOrderSession.class, orderRef.getID_OcsOrderSession()));
	}

	public IfOrderMessageVo saveOrderMessage(ims.ocs_if.vo.IfOrderMessageVo ordMsg) throws StaleObjectException
	{
		if (ordMsg == null)
			throw new RuntimeException("Cannot save null Order Message");
//WDEV-10170 		if (!ordMsg.isValidated())
//WDEV-10170 			throw new CodingRuntimeException("Order Message has not been validated!");
		
		DomainFactory factory = getDomainFactory();
		OrderMessage domMsg = IfOrderMessageVoAssembler.extractOrderMessage(factory, ordMsg);
		factory.save(domMsg);
		return IfOrderMessageVoAssembler.create(domMsg);
	}

	public IfOrderMessageVoCollection saveOrderMessages(ims.ocs_if.vo.IfOrderMessageVoCollection orderMsgs) throws StaleObjectException
	{
		if (orderMsgs == null)
			throw new RuntimeException("Cannot save null Order Messages");
		DomainFactory factory = getDomainFactory();
		
		IfOrderMessageVoCollection returnColl = new IfOrderMessageVoCollection();
		
		for (int i=0; i<orderMsgs.size(); i++)
		{
			IfOrderMessageVo msg = orderMsgs.get(i);
//WDEV-10170 			if (!msg.isValidated())
//WDEV-10170 				throw new CodingRuntimeEction("Order Message instance " + i + " has not been validated!");
			
			// We should check if this order already exists - it may have previously,
			// but couldn't be saved due to errors
			OrderMessage domMsg = OrderMessage.getOrderMessageFromorder_msg_unq1(factory, msg.getPlacerOrdNum(), getDomLookup(msg.getOrderCategory()));
			if (domMsg == null)
			{
				domMsg = IfOrderMessageVoAssembler.extractOrderMessage(factory, msg);
				factory.save(domMsg);
			}
			else /*if (domMsg != null && domMsg.getHL7Message() == null)*/
			{
				domMsg.setHL7Message(msg.getHL7Message());
				factory.save(domMsg);
			}
			returnColl.add(IfOrderMessageVoAssembler.create(domMsg));
		}
		
		return returnColl;
	}

	public IfOrderInvestigationVo createInvestigationStatusRecord(OrderInvestigationRefVo investigation, IfOrderInvCurrentStatusVo statusRecordVo) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		DecimalFormat dftFormatter = new DecimalFormat("G00000000");
		
		OrderInvestigation inv = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation());
		OrderedInvestigationStatus stat = IfOrderInvCurrentStatusVoAssembler.extractOrderedInvestigationStatus(factory, statusRecordVo);
		inv.getOrdInvStatusHistory().add(stat);
		inv.setOrdInvCurrentStatus(stat);
		
		// wdev-2998 If the status is SENT
		// we want to mark the investigation as processed
		if (stat.getOrdInvStatus().getId() == OrderInvStatus.SENT.getId())
		{
			inv.setWasProcessed(true);
			
			if (inv.getSpecimen() != null&&!inv.getSpecimen().isEmpty())
				for (Object objSpecimen : inv.getSpecimen()) {
					OrderSpecimen specimen = (OrderSpecimen)objSpecimen;
					specimen.setWasProcessed(true);
					if(inv.getInvestigation()!=null
							&&inv.getInvestigation().getEventType()!=null
							&& InvEventType.TIME_SERIES.equals( inv.getInvestigation().getEventType()))
					{
						specimen.setPlacerOrdNum(dftFormatter.format(inv.getId()));
					}
				}
		}
		factory.save(inv);
		return IfOrderInvestigationVoAssembler.create(inv);
	}
	
	public ims.ocs_if.vo.Hl7OutboundRegVo registerOutbound(ims.ocs_if.vo.Hl7OutboundRegVo regVo) throws ims.domain.exceptions.DomainInterfaceException
	{
		if(!regVo.isValidated())
			throw new DomainInterfaceException("regVo Not Validated");

		DomainFactory factory = getDomainFactory();
		Hl7OutboundRegister existingReg = getExistingReg();
		if (existingReg != null)
		{
			if (!existingReg.getIpAddress().equals(regVo.getIpAddress()) || 
					!existingReg.getServletContext().equals(regVo.getServletContext()))
			{
				throw new DomainInterfaceException("An existing Outbound Thread with IP Address = " + 
						existingReg.getIpAddress() + " and Servlet location = " +  
						existingReg.getServletContext() + " is already registered.");
			}
			else
			{
				existingReg.setLastUpdated(regVo.getLastUpdated().getJavaDate());
				existingReg.setRegDateTime(regVo.getRegDateTime().getJavaDate());
			}
		}
		else
		{
			regVo.setID_Hl7OutboundRegister(null);
			existingReg = Hl7OutboundRegVoAssembler.extractHl7OutboundRegister(factory, regVo);
		}
		try
		{
			factory.save(existingReg);
		}
		catch (StaleObjectException e)
		{
			throw new DomainInterfaceException(e);
		}
			
		regVo.setID_Hl7OutboundRegister(existingReg.getId());
		return regVo;
	}

	public ims.ocs_if.vo.Hl7OutboundRegVo updateOutboundRegistration(ims.ocs_if.vo.Hl7OutboundRegVo regVo) throws ims.domain.exceptions.DomainInterfaceException
	{
		return registerOutbound(regVo);
	}

	public void deregisterOutbound(Hl7OutboundRegVo regVo) throws DomainInterfaceException
	{
		if(!regVo.isValidated())
			throw new DomainInterfaceException("regVo Not Validated");

		DomainFactory factory = getDomainFactory();
		Hl7OutboundRegister existingReg = getExistingReg();
		if (existingReg != null)
		{
			if (!existingReg.getIpAddress().equals(regVo.getIpAddress()) || 
					!existingReg.getServletContext().equals(regVo.getServletContext()))
			{
				throw new DomainInterfaceException("Another Outbound Thread with IP Address = " + 
						existingReg.getIpAddress() + " and Servlet location = " +  
						existingReg.getServletContext() + " is registered. Cannot Deregister.");
			}
			else
			{
				try
				{
					factory.delete(existingReg);
				}
				catch (ForeignKeyViolationException e)
				{
					throw new DomainInterfaceException(e);
				}
			}
		}		
	}

	public OcsOrderSessionRefVo getNextOrder()  
	{
		Integer orderId = getNextOrderId();
		if (orderId == null)
			return null;
		OcsOrderSessionRefVo vo = new OcsOrderSessionRefVo();
		vo.setID_OcsOrderSession(orderId);
		return vo;
	}

	public void updateNextOrder(OcsOrderSessionRefVo lastOrderVo) throws StaleObjectException 
	{
		if (lastOrderVo == null)
			return;
		DomainFactory factory = getDomainFactory();
		
		// wdev-2998
		// We should only update the was Processed value if all specimens
		// and investigations for the order have been dealt with
		// Note that this relies on wdev-3000, i.e. that the isAwaitingCollection value
		// is set to false when a specimen has been collected or cancelled
		String hql = " from OcsOrderSession o join o.specimens spc where spc.isAwaitingCollection is true and o.id = :orderId ";
		List pathLst = factory.find(hql, new String[]{"orderId"}, new Object[]{lastOrderVo.getID_OcsOrderSession()});
		if (pathLst != null && pathLst.size() > 0)
			return;  // There are still some outstanding specimens, so we do not mark the order as processed
			
		hql = " from OcsOrderSession o join o.investigations inv " + 
			" where inv.investigation.investigationIndex.category = :category " +
			" and (inv.wasProcessed is false or inv.wasProcessed is null) "  +
			" and (inv.ordInvCurrentStatus.ordInvStatus = :orderStat or inv.ordInvCurrentStatus.ordInvStatus = :authStat) "+
		    " and o.id = :orderId";
		List radLst = factory.find(hql, new String[]{"orderId", "category", "orderStat", "authStat"},
						new Object[]{lastOrderVo.getID_OcsOrderSession(), getDomLookup(Category.CLINICALIMAGING), getDomLookup(OrderInvStatus.ORDERED), getDomLookup(OrderInvStatus.AWAITING_AUTHORISATION)});
		if (radLst != null && radLst.size() > 0)
			return; // There are still some outstanding investigations, so we do not mark the order as processed
		
		OcsOrderSession domOrder = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, lastOrderVo.getID_OcsOrderSession());
		domOrder.setWasProcessed(Boolean.TRUE);
		factory.save(domOrder);
	}
	

	private Hl7OutboundRegister getExistingReg() throws DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		List l = factory.find("from Hl7OutboundRegister");
		if (l.size() == 0) 
			return null;
		if (l.size() > 1)
			throw new DomainInterfaceException("More than one registration record for Outbound Thread found. This is not permitted. Please delete one.");
		
		else return (Hl7OutboundRegister)l.get(0);
	}
	
	/**
	 * getNextOrderId
	 * To get the next Pathology or Radiology Order to process
	 * we need to use a left join and include where sp is null -
	 * as for Radiology orders, there will not be a specimen record.
	 * @return Next Order to process
	 */
	private Integer getNextOrderId()
	{
		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		
		// wdev-2998 wasProcessed added to investigation level too
		// so once a message has been processed for the investigation
		// in question, this will be set to true.  We will omit these from
		// the query

		String sql=null;
		
		//http://jira/browse/WDEV-12682 Changed flag from PukkaJ to ICAB so only do the link to patient in ICAB systems
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			//WDEV-19317 Lower case table names and column names, ensure identifiers match definition
			//           Done so that SQL will work for case sensitive DBs
			sql = "select distinct (id) from ocrr_ocsorder where id in (" +
			" select orderdetai from ocrr_orderinvestiga oi, ocrr_ocsorder ord, ocrr_investigation inv, ocrr_investigationi invidx, core_patient patient " +
			" where oi.orderdetai = ord.id " +
			" and oi.investigat = inv.id " +
			" and ord.patient = patient.id " +
			" and patient.nameuppersurna <> 'DummyICABSurname' " +
			" and oi.lkp_ordinvcurrordinvstat =? " +
			" and inv.investigat = invidx.id " +
			" and ord.wasprocess = 0 " +
			" and (ord.wasdiscard is null or ord.wasdiscard = 0) " +
			" and ord.lkp_authorisat=? " +
			" and (invidx.lkp_category=? or (invidx.lkp_category=? and inv.lkp_eventtype=?))" +
			" and (oi.wasprocess = 0 or oi.wasprocess is null) " +
			" union " +
			" select c_ord from ocrr_orderspecimen os, ocrr_ocsorder ord" +
			" where os.c_ord = ord.id " +
			" and ord.wasprocess = 0 " +
			" and (os.wasprocess is null or os.wasprocess = 0)" +
			" and (ord.wasdiscard is null or ord.wasdiscard = 0) " +
			" and (os.colldateti is not null or os.ispatientc=1 or ord.sendnumber=1) " +
			" and ord.lkp_authorisat=? ) order by id ";
		}
		else
		{
		sql = "select distinct (id) from ocrr_ocsorder where id in (" +
				" select orderdetai from ocrr_orderinvestiga oi, ocrr_ocsorder ord, ocrr_investigation inv, ocrr_investigationi invidx " +
				" where oi.orderdetai = ord.id " +
				" and oi.investigat = inv.id " +
				" and oi.lkp_ordinvcurrordinvstat =? " +
				" and inv.investigat = invidx.id " +
				" and ord.wasprocess = 0 " +
				" and (ord.wasdiscard is null or ord.wasdiscard = 0) " +
				" and ord.lkp_authorisat=? " +
				" and (invidx.lkp_category=? or (invidx.lkp_category=? and inv.lkp_eventtype=?))" +
				" and (oi.wasprocess = 0 or oi.wasprocess is null) " +
				" union " +
				" select c_ord from ocrr_orderspecimen os, ocrr_ocsorder ord" +
				" where os.c_ord = ord.id " +
				" and ord.wasprocess = 0 " +
				" and (os.wasprocess is null or os.wasprocess = 0)" +
				" and (ord.wasdiscard is null or ord.wasdiscard = 0) " +
				" and (os.colldateti is not null or os.ispatientc=1 or ord.sendnumber=1) " +
				" and ord.lkp_authorisat=? ) order by id ";
		}
		
		//List l = factory.find(" select ord from OcsOrder ord left join ord.specimens as sp where ord.wasProcessed = false and (ord.wasDiscarded = false or ord.wasDiscarded is null) and ord.authorisationOrderStatus.id = :authorised and ((sp.collDateTimePlacer is not null or sp.isPatientCollect = true) or sp is null ) order by ord.id", new String[]{"authorised"}, new Object[]{new Integer(AuthorisationOrderStatus.AUTHORISED.getId())}, 1);
		//List l = factory.find(" select ord from OcsOrder ord left join ord.specimens as sp where ord.wasProcessed = false and ord.authorisationOrderStatus = :authorised and ((sp.collDateTimePlacer is not null or sp.isPatientCollect = true) or sp is null ) order by ord.id", new String[]{"authorised"}, new Object[]{getDomLookup(AuthorisationOrderStatus.AUTHORISED)}, 1);		
//		if (l.size() == 0) 
//			return null;
//		
//		OcsOrder ord = (OcsOrder)l.get(0);
		//return ord.getId();
		
		try 
		{
			Integer ret = null;
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, OrderInvStatus.ORDERED.getId());// AuthorisationOrderStatus.AUTHORISED.getId());
			ps.setInt(2, AuthorisationOrderStatus.AUTHORISED.getId());
			ps.setInt(3, Category.CLINICALIMAGING.getId());
			
			ps.setInt(4, Category.PATHOLOGY.getId());
			ps.setInt(5, InvEventType.TIME_SERIES.getId());
			
			ps.setInt(6, AuthorisationOrderStatus.AUTHORISED.getId());
			ResultSet rs = ps.executeQuery();
			if (rs.next())
			{
				ret = Integer.valueOf(rs.getInt(1));
			}
			rs.close();
			ps.close();
			conn.close();
			return ret;
		} 
		catch (SQLException e) 
		{
			//WDEV-7715  Don't throw an exception just log and return NULL
			//throw new DomainRuntimeException(e);
			LOG.warn("SQL Exception getting next order", e);
			return null;
		}		
	}


	public ProviderSystemVo getProviderSystem(String sendingApplication)
	{
		if (sendingApplication == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List lst = factory.find(" from ProviderSystem ps where ps.hl7Application = '" + sendingApplication + "'");
		if (lst == null || lst.size() == 0)
			return null;
		
		return ProviderSystemVoAssembler.create((ProviderSystem) lst.get(0));
			
	}
	
	public GeneralQuestionAnswerVoCollection getPathologyQuestions(OrderSpecimenRefVo specVo, ims.ocrr.orderingresults.vo.OrderInvestigationRefVo investigation,Boolean includeShared)
	{
		if (specVo == null)
			throw new DomainRuntimeException("Specimen must be supplied in order to retrieve questions");

		DomainFactory factory = getDomainFactory();
		
		List returnedList = new ArrayList();

		OrderSpecimen domSpecimen = (OrderSpecimen) factory.getDomainObject(OrderSpecimen.class, specVo.getID_OrderSpecimen());
		
		OrderInvestigation domInvestigation = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation());
		// Category Questions
		String hql = " select o.clinicalInfo.categoryQuestionAnswers from OcsOrderSession o " +
		 	" join o.specimens spc where spc.id = :specimenId";
		
		List categoryList = factory.find(hql, new String[]{"specimenId"}, new Object[]{specVo.getID_OrderSpecimen()});

		// We now have the CategoryQuestionAnswerCollection, from here,
		// get Category, Service and Investigation questions?
		Iterator catIt = categoryList.iterator();
		while (catIt.hasNext())
		{
			CategoryQuestionAnswer domCat = (CategoryQuestionAnswer) catIt.next();
			
			// Category
			if (domCat.getCategory().getId() == Category.PATHOLOGY.getId()&&includeShared)
				returnedList.addAll(domCat.getCategoryQuestionAnswers());
			
			// Service Questions
			String serviceHql = " select svc from CategoryQuestionAnswer cat " +
					" join cat.serviceQuestionAnswers as svc " + 
					" where cat.id = :categoryId and svc.service.id = :serviceId";
			List svcLst = factory.find(serviceHql, new String[]{"categoryId", "serviceId"}, new Object[]{domCat.getId(), domSpecimen.getDiscipline().getId()});
			Iterator svcIt = svcLst.iterator();
			while (svcIt.hasNext())
			{
				ServiceQuestionAnswer svc = (ServiceQuestionAnswer) svcIt.next();
				if(includeShared)
				{
					returnedList.addAll(svc.getServiceQuestionAnswers());
				}
				List invList = svc.getInvestigationQuestionAnswers();
				Iterator invIt = invList.iterator();
				while (invIt.hasNext())
				{
					InvestigationQuestionAnswer inv = (InvestigationQuestionAnswer) invIt.next();
					Investigation domInv = inv.getInvestigation();
					if (domInvestigation == null || domInvestigation.getInvestigation().getId().equals(domInv.getId()))
							returnedList.addAll(inv.getInvestigationQuestionAnswers());
					
				}
			}
		}
		
		GeneralQuestionAnswerVoCollection returnColl = new GeneralQuestionAnswerVoCollection();
		GeneralQuestionAnswerVoCollection questionColl =  GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(returnedList);
		// wdev-3018 Remove all non-questions and non-answered questions
		for (int i=0; i<questionColl.size(); i++)
		{
			GeneralQuestionAnswerVo vo = questionColl.get(i);
			if (vo.getQuestion().getIsQuestionIsNotNull() && vo.getQuestion().getIsQuestion().booleanValue() == true)
				returnColl.add(vo);
				
		}
		return returnColl;
	}
	
	
	public GeneralQuestionAnswerVoCollection getRadiologyQuestions(OrderInvestigationRefVo invVo)
	{
		if (invVo == null)
			throw new DomainRuntimeException("Investigation must be supplied in order to retrieve questions");
		
		DomainFactory factory = getDomainFactory();
		
		List returnedList = new ArrayList();

		OrderInvestigation domInv = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, invVo.getID_OrderInvestigation());
		
		// Category Questions
		String hql = " select o.clinicalInfo.categoryQuestionAnswers from OcsOrderSession o " +
		 	" join o.investigations inv where inv.id = :investigationId";
		
		List categoryList = factory.find(hql, new String[]{"investigationId"}, new Object[]{invVo.getID_OrderInvestigation()});

		// We now have the CategoryQuestionAnswerCollection, from here,
		// get Category, Service and Investigation questions?
		Iterator catIt = categoryList.iterator();
		while (catIt.hasNext())
		{
			CategoryQuestionAnswer domCat = (CategoryQuestionAnswer) catIt.next();
			
			// Category
			if (domCat.getCategory().getId() == Category.CLINICALIMAGING.getId())
				returnedList.addAll(domCat.getCategoryQuestionAnswers());
			
			// Service Questions
			String serviceHql = " select svc from CategoryQuestionAnswer cat " +
					" join cat.serviceQuestionAnswers as svc " + 
					" where cat.id = :categoryId and svc.service.id = :serviceId";
			List svcLst = factory.find(serviceHql, new String[]{"categoryId", "serviceId"}, new Object[]{domCat.getId(), domInv.getInvestigation().getProviderService().getLocationService().getService().getId()});
			Iterator svcIt = svcLst.iterator();
			while (svcIt.hasNext())
			{
				ServiceQuestionAnswer svc = (ServiceQuestionAnswer) svcIt.next();
				returnedList.addAll(svc.getServiceQuestionAnswers());
				
				List invList = svc.getInvestigationQuestionAnswers();
				Iterator invIt = invList.iterator();
				while (invIt.hasNext())
				{
					InvestigationQuestionAnswer inv = (InvestigationQuestionAnswer) invIt.next();
					if (inv.getInvestigation().getId().equals(domInv.getInvestigation().getId()))
						returnedList.addAll(inv.getInvestigationQuestionAnswers());
					
				}
			}
		}
		
		GeneralQuestionAnswerVoCollection returnColl = new GeneralQuestionAnswerVoCollection();
		GeneralQuestionAnswerVoCollection questionColl =  GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(returnedList);
		// wdev-3018 Remove all non-questions and non-answered questions
		for (int i=0; i<questionColl.size(); i++)
		{
			GeneralQuestionAnswerVo vo = questionColl.get(i);
			if (vo.getQuestion().getIsQuestionIsNotNull() && vo.getQuestion().getIsQuestion().booleanValue() == true)
				returnColl.add(vo);
				
		}
		return returnColl;

	}
	
	public ProviderSystemVo getProviderSystem(InvestigationRefVo invVo)
	{
		if (invVo == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Investigation domInv = (Investigation)factory.getDomainObject(Investigation.class, invVo.getID_Investigation());
		return ProviderSystemVoAssembler.create(domInv.getProviderService().getProviderSystem());
	}

	public ServiceShortVo getService(InvestigationRefVo invVo)
	{
		if (invVo == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Investigation domInv = (Investigation)factory.getDomainObject(Investigation.class, invVo.getID_Investigation());
		return ServiceShortVoAssembler.create(domInv.getProviderService().getLocationService().getService());
	}

	public String getServiceMapping(ServiceRefVo service, LookupInstVo taxType)
	{
		if (service == null || taxType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		Service domSvc = (Service)factory.getDomainObject(Service.class, service.getID_Service());
		LookupInstance domTax = getDomLookup(taxType);
		
		for (int i = 0; i < domSvc.getTaxonomyMap().size(); i++)
		{
			//WDEV-21146
//			TaxonomyMap map = (TaxonomyMap)domSvc.getTaxonomyMap().get(i);
			NonUniqueTaxonomyMap map = (NonUniqueTaxonomyMap)domSvc.getTaxonomyMap().get(i); //WDEV-21146
			if (map.getTaxonomyName().equals(domTax))
				return map.getTaxonomyCode();
		}
		return null;
	}

	public void saveOrderAsDiscarded(OcsOrderSessionRefVo order) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		OcsOrderSession domOrder = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, order.getBoId().intValue());
		domOrder.setWasDiscarded(Boolean.TRUE);
		factory.save(domOrder);
	}

// http://jira/browse/WDEV-11629
	public IHL7OutboundMessageHandler getEvent(QueuedEventVo event)
	{
		if (event!=null)
		{
			DomainFactory factory = getDomainFactory();
			if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.ORDERCHANGERESPONSE))
			{
				return OrderChangeResponseVoAssembler.create((OrderChangeResponseQueue)factory.getDomainObject(OrderChangeResponseQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.PATIENTDOCUMENT))
			{
				return IfPatientDocumentMessageVoAssembler.create((PatientDocumentMessageQueue)factory.getDomainObject(PatientDocumentMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.DEMOGRAPHICFEED))
			{
				return DemographicFeedVoAssembler.create((DemographicsMessageQueue)factory.getDomainObject(DemographicsMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.EDATTENDANCE))
			{
				EdAttendanceMessageQueue queue = (EdAttendanceMessageQueue)factory.getDomainObject(EdAttendanceMessageQueue.class, event.getID());
				if (queue!=null&&queue.getIsRIE()!=null&&queue.getIsRIE())
				{
					queue.setIncludeRecord(true);
				}
				EDAttendanceFeedVo feedVo=  EDAttendanceFeedVoAssembler.create((queue));
				if(feedVo.getAttendance()==null&&queue.getAttendance()!=null)
				{
					feedVo.setAttendance(new ifEDAttendanceVo());
				}
				if(feedVo.getAttendance().getPatient()==null)
				{
					Patient pat =  PatientAssembler.create( queue.getAttendance().getPatient());
					feedVo.getAttendance().setPatient(pat);
				}
				return  feedVo;
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.INPATIENTADT))
			{
				return  InPatientADTFeedVoAssembler.create((InPatientADTMessageQueue)factory.getDomainObject(InPatientADTMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.APPOINTMENT))
			{
				return  AppointmentMessageQueueVoAssembler.create((AppointmentMessageQueue)factory.getDomainObject(AppointmentMessageQueue.class, event.getID()));
			}
			//WDEC-19160
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.RADIOTHERAPYSCHEDULING))
			{
				PatientRefVo patRefVo = null;
				RadioTherapySchedQueue queueDom = (RadioTherapySchedQueue)factory.getDomainObject(RadioTherapySchedQueue.class, event.getID());	
				if(queueDom!=null
						&&queueDom.getAppointment()!=null
						&&queueDom.getAppointment().getPatient()!=null)
				{
						patRefVo = new PatientRefVo(queueDom.getAppointment().getPatient().getId(), queueDom.getAppointment().getPatient().getVersion());
				}
				RadioTherapySchedQueueVo radioTherapySched = RadioTherapySchedQueueVoAssembler.create(queueDom);
				radioTherapySched.setPatient(patRefVo);
				return radioTherapySched;
			}
			
			
			//WDEV-19481
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.INPATIENTEPISODE))
			{
				PatientRefVo patRefVo = null;
				InpatientEpisodeQueue queueDom = (InpatientEpisodeQueue)factory.getDomainObject(InpatientEpisodeQueue.class, event.getID());	
				if(queueDom!=null
						&&queueDom.getPasEvent()!=null
						&&queueDom.getPasEvent().getPatient()!=null)
				{
						patRefVo = new PatientRefVo(queueDom.getPasEvent().getPatient().getId(), queueDom.getPasEvent().getPatient().getVersion());
				}
				InpatientEpisodeQueueVo inpatientEpisodeQueueVo = InpatientEpisodeQueueVoAssembler.create(queueDom);
				inpatientEpisodeQueueVo.setPatient(patRefVo);
				return inpatientEpisodeQueueVo;				
			}
			
			//WDEV-19704 Patient Elective List events
			else if(event.getQueueTypeIsNotNull() && event.getQueueType().equals(QueueType.ELECTIVELIST))
			{
				PatientRefVo patRefVo = null;
				ElectiveListMessageQueue queueDom = (ElectiveListMessageQueue)factory.getDomainObject(ElectiveListMessageQueue.class, event.getID());	
				ElectiveListMessageQueueVo electiveListMessageQueueVo = ElectiveListMessageQueueVoAssembler.create(queueDom);
				if(queueDom != null
						&& queueDom.getPatientElectiveList() != null
						&& queueDom.getPatientElectiveList().getPatient() != null)
				{
						patRefVo = new PatientRefVo(queueDom.getPatientElectiveList().getPatient().getId(), queueDom.getPatientElectiveList().getPatient().getVersion());
				}
				electiveListMessageQueueVo.setPatient(patRefVo);				
				return electiveListMessageQueueVo;				
			}
			
			
			//WDEV-19576 Master File events
			else if(event.getQueueTypeIsNotNull() && event.getQueueType().equals(QueueType.WARDMASTERFILE))
			{
				LocationRefVo locRefVo = null;
				WardMessageQueue queueDom = (WardMessageQueue)factory.getDomainObject(WardMessageQueue.class, event.getID());
				if(queueDom!=null && queueDom.getWard()!=null)
				{
					locRefVo = new LocationRefVo(queueDom.getWard().getId(), queueDom.getWard().getVersion());
				}
				WardMessageQueueVo wardMessageQueueVo = WardMessageQueueVoAssembler.create(queueDom);
				wardMessageQueueVo.setWard(locRefVo);
				return wardMessageQueueVo;				
			}
			else if(event.getQueueTypeIsNotNull() && event.getQueueType().equals(QueueType.GPPRACTICEMASTERFILE))
			{
				OrganisationRefVo orgRefVo = null;
				GPPracticeMessageQueue queueDom = (GPPracticeMessageQueue)factory.getDomainObject(GPPracticeMessageQueue.class, event.getID());
				if(queueDom!=null && queueDom.getPractice()!=null)
				{
					orgRefVo = new OrganisationRefVo(queueDom.getPractice().getId(), queueDom.getPractice().getVersion());
				}
				GPPracticeMessageQueueVo gpPracticeMessageQueueVo = GPPracticeMessageQueueVoAssembler.create(queueDom);
				gpPracticeMessageQueueVo.setPractice(orgRefVo);
				return gpPracticeMessageQueueVo;				
			}
			else if(event.getQueueTypeIsNotNull() && event.getQueueType().equals(QueueType.MOSMASTERFILE))
			{
				MemberOfStaffRefVo mosRefVo = null;
				MOSMessageQueue queueDom = (MOSMessageQueue)factory.getDomainObject(MOSMessageQueue.class, event.getID());
				if(queueDom!=null && queueDom.getMOS()!=null)
				{
					mosRefVo = new MemberOfStaffRefVo(queueDom.getMOS().getId(), queueDom.getMOS().getVersion());
				}
				MOSMessageQueueVo mosMessageQueueVo = MOSMessageQueueVoAssembler.create(queueDom);
				mosMessageQueueVo.setMOS(mosRefVo);
				return mosMessageQueueVo;				
			}
			else if(event.getQueueTypeIsNotNull() && event.getQueueType().equals(QueueType.GPMASTERFILE))
			{
				GpRefVo gpRefVo = null;
				GPMessageQueue queueDom = (GPMessageQueue)factory.getDomainObject(GPMessageQueue.class, event.getID());
				if(queueDom!=null && queueDom.getGP()!=null)
				{
					gpRefVo = new GpRefVo(queueDom.getGP().getId(), queueDom.getGP().getVersion());
				}
				GPMessageQueueVo gpMessageQueueVo = GPMessageQueueVoAssembler.create(queueDom);
				gpMessageQueueVo.setGP(gpRefVo);
				return gpMessageQueueVo;				
			}
			
		}
		return null;
	}
	

	public QueuedEventVo getNextQueuedEvent()
	{
		QueuedEventVo event = null;
		try {
			DomainFactory factory = getDomainFactory();

			StringBuffer query = new StringBuffer();
			List <?> triggers = factory.find("select distinct l2_1.id from OutboundTriggers as o1_1 left join o1_1.queueType as l1_1 left join l1_1.instance as l2_1");
		
			//WDEV-21635
			if(triggers!=null
				&&triggers.isEmpty()
				&&"Configured".equals(ConfigFlag.HL7.EXTENDED_HL7_PROCESSING.getValue()))
			{
				return null;
			}
			//http://jira/browse/WDEV-13985 change conditions
			if(triggers!=null&&!triggers.isEmpty())
			{
				if (triggers.contains(QueueType.DEMOGRAPHICFEED.getID()))
				{
					if(ConfigFlag.GEN.ICAB_ENABLED.getValue()) //WDEV-18949
					{
						//WDEV-19317 Lower case table and column names
						//           Done so that SQL will work for case sensitive DBs
						query.append("select adto_demographicsmq.id,lkp_queuetype,adto_demographicsmq.sys_creation_datetime as DT "+
									"from adto_demographicsmq "+
									"left join core_patient on adto_demographicsmq.patient=core_patient.id "+
									"where core_patient.nameuppersurna <> 'DummyICABSurname' "+ 
									"and (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");

					}
					else
					{
						query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
									"from adto_demographicsmq where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
					}
				}
				if (triggers.contains(QueueType.ORDERCHANGERESPONSE.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					//WDEV-19317 Lower case table and column names
					//           Done so that SQL will work for case sensitive DBs
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
								"from ocrr_orderchangeres where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
				}
				if(triggers.contains(QueueType.PATIENTDOCUMENT.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					//WDEV-19317 Lower case table and column names
					//           Done so that SQL will work for case sensitive DBs
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
								"from adto_patientdocumen where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
				}	
				if(triggers.contains(QueueType.EDATTENDANCE.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					//WDEV-19317 Lower case table and column names
					//           Done so that SQL will work for case sensitive DBs
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
								"from adto_edattendanceme where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
				}
				if(triggers.contains(QueueType.INPATIENTADT.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					//WDEV-1317 Lower case table and column names
					//           Done so that SQL will work for case sensitive DBs
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
								"from adto_inpatientadtme where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
				}	
				if(triggers.contains(QueueType.APPOINTMENT.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
					{
						//WDEV-19317 Lower case column and table names, ensure identifiers match definition
						//           Done so that SQL will work for case sensitive DBs
						query.append("select adto_appointmentmes.id,lkp_queuetype,adto_appointmentmes.sys_creation_datetime as DT "+
									"from adto_appointmentmes "+
									"left join schl_sch_booking  on adto_appointmentmes.appointmen=schl_sch_booking.id "+
									"left join core_patient on schl_sch_booking.patient=core_patient.id "+
									"where core_patient.nameuppersurna <> 'DummyICABSurname' "+ 
									"and (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
					}
					else
					{
						query.append("select id,lkp_queuetype,sys_creation_datetime as DT "+
									"from adto_appointmentmes where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");

					}
					
				}	

			}	
			if(ConfigFlag.HL7.EXTENDED_HL7_PROCESSING.getValue().equals("CARE_UK"))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				if (ConfigFlag.GEN.ICAB_ENABLED.getValue())
					{
//					ExternalSystemEventTypes.NEWORDER.getId() -1518
					//WDEV-19317 Lower case column and table names
					//           Done so that SQL will work for case sensitive DBs
					query.append("select ext.id,null,ext.sys_creation_datetime as DT from schl_externalsy as ext ");
					query.append("left join ocrr_orderinvestiga inv on ext.investigat=inv.id ");
					query.append("left join ocrr_ocsorder orde on inv.orderdetai=orde.id ");
					query.append("left join core_patient pat on orde.patient=pat.id ");
					query.append("where   pat.nameuppersurna<> 'DummyICABSurname' and pat.nameuppersurna is not null and "); 
					query.append("ext.wasprocess is null or ext.wasprocess=0 and ext.lkp_eventtype <>-1518");
				}
				else
				{
					query.append("select id,null,sys_creation_datetime as DT "+
								"from schl_externalsy where (wasprocess is null or wasprocess=0) and lkp_eventtype <>-1518");
				}
			}
			
			//WDEV-19160 RadioTherapy messages (VARIAN)
			if (triggers.contains(QueueType.RADIOTHERAPYSCHEDULING.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_radiotherapysc " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}
			
			//WDEV-19481 Inpatient Episode messages
			if (triggers.contains(QueueType.INPATIENTEPISODE.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_inpatientepiso " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}

			//WDEV-19576 Ward Master File messages
			if (triggers.contains(QueueType.WARDMASTERFILE.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_wardmessageque " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}

			//WDEV-19576 GP Practice Master File messages
			if (triggers.contains(QueueType.GPPRACTICEMASTERFILE.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_gppracticemess " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}

			//WDEV-19576 MOS (Consultant) Master File messages
			if (triggers.contains(QueueType.MOSMASTERFILE.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_mosmessagequeu " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}

			//WDEV-19576 GP Master File messages
			if (triggers.contains(QueueType.GPMASTERFILE.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_gpmessagequeue " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}

			//WDEV-19704 Patient Elective List (TCI) messages
			if (triggers.contains(QueueType.ELECTIVELIST.getID()))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				query.append("select id,lkp_queuetype,sys_creation_datetime as DT " +
						"from adto_electivelistme " +
						"where (wasprocess is null or wasprocess=0) and (wasdiscard is null or wasdiscard=0)");
			}



			
			//WDEV-13985 change order by
			query.append(" order by DT");	

			Connection conn = factory.getJdbcConnection();
			PreparedStatement ps = conn.prepareStatement(query.toString());
			ResultSet rs = ps.executeQuery();
			if (rs.next())
			{
				event = new QueuedEventVo();
				event.setID(rs.getInt(1));
				if(rs.getObject(2)!=null)
				{
					event.setQueueType((QueueType)getLookupService().getLookupInstance(QueueType.class, rs.getInt(2)));
				}
			}
			rs.close();
			ps.close();
			conn.close();
		}
		catch (SQLException e)
		{
			LOG.error("Exception ignored getting next event", e);
		}
		return event;
	}



	public IHL7OutboundMessageHandler saveMessage(IHL7OutboundMessageHandler iEvent) throws StaleObjectException
	{
		if (iEvent == null)
			throw new RuntimeException("Cannot save null Event");
		
		DomainFactory factory = getDomainFactory();

		if(iEvent instanceof OrderChangeResponseVo)
		{
			OrderChangeResponseVo event = (OrderChangeResponseVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			OrderChangeResponseQueue domEvent=OrderChangeResponseVoAssembler.extractOrderChangeResponseQueue(factory, event);
			factory.save(domEvent);
			return OrderChangeResponseVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof IfPatientDocumentMessageVo)
		{
			IfPatientDocumentMessageVo event = (IfPatientDocumentMessageVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			PatientDocumentMessageQueue domEvent=IfPatientDocumentMessageVoAssembler.extractPatientDocumentMessageQueue(factory, event);
			factory.save(domEvent);
			return IfPatientDocumentMessageVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof DemographicFeedVo)
		{
			DemographicFeedVo event = (DemographicFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			DemographicsMessageQueue domEvent=DemographicFeedVoAssembler
				.extractDemographicsMessageQueue(factory, event);
			factory.save(domEvent);
			return DemographicFeedVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof EDAttendanceFeedVo)
		{
			EDAttendanceFeedVo event = (EDAttendanceFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			EdAttendanceMessageQueue  domEvent=EDAttendanceFeedVoAssembler
				.extractEdAttendanceMessageQueue(factory, event);
			factory.save(domEvent);
			return EDAttendanceFeedVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof InPatientADTFeedVo)
		{
			InPatientADTFeedVo event = (InPatientADTFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			InPatientADTMessageQueue  domEvent=InPatientADTFeedVoAssembler
				.extractInPatientADTMessageQueue(factory, event);
			factory.save(domEvent);
			return InPatientADTFeedVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof AppointmentMessageQueueVo)
		{
			AppointmentMessageQueueVo event = (AppointmentMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			AppointmentMessageQueue  domEvent=AppointmentMessageQueueVoAssembler.extractAppointmentMessageQueue(factory, event);
			factory.save(domEvent);
			return AppointmentMessageQueueVoAssembler.create(domEvent);
		}
		// WDEV-19160
		else if(iEvent instanceof RadioTherapySchedQueueVo)
		{
			RadioTherapySchedQueueVo event = (RadioTherapySchedQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			RadioTherapySchedQueue  domEvent=RadioTherapySchedQueueVoAssembler.extractRadioTherapySchedQueue(factory, event);
			factory.save(domEvent);
			return RadioTherapySchedQueueVoAssembler.create(domEvent);
		}
		// WDEV-19481
		else if(iEvent instanceof InpatientEpisodeQueueVo)
		{
			InpatientEpisodeQueueVo event = (InpatientEpisodeQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			InpatientEpisodeQueue  domEvent=InpatientEpisodeQueueVoAssembler.extractInpatientEpisodeQueue(factory, event);
			factory.save(domEvent);
			return InpatientEpisodeQueueVoAssembler.create(domEvent);
		}
		// WDEV-19576 Master File events
		else if(iEvent instanceof WardMessageQueueVo)
		{
			WardMessageQueueVo event = (WardMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			WardMessageQueue domEvent = WardMessageQueueVoAssembler.extractWardMessageQueue(factory, event);
			factory.save(domEvent);
			return WardMessageQueueVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof GPPracticeMessageQueueVo)
		{
			GPPracticeMessageQueueVo event = (GPPracticeMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			GPPracticeMessageQueue domEvent = GPPracticeMessageQueueVoAssembler.extractGPPracticeMessageQueue(factory, event);
			factory.save(domEvent);
			return GPPracticeMessageQueueVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof MOSMessageQueueVo)
		{
			MOSMessageQueueVo event = (MOSMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			MOSMessageQueue domEvent = MOSMessageQueueVoAssembler.extractMOSMessageQueue(factory, event);
			factory.save(domEvent);
			return MOSMessageQueueVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof GPMessageQueueVo)
		{
			GPMessageQueueVo event = (GPMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			GPMessageQueue domEvent = GPMessageQueueVoAssembler.extractGPMessageQueue(factory, event);
			factory.save(domEvent);
			return GPMessageQueueVoAssembler.create(domEvent);
		}
		// WDEV-19704
		else if(iEvent instanceof ElectiveListMessageQueueVo)
		{
			ElectiveListMessageQueueVo event = (ElectiveListMessageQueueVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			ElectiveListMessageQueue  domEvent = ElectiveListMessageQueueVoAssembler.extractElectiveListMessageQueue(factory, event);
			factory.save(domEvent);
			return ElectiveListMessageQueueVoAssembler.create(domEvent);
		}
		
		
		else 
		{
			throw new RuntimeException("Cannot determine event type for saving");
		}
	}

	public void processSpecimenWithoutInvestigations(OrderSpecimenRefVo specimen)
	{
		if(specimen==null)
			return;
		LOG.error("processSpecimenWithoutInvestigations"+specimen.getID_OrderSpecimen());

		DomainFactory factory = getDomainFactory();
		OrderSpecimen orderSpecimen =  (OrderSpecimen)factory.getDomainObject(specimen);
		if(orderSpecimen.getInvestigations()==null||orderSpecimen.getInvestigations().size()==0)
		{
			orderSpecimen.setWasProcessed(true);
			try
			{
				factory.save(orderSpecimen);
			}catch (StaleObjectException e)
			{
				LOG.error("StaleObjectException processSpecimenWithoutInvestigations "+specimen.getID_OrderSpecimen());
			}
			
		}
	}

	
}
