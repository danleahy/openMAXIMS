//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Mara Iroaie using IMS Development Environment (version 1.80 build 5003.20929)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.pathways.domain.impl;

import java.util.ArrayList;
import java.util.List;
import ims.configuration.PathwayEntityEvent;
import ims.configuration.gen.ConfigFlag;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.domain.base.impl.BaseEntityEventMapImpl;
import ims.pathways.vo.EventLiteVoCollection;
import ims.pathways.vo.PathwayEntityEventMapVo;
import ims.pathways.vo.PathwayEntityEventMapVoCollection;
import ims.pathways.vo.domain.EventLiteVoAssembler;

public class EntityEventMapImpl extends BaseEntityEventMapImpl
{

	private static final long serialVersionUID = 1L;

	/**
	* Returns a list of all instantiation objects
	*/
	public String[] listBOEntities()
	{
		DomainFactory factory = getDomainFactory();
		
		List boList = factory.getDomainClasses();
	
		String[] result = new String[boList.size()];
		
		for (int i = 0; i < boList.size(); i++)
		{
			result[i] = extractBoName((String) boList.get(i));
		}
		return result;			
	}
	
	private String extractBoName(String bo)
	{
		int indexOfTheastDot = bo.lastIndexOf(".");		
		String boName = bo.substring(indexOfTheastDot + 1, bo.length());
		
		return boName;
	}

	/**
	* List events by the search criteria
	*/
	public EventLiteVoCollection listEvents(String textSupplied)
	{
		DomainFactory factory = getDomainFactory();
		
		String query = " select events From Event as events left join events.status as status ";
		StringBuilder conditions = new StringBuilder();
		ArrayList<String> marques = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		if (textSupplied != null)
		{
			conditions.append(" events.upperName like :text and status.text = :activeStatus "); //WDEV-20219 UPPER(events.name)
			marques.add("text");
			values.add(textSupplied.toUpperCase() + "%");
			marques.add("activeStatus");
			values.add(PreActiveActiveInactiveStatus.ACTIVE.toString());
		}
		
		if (marques.size() > 0)
		{
			query += " where ";
		}
		
		query += conditions.toString();
		query += " order by events.name asc  ";

		List<?> listEvents = factory.find(query, marques, values);
		
		return EventLiteVoAssembler.createEventLiteVoCollectionFromEvent(listEvents);
	}

	public PathwayEntityEventMapVoCollection listPathwayEntityEvents()
	{
		PathwayEntityEventMapVoCollection pathwayEntityEventMapVoCollection = new PathwayEntityEventMapVoCollection();
		DomainFactory factory = getDomainFactory();
		String query = " select entityEvents, event From PathwayEntityEvent as entityEvents, Event as event where (event.id = (entityEvents.event)) order by entityEvents.entityName asc ";
		String query2 = " select entityEvents From PathwayEntityEvent as entityEvents where event is null order by entityEvents.entityName asc ";
		List<?> pathwayEntityEventList = factory.find(query);
		List<?> pathwayEntityEventList2 = factory.find(query2);
		
		for (int i = 0; i< pathwayEntityEventList.size(); i++)
		{
			PathwayEntityEventMapVo record =convertPathwayEntityEventBoToPathwayEntityEventMapVo((PathwayEntityEvent)((Object[]) pathwayEntityEventList.get(i))[0]);
			record.setEvent(EventLiteVoAssembler.create((Event) ((Object[]) pathwayEntityEventList.get(i))[1]));
			pathwayEntityEventMapVoCollection.add(record);
		}

		for (int i = 0; i< pathwayEntityEventList2.size(); i++)
		{
			PathwayEntityEventMapVo record =convertPathwayEntityEventBoToPathwayEntityEventMapVo((PathwayEntityEvent)pathwayEntityEventList2.get(i));
			pathwayEntityEventMapVoCollection.add(record);
		}
		
		return pathwayEntityEventMapVoCollection;
	}

	/**
	* Saves the given Pathway Entity
	*/
	public PathwayEntityEventMapVo savePathwayEntity(PathwayEntityEventMapVo pathwayEntity)throws StaleObjectException
	{
		if (pathwayEntity == null)
			throw new CodingRuntimeException("Cannot save a null user VO");
			
		if(!pathwayEntity.isValidated())
			throw new CodingRuntimeException("Cannot Save because there are validation errors");
		
		DomainFactory factory = getDomainFactory();
		
		PathwayEntityEvent doPathwayEntityEvent = convertEntityEventMapVoToPathwayEntityEventBo(pathwayEntity);
		if (pathwayEntity.getVersionIsNotNull() && !pathwayEntity.getVersion().equals(doPathwayEntityEvent.getVersion()))
			throw new StaleObjectException(doPathwayEntityEvent, ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue().toString());
		factory.save(doPathwayEntityEvent);
		doPathwayEntityEvent = (PathwayEntityEvent) factory.getDomainObject(PathwayEntityEvent.class, doPathwayEntityEvent.getId());

		return convertPathwayEntityEventBoToPathwayEntityEventMapVo(doPathwayEntityEvent);
	}

	private PathwayEntityEventMapVo convertPathwayEntityEventBoToPathwayEntityEventMapVo(PathwayEntityEvent doPathwayEntityEvent)
	{
		PathwayEntityEventMapVo pathwayEntity = new PathwayEntityEventMapVo();
		
		pathwayEntity.setId(doPathwayEntityEvent.getId());
		pathwayEntity.setVersion(doPathwayEntityEvent.getVersion());
		pathwayEntity.setEntity(doPathwayEntityEvent.getEntityName());
		pathwayEntity.setEventId(doPathwayEntityEvent.getEvent());
		pathwayEntity.setRule(doPathwayEntityEvent.getRule());
		pathwayEntity.setDescription(doPathwayEntityEvent.getDescription());
		pathwayEntity.setScheduledDateTimeField(doPathwayEntityEvent.getScheduledDateField());
		pathwayEntity.setActive(doPathwayEntityEvent.isActive());
		pathwayEntity.setTargetMethod(doPathwayEntityEvent.getTargetMethod());
		
		return pathwayEntity;
	}

	private PathwayEntityEvent convertEntityEventMapVoToPathwayEntityEventBo(PathwayEntityEventMapVo pathwayEntity)
	{
		DomainFactory factory = getDomainFactory();
		PathwayEntityEvent doPathwayEntityEvent= null;
		if (pathwayEntity.getId() == null)
			doPathwayEntityEvent = new PathwayEntityEvent(); 
		else
			doPathwayEntityEvent = (PathwayEntityEvent) factory.getDomainObject(PathwayEntityEvent.class, pathwayEntity.getId());
		
		doPathwayEntityEvent.setActive(pathwayEntity.getActive());
		doPathwayEntityEvent.setEntityName(pathwayEntity.getEntity());
		doPathwayEntityEvent.setEvent(pathwayEntity.getEventId());
		doPathwayEntityEvent.setRule(pathwayEntity.getRule());
		doPathwayEntityEvent.setDescription(pathwayEntity.getDescription());
		doPathwayEntityEvent.setScheduledDateField(pathwayEntity.getScheduledDateTimeField());
		doPathwayEntityEvent.setTargetMethod(pathwayEntity.getTargetMethod());
		
		return doPathwayEntityEvent;
	}

}
