//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Mara Iroaie using IMS Development Environment (version 1.80 build 5256.13787)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.pathways.domain.impl;

import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.CATSReferralFilterVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVoCollection;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceShortVoCollection;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.pathways.domain.base.impl.BasePatientPathwaysAwaitingValidationWorklistImpl;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.vo.PatientPathwayJourneyRefVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationSearchCriteriaVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationWorklistVo;
import ims.pathways.vo.PatientPathwaysAwaitingValidationWorklistVoCollection;
import ims.pathways.vo.domain.PatientPathwaysAwaitingValidationWorklistVoAssembler;

import java.util.ArrayList;
import java.util.List;
//import ims.RefMan.helper.CatsReferralManualClass;

public class PatientPathwaysAwaitingValidationImpl extends BasePatientPathwaysAwaitingValidationWorklistImpl
{

	private static final long serialVersionUID = 1L;

	public PatientPathwaysAwaitingValidationWorklistVoCollection getPathways(PatientPathwaysAwaitingValidationSearchCriteriaVo searchCriteria)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " and ";
		
		Boolean validationDateAdded = false;
		Boolean rttValidationAdded = false;
		
		 
		
		//WDEV-21431 (Following code commented out and replaced below)
//		StringBuffer hql = new StringBuffer(" select pathways from PatientPathwayJourney as pathways left join pathways.currentClock as cc ");
//		StringBuffer hqlConditions = new StringBuffer(" cc is not null and cc.stopDate is null and (pathways.isRIE is null or pathways.isRIE = 0) ");
//		
//		//WDEV-21431
//		
//		if (searchCriteria != null && searchCriteria.getStartDateIsNotNull() && Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
//		{
//			hqlConditions.append("and pathways.nextValidationDate is not null");
//			validationDateAdded = true;
//			
//			hqlConditions.append(andStr);
//			
//			hqlConditions.append(" pathways.nextValidationDate >= :fromDate ");
//			markers.add("fromDate");
//			DateTime fromDateTime = new DateTime( searchCriteria.getStartDate(), new Time(0, 0));
//			values.add(fromDateTime.getJavaDate());
//			
//			andStr = " and ";
//		}
//		
//		if (searchCriteria != null && searchCriteria.getEndDateIsNotNull() && Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
//		{
//			if (Boolean.FALSE.equals(validationDateAdded))
//			{
//				hqlConditions.append("and pathways.nextValidationDate is not null");
//				validationDateAdded = true;
//			}
//			
//			hqlConditions.append(andStr);
//			
//			hqlConditions.append(" pathways.nextValidationDate <= :toDate ");
//			markers.add("toDate");
//			DateTime toDateTime = new DateTime( searchCriteria.getEndDate(), new Time(0, 0));
//			values.add(toDateTime.getJavaDate());
//			values.add(searchCriteria.getEndDate());
//			andStr = " and ";
//		}
//		
//		//WDEV-21155
//		hqlConditions.append("and pathways.validationCompletedDT is null and pathways.validationCompletedBy is null ");
//		
//		if (searchCriteria != null &&  Boolean.TRUE.equals(searchCriteria.getRttIncluded()))
//		{
//			hqlConditions.append(andStr);
//			
//			hql.append(" left join pathways.currentClock as cc left join cc.currentRTTStatus as crtts ");
//			hqlConditions.append(" (pathways.nextValidationDate >= :notValidatedStartDate and pathways.nextValidationDate <= :notValidatedEndDate)  
//		or (pathways.nextValidationDate is null and  crtts.statusDateTime is not null and  crtts.statusDateTime >= :startDate and crtts.statusDateTime <= :endDate) ");
//			
//			markers.add("notValidatedStartDate");
//			DateTime notValidatedStartDate = new DateTime();
//			values.add(notValidatedStartDate.addDays(-(searchCriteria.getNotValidatedNoOfWeeks() * 7)).getJavaDate());
//			
//			markers.add("notValidatedEndDate");
//			values.add(new DateTime().getJavaDate());
//			
//			markers.add("startDate");
//			DateTime startDate = new DateTime();
//			values.add(startDate.addDays(-(searchCriteria.getNoOfWeeks() * 7)).getJavaDate());
//			
//			markers.add("endDate");
//			values.add(new DateTime().getJavaDate());
//	
//			andStr = " and ";
//			rttValidationAdded = true;
//		}
//		
//		if (hqlConditions != null && hqlConditions.length() > 0)
//		{
//			hqlConditions.insert(0, " where ");
//		}
//		
//		if (Boolean.TRUE.equals(validationDateAdded))
//		{
//			hqlConditions.append(" order by pathways.nextValidationDate desc");	
//		}
//		else if (Boolean.TRUE.equals(rttValidationAdded))
//		{
//			hqlConditions.append(" order by crtts.statusDateTime desc");	
//		}
//
//		List<?> list = getDomainFactory().find(hql.append(hqlConditions.toString()).toString(), markers, values);
//		
//		return PatientPathwaysAwaitingValidationWorklistVoAssembler.createPatientPathwaysAwaitingValidationWorklistVoCollectionFromPatientPathwayJourney(list);

		
		//WDEV-21431 Code below replaces commented out code above
		// Note that HQL query has been vastly changed to accommodate new requirement to list referral service for selected pathways
		
		String serviceIds = "";
		if (searchCriteria != null)
		{
			if (searchCriteria.getService() != null
					&& searchCriteria.getService().getID_Service() != null)
			{
				serviceIds = " and refdetails.service.id in (" + searchCriteria.getService().getID_Service().toString();
			}

			if (searchCriteria.getServices() != null
					&& searchCriteria.getServices().size() > 0)
			{
				for (ServiceShortVo service : searchCriteria.getServices())
				{
					if (service.getID_ServiceIsNotNull())
					{
						if (serviceIds == "")
						{
							serviceIds = " and refdetails.service.id in (" + service.getID_Service().toString();
						}
						else
						{
							serviceIds = serviceIds + "," + service.getID_Service().toString();						
						}	
					}
				}
			}

			if (serviceIds.length() > 0)
			{
				serviceIds = serviceIds + ")";
			}
		}
		//WDEV-2258
		StringBuffer hql = new StringBuffer("select pathways, service, cons "+
											" from CatsReferral as referral "+
											" left join referral.referralDetails as refdetails "+
											" left join refdetails.service as service "+
											" left join refdetails.consultant as cons "+
											" left join referral.journey as pathways "+
											" left join pathways.currentClock as cc ");

		StringBuffer hqlConditions = new StringBuffer("where pathways.validationCompletedDT is null "+
				" and pathways.validationCompletedBy is null "+
				" and (pathways.isRIE = 0 or pathways.isRIE is null) "+
				" and referral.rTTClockImpact = 1" +
				" and (service.isRIE = 0 or service.isRIE is null) " +
				" and refdetails.service.id is not null "+
				" and cc is not null "+
				" and cc.stopDate is null ");

		if (searchCriteria != null 
			&& searchCriteria.getStartDateIsNotNull() 
			&& Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
		{
			hqlConditions.append("and (pathways.nextValidationDate is not null");
			validationDateAdded = true;
			
			hqlConditions.append(" and (pathways.nextValidationDate >= :fromDate ");
			markers.add("fromDate");
			DateTime fromDateTime = new DateTime( searchCriteria.getStartDate(), new Time(0, 0));
			values.add(fromDateTime.getJavaDate());
		}

		if (searchCriteria != null 
				&& searchCriteria.getEndDateIsNotNull() 
				&& Boolean.FALSE.equals(searchCriteria.getRttIncluded()))
		{
			if (Boolean.FALSE.equals(validationDateAdded))
			{
				hqlConditions.append("and pathways.nextValidationDate is not null");
				validationDateAdded = true;
			}
			
			hqlConditions.append(" and pathways.nextValidationDate <= :toDate)) ");
			markers.add("toDate");
			DateTime toDateTime = new DateTime( searchCriteria.getEndDate(), new Time(0, 0));
			values.add(toDateTime.getJavaDate());
		}
		
		if (searchCriteria != null 
				&&  Boolean.TRUE.equals(searchCriteria.getRttIncluded()))
		{
			hqlConditions.append(andStr);
			
			hqlConditions.append(" ("+
								"("+
								"    	pathways.nextValidationDate is not null" +
								"	and pathways.nextValidationDate >= :notValidatedStartDate" +
								"	and pathways.nextValidationDate <= :notValidatedEndDate" +
								"	and (pathways.isRIE = 0 or pathways.isRIE is null)" +
								")"+
								" or "+
								"	(	 pathways.nextValidationDate is null "+
								"	and  refdetails.end18WW  is not null" + //WDEV-22258
								"	and  refdetails.end18WW >= :startDate" + //WDEV-22258
								"	and refdetails.end18WW <= :endDate" +	//WDEV-22258								
								"	and (pathways.isRIE = 0 or pathways.isRIE is null)"+
								"   )"+
								") ");
			
			markers.add("notValidatedStartDate");
			DateTime notValidatedStartDate = new DateTime();
			values.add(notValidatedStartDate.addDays(-(searchCriteria.getNotValidatedNoOfWeeks() * 7)).getJavaDate());
			
			markers.add("notValidatedEndDate");
			values.add(new DateTime().getJavaDate());
			
			markers.add("startDate");
			values.add(new ims.framework.utils.Date().getDate());
			
			markers.add("endDate");
			ims.framework.utils.Date startDate = new ims.framework.utils.Date();
			values.add(startDate.addDay((searchCriteria.getNoOfWeeks() * 7)).getDate());
				
			rttValidationAdded = true;
		}


		if (serviceIds != null && serviceIds.length() > 0)
		{
			hqlConditions.append(serviceIds);
		}

		//Sorting 
		if (Boolean.TRUE.equals(validationDateAdded))
		{
			hqlConditions.append(" order by pathways.nextValidationDate desc");	
		}
		else if (Boolean.TRUE.equals(rttValidationAdded))
		{
			hqlConditions.append(" order by refdetails.end18WW desc");	
		}

		if ((Boolean.TRUE.equals(validationDateAdded)) || (Boolean.TRUE.equals(rttValidationAdded)))
			hqlConditions.append(", refdetails.service.serviceName asc");
		else if (! (Boolean.TRUE.equals(validationDateAdded)) && ! (Boolean.TRUE.equals(rttValidationAdded)))
		{
			hqlConditions.append(" order by refdetails.service.serviceName asc");
		}


		
		hql = hql.append(hqlConditions.toString());
		List<?> hqlList = getDomainFactory().find(hql.toString(), markers, values);

		// Assemble PatientPathwaysAwaitingValidationWorklistVo from Pathway and Service (hqlList rray elements 0 and 1)
		PatientPathwaysAwaitingValidationWorklistVoCollection returnVoCollection = new PatientPathwaysAwaitingValidationWorklistVoCollection();
		for (Object object : hqlList)
		{
			Object[] array = (Object[])object;

			PatientPathwayJourney patientPathJourney = (PatientPathwayJourney)array[0];
			PatientPathwaysAwaitingValidationWorklistVo workListVo = PatientPathwaysAwaitingValidationWorklistVoAssembler.create(patientPathJourney);

			if (workListVo != null)
			{	
				Service service = (Service)array[1];
				ServiceShortVo serviceItem = ServiceShortVoAssembler.create(service);
				workListVo.setService(serviceItem);

				Hcp hcp = (Hcp)array[2];
				HcpLiteVo respHCP = HcpLiteVoAssembler.create(hcp);
				workListVo.setResponsibleConsultant(respHCP);
			}

			returnVoCollection.add(workListVo);

		} 
		
		return returnVoCollection;
		
		// End of WDEV-21431 changes
		
	}


	//WDEV-21155
	@Override
	public void savePatientPathwayJourney(PatientPathwaysAwaitingValidationWorklistVo patientPathwayJourneyVo) throws DomainInterfaceException, StaleObjectException
	{
		if(patientPathwayJourneyVo == null)
			throw new CodingRuntimeException("Invalid PatientPathwaysAwaitingValidationWorklistVo");

		DomainFactory factory = getDomainFactory();
		
		PatientPathwayJourney domPatientPathwayJourney = PatientPathwaysAwaitingValidationWorklistVoAssembler.extractPatientPathwayJourney(factory, patientPathwayJourneyVo);
		
		domPatientPathwayJourney.setLastValidationDate(domPatientPathwayJourney.getNextValidationDate());
		domPatientPathwayJourney.setNextValidationDate(null);
		
		factory.save(domPatientPathwayJourney);
	}

	//WDEV-21389
	@Override
	public CatsReferralListVo getCatsReferral(PatientPathwayJourneyRefVo journey)
	{
		if (journey == null)
			return null;

		DomainFactory factory = getDomainFactory();

		String hql = "select cr from CatsReferral as cr left join cr.journey as joy where  (cr.journey.id = " + journey.getID_PatientPathwayJourney() +")";
		
		CatsReferral referralList = (CatsReferral) factory.findFirst(hql);

		if (referralList != null)
			return CatsReferralListVoAssembler.create((CatsReferral) referralList);

		return null;
	}

	//WDEV-21389
	@Override
	public CareContextShortVo getCareContextShort(CareContextRefVo voCareContextRef)
	{
		if (voCareContextRef == null)
			throw new RuntimeException("Cannot get CareContextShortVo for null CareContextRefVo");

		CareContext doCareContext = (CareContext) getDomainFactory().getDomainObject(CareContext.class, voCareContextRef.getID_CareContext());
		return CareContextShortVoAssembler.create(doCareContext);
	}
	
	//WDEV-21431
	public ServiceShortVoCollection getReferralServices(String serviceName)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hqlJoins = new StringBuffer("select s from ReferralService rs left join rs.referralServices as s left join s.specialty as ss ");
		StringBuffer hql = new StringBuffer(" ");
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";
		
		if(serviceName != null)
		{
			hql.append(" s.upperName like :ServiceName ");
			markers.add("ServiceName");
			values.add(serviceName.toUpperCase() + "%");
			andStr = " and ";
		}
		
		if (markers.size() > 0)
			hql.insert(0, " where ");
		
		hql.append( " order by s.upperName asc" );
		
		List<?> list = factory.find(hqlJoins.append(hql.toString()).toString(), markers, values);
		
		return ServiceShortVoAssembler.createServiceShortVoCollectionFromService(list);

	}

	//WDEV-21431
	public ServiceShortVoCollection listServicesForLoggedHCP(HcpRefVo hcp)
	{
		if (hcp == null || hcp.getID_Hcp() == null)
			return null;
		
		ArrayList<String> paramName= new ArrayList<String>();
		ArrayList<Object> paramValue = new ArrayList<Object>();
		
		String query = "select s from Hcp as h left join h.serviceFunction as hsf left join hsf.service as s, ReferralService as rs left join rs.referralServices as rss where hsf.isActive = :isActive and s.id = rss.id and h.id = :HcpId order by s.upperName asc";
		
		paramName.add("HcpId");		
		paramValue.add(hcp.getID_Hcp());

		paramName.add("isActive");		
		paramValue.add(Boolean.TRUE);

		List serviceList = getDomainFactory().find(query, paramName, paramValue);
		
		return ServiceShortVoAssembler.createServiceShortVoCollectionFromService(serviceList);

	}

//	//WDEV-21431
//	@Override
//	public CatsReferralListManualAssemblyVoCollection listCATSReferrals(CATSReferralFilterVo voCATSFilter)
//	{
//		if (voCATSFilter == null)
//		{
//			throw new CodingRuntimeException("Invalid voCATSFilter");
//		}
//
////		String hqlSB = getBaseSelectQuery(bIncludeICPColumn, bIncludeELEColumn);
//		String hqlSB = getBaseSelectQuery(false, false);
//		hqlSB += "from CatsReferral as catsref ";
//		hqlSB += getBaseJoinQuery();
//		
//		ArrayList<String> markers = new ArrayList<String>();
//		ArrayList<Serializable> values = new ArrayList<Serializable>();
//	
//	
////		boolean isCaseSensitivePatIdSearch = ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue();  //WDEV-18817
////
//		StringBuffer sb = new StringBuffer();
//		String hqlJoin = "";
//		String andStr = "";
//		
//		if (voCATSFilter.getServiceIsNotNull() || (voCATSFilter.getServices() != null) 
//				&& voCATSFilter.getServices().size() > 0)
//		{
//			sb.append(andStr + " ( (refDetails.service.id in (" + getServicesIds(voCATSFilter) + ") ) ");
//		}
//
//
////		if(voCATSFilter.getPatientIsNotNull())
////		{
////			sb.append(" catsref.patient.id = :pat");
////			markers.add("pat");
////			values.add(voCATSFilter.getPatient().getID_Patient());
////			
////			sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
////			hqlSB+= " where ";
////			
////			hqlSB+= sb.toString();
////			
////			return assembleRecords(getDomainFactory().find(hqlSB.toString(), markers, values));
////		}
//		
////		if (voCATSFilter.getContractIsNotNull())
////		{
////			sb.append(andStr + " ( catsref.contract.id = :contra ) ");
////			markers.add("contra");
////			values.add(voCATSFilter.getContract().getID_ContractConfig());
////			andStr = " and ";
////		}
////		else if (voCATSFilter.getContractsForOrgIsNotNull())
////		{
////			StringBuffer sbContracts = new StringBuffer();
////			for (int cOrgs = 0 ; voCATSFilter.getContractsForOrgIsNotNull() && cOrgs < voCATSFilter.getContractsForOrg().size() ; cOrgs++)
////			{
////				sbContracts.append(voCATSFilter.getContractsForOrg().get(cOrgs).getID_ContractConfig());
////				if (cOrgs+1 < voCATSFilter.getContractsForOrg().size())
////					sbContracts.append(", ");
////			}
////
////			sb.append(andStr + " ( catsref.contract.id in (" + sbContracts.toString() + ") ) ");
////			andStr = " and ";
////		}
//
////		//WDEV-7447
////		if (voCATSFilter.getLocationIsNotNull())
////		{
////			sb.append(andStr + " ( refDetails.location.id = :loc ) ");
////			markers.add("loc");
////			values.add(voCATSFilter.getLocation().getID_Location());
////			andStr = " and ";
////		}
////		//wdev-13652
////		if(voCATSFilter.getTreatmentCenterIsNotNull())
////		{
////			sb.append(andStr + " ( catsref.nearestTreatmentCentre.id = :treatCenter ) ");
////			markers.add("treatCenter");
////			values.add(voCATSFilter.getTreatmentCenter().getLocation().getID_Location());
////			andStr = " and ";
////			
////		}
////		//---------------
//		
////		if (voCATSFilter.getServiceIsNotNull() || (voCATSFilter.getServices() != null) 
////				&& voCATSFilter.getServices().size() > 0)
////		{
////			sb.append(andStr + " ( (refDetails.service.id in (" + getServicesIds(voCATSFilter) + ") ) ");
////
////			sb.append(" or (catsref.isCAB = :cab2 and refDetails = null) ) ");
////			markers.add("cab2");
////			values.add(Boolean.TRUE);
////			andStr = " and ";
////		}
//		
////		if (voCATSFilter.getReviewTypeIsNotNull())
////		{
////			hqlJoin += " join catsref.currentReviewDetail as reviewedRecs ";
////
////			sb.append(andStr + " reviewedRecs.reviewType.id = :type");
////			markers.add("type");
////			values.add(voCATSFilter.getReviewType().getID());
////			andStr = " and ";
////		}
////		
////		if (voCATSFilter.getClinicTypeIsNotNull())
////		{
////			sb.append(andStr + " refDetails.function.id = :ct");
////			markers.add("ct");
////			values.add(voCATSFilter.getClinicType().getID_ServiceFunction());
////			andStr = " and ";
////		}
////		// WDEV-17895 isDad label has been removed
////		/*
////		if (voCATSFilter.getIsDADIsNotNull() 
////			&& voCATSFilter.getIsDAD().booleanValue())
////		{
////			sb.append(andStr + " refDetails.isDADReferral = :dad");
////			markers.add("dad");
////			values.add(Boolean.TRUE);
////			andStr = " and ";
////		}
////		 */
////		
////		if (voCATSFilter.getIsCABIsNotNull() 
////			&& voCATSFilter.getIsCAB().booleanValue())
////		{
////			sb.append(andStr + " catsref.isCAB = :cab");
////			markers.add("cab");
////			values.add(Boolean.TRUE);
////			andStr = " and ";
////		}
////
////		if (voCATSFilter.getIsManualIsNotNull() 
////			&& voCATSFilter.getIsManual().booleanValue())
////		{
////			sb.append(andStr + " catsref.isCAB = :cab");
////			markers.add("cab");
////			values.add(Boolean.FALSE);
////			andStr = " and ";
////		}
////
////		if (voCATSFilter.getDOSIsNotNull())
////		{
////			sb.append(andStr + " catsref.dOS.id = :dos");
////			markers.add("dos");
////			values.add(voCATSFilter.getDOS().getID_DirectoryofService());
////			andStr = " and ";
////		}
////
////		if (voCATSFilter.getNHSNumberIsNotNull())
////		{
////			hqlJoin += " join catsref.patient.identifiers as patids ";
////			
////			sb.append(andStr + " patids.type = :idType");
////			markers.add("idType");
////			values.add(getDomLookup(PatIdType.NHSN));
////			andStr = " and ";
////
////			sb.append(andStr + (!isCaseSensitivePatIdSearch ? "UPPER(patids.value)" : "patids.value") + " like :idValue"); //WDEV-18817
////			markers.add("idValue");
////			values.add((!isCaseSensitivePatIdSearch ? voCATSFilter.getNHSNumber().trim().toUpperCase() : voCATSFilter.getNHSNumber().trim()) + "%"); //WDEV-18817
////			andStr = " and ";
////		}
////
////		if (voCATSFilter.getExcludeProviderCancellationIsNotNull()
////			&& voCATSFilter.getExcludeProviderCancellation().booleanValue()
////			&& ( voCATSFilter.getStatus() == null
////				|| ( voCATSFilter.getStatusIsNotNull()
////						&& ! voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVIDER_CANCELLATION)) ))
////		{
////			sb.append(andStr + " catsref.currentStatus.referralStatus != :providerCancellation ");
////			markers.add("providerCancellation");
////			values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
////			andStr = " and ";
////		}
////		
////		if (voCATSFilter.getFromDateIsNotNull() && voCATSFilter.getToDateIsNotNull())
////		{
////			sb.append(andStr + " ( ( refDetails != null and refDetails.dateOfReferral between :fromdate and :todate )");
////			markers.add("fromdate");
////			values.add(new DateTime(voCATSFilter.getFromDate(), new Time("00:00:00")).getJavaDate() );
////			markers.add("todate");
////			values.add(new DateTime(voCATSFilter.getToDate(), new Time("23:59:59")).getJavaDate() );
////			andStr = " and ";
////
////			sb.append(" or (refDetails = null and catsref.isCAB = :cab1) )");
////			markers.add("cab1");
////			values.add(Boolean.TRUE);
////
////		}
////		else if (voCATSFilter.getFromDateIsNotNull() && voCATSFilter.getToDate() == null)
////		{
////			sb.append(andStr + " ( (refDetails = null and catsref.isCAB = :cab1) " +
////					"or (refDetails != null and refDetails.dateOfReferral >= :fromdate) ) ");
////			markers.add("cab1");
////			values.add(Boolean.TRUE);
////			markers.add("fromdate");
////			values.add(new DateTime(voCATSFilter.getFromDate(), new Time("00:00:00")).getJavaDate() );
////			andStr = " and ";
////			
////		}
////		else if (voCATSFilter.getFromDate() == null && voCATSFilter.getToDateIsNotNull())
////		{
////			sb.append(andStr + " ( (refDetails = null and catsref.isCAB = :cab1)" +
////				"or (refDetails != null and refDetails.dateOfReferral <= :todate) ) ");
////			markers.add("cab1");
////			values.add(Boolean.TRUE);
////			markers.add("todate");
////			values.add(new DateTime(voCATSFilter.getToDate(), new Time("23:59:59")).getJavaDate() );
////			andStr = " and ";
////		}
////	
////		//WDEV-19327 
////		if (voCATSFilter.getResponsibleHCP() != null)
////		{
////			sb.append(andStr +  " ( refDetails != null and m.id= :respHCP ) ");
////			markers.add("respHCP");
////			values.add(voCATSFilter.getResponsibleHCP().getIMosId());	
////			andStr = " and ";
////		}
////		
////		//start WDEV-20275
////		if (voCATSFilter.getReferralUrgencies() != null && voCATSFilter.getReferralUrgencies().size() > 0)
////		{
////			sb.append(andStr +  " ur.id in " + getReferralUrgenciesForSearch(voCATSFilter.getReferralUrgencies()));
////			andStr = " and ";
////		}
////		
////		if(voCATSFilter.getStatus() != null)
////		{
////			sb.append(andStr +  " catsref.currentStatus.referralStatus.id != :worklist ");
////			markers.add("worklist");
////			values.add(ReferralApptStatus.END_OF_CARE.getID());	
////			andStr = " and ";	
////		}		
////		//end WDEV-20275
////		
////		
////		//wdev-15109 //Comented because of this issue WDEV-19212 
////		//PatIdType dispIdType = PatIdType.getNegativeInstance(ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue()); 
////		//if (dispIdType == null)
////		//	sb.append(andStr + "  patidtype1.id = -9 ");
////		//else
////		//	sb.append(andStr + "  patidtype1.id = " + dispIdType.getID() );
////		//wdev-15109
//		
////		andStr = " and ";
////
//		List<?> refList = null;
////		
////		if (voCATSFilter.getStatusIsNotNull())
////		{
////			if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_REFERRAL_LETTER))
////				refList = domListAwaitingReferralLetter(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_TRIAGE))
////				refList = domListAwaitingTriage(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.CONSULTATION_APPOINTMENT_REQUIRED))
////				refList = domListConsAppointmentRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.OTHER_APPOINTMENTS_REQUIRED))
////				refList = domListOtherApptsRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVISIONAL_REJECTION))
////				refList = domListProvisionalRejection(hqlSB, sb, markers, values, andStr, voCATSFilter.getSecondOpinionReason(), hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_ACCEPTED))
////				refList = domListReferralAccepted(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_REJECTED))
////				refList = domListReferralRejected(hqlSB, sb, markers, values, andStr,voCATSFilter.getIsCAB(), hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_APPOINTMENTS))
////				refList = domListReviewAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REJECTED_INVESTIGATIONS))
////				refList = domListRejectedInvestigations(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRALS_PENDING_RESULTS))
////				refList = domListPendingResults(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FLAGGED_FOR_REVIEW))
////				refList = domListFlaggedForReview(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVIDER_CANCELLATION))
////				refList = domListProviderCancellation(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FURTHER_MANAGMENT_REQUIRED))
////				refList = domListFurtherManagementRequired(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FINAL_DISCHARGE_DOCUMENT_REQUIRED))
////				refList = domListFinalDischargeDocumentRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGED_REFERRALS))
////				refList = domListDischargeReferrals(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ORDERINV_ACCEPTED_APPT_REQUIRED))
////				refList = domListOrderInvAcceptedApptRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FIT_FOR_SURGERY_NEED_APPT))
////				refList = domListFitForSurgeryAndNeedAppointment(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_CANCELLED_APPOINTMENTS))
////				refList = domListReviewCancelledAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_DNA_APPOINTMENTS))
////				refList = domListReviewDNAAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.CAB_REFERRALS_TO_BE_ACCEPTED_ON_CAB))
////				refList = domListCABReferralsToBeAcceptedOnCAB(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ONWARD_REFERRAL_WORKLIST))
////				refList = domListOnwardReferralWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getOnwardReferralReason());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REPORTS_REQUIRED_WORKLIST))
////				refList = domListReportsRequiredWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getReportSubCategory());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGE_REPORT_WORKLIST))
////				refList = domListDischargeReportRequired(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.MY_ALLOCATED_WORKLIST))
////				refList = domListMyAllocatedWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getAllocatedTo());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FURTHER_MANAGEMENT_REQUIRED_TLT))
////				refList = domListFurtherManagementTLTRequired(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.NOT_FIT_OR_SUITABLE_FOR_SURGERY))
////				refList = domListNotFitOrUnsuitableForSurgery(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.RefMan_REPORTS_REQUIRED_WORKLIST))
////				refList = domListRefManReportsRequiredWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGED_TO_GP))
////				refList = domListDischargeToGPWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFER_BACK_TO_CONS_WORKLIST))
////				refList = domListReferBackToConsultantWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_CLINICAL_INFO))
////				refList = domListAwaitingClinicalInformationWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ACTIVE_MONITORING_REQ_APPOINTMENT))
////				refList = domListActiveMonitoringWorklistApptRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ACTIVE_MONITORING))
////				refList = domListActiveMonitoringWorklist(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.TWENTYFOUR_HOUR_POST_OP))
////				refList = domList24HourMonitoringWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getProcedure());
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_TRIAGE_WORKLIST))
////				refList = domListReferralTriageWorklist(hqlSB, sb, markers, values, andStr, hqlJoin);
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.OP_PROCEDURE_AWAITING_APPOINTMENT))    //wdev-13765
////				refList = domListopProcedureAawaittingAppointment(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType(),voCATSFilter); //wdev-13765
////			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.CONSULTATION_ACTIVITY_REQUIRED))    //WDEV-20643
////				refList = domListReferralConsultationActivityRequiredrefList(hqlSB, sb, markers, values, andStr, hqlJoin);
////			
////		}
////		else
////		{
//			if (hqlJoin != "")
//				hqlSB += hqlJoin;
//			
//			sb.append(andStr + " catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
//			hqlSB += " where ";
//			
//			hqlSB += sb.toString();
//			return assembleRecords(getDomainFactory().find(hqlSB.toString(), markers, values));
////		}
////		
////		if (refList == null || refList.size() == 0)
////			return null;
////		else
//		
////		return assembleRecords(getDomainFactory().find(hqlSB.toString(), markers, values));
////		return assembleRecords(refList);
//	}
	
	//WDEV-21431
	private String getBaseSelectQuery(Boolean includeICPColumn, Boolean includeELEColumn) 
	{
		//WDEV-19621
		String name = ims.configuration.ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue();
		ims.core.vo.lookups.PatIdType displayPatIDType = ims.core.vo.lookups.PatIdType.getNegativeInstance(name);
		
		//wdev-15109
		String hqlSB = "select new ims.RefMan.helper.CatsReferralManualClass( catsref.id, title1.text, pat1.name.surname, pat1.name.forename, " +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = -9 and p11_1.id = pat1.id)) as ANY_NHS, " +
		" (select max(p211_1.value) from Patient as p111_1 left join p111_1.identifiers as p211_1 where (p211_1.type = -9 and p211_1.verified = 1 and p111_1.id = pat1.id)) as VERIFIED_NHS," +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = " + displayPatIDType.getID() + " and p11_1.id = pat1.id)) , " + //WDEV-19621
		" pat1.dod, ";
		//wdev-15109

		if (includeICPColumn)
			hqlSB+="(select max(icp.careContext.id) from PatientICP as icp where icp.careContext.id = catsref.careContext.id),";//WDEV-12965
		else
			hqlSB+= "catsref.id, ";
		
		if (includeELEColumn)
			hqlSB+="(select max(ele.id) from PatientElectiveList as ele where ele.referral.id = catsref.id),";//WDEV-18389
		else
			hqlSB+= "catsref.id, ";
			
		hqlSB+="refDetails.dateOfReferral, catsref.isCAB, loc1.name, service1.serviceName, catsref.isFlaggedForReview, refDetails.end18WW, catsref.isCurrentlyAllocated, " +
		"catsref.hasInvestigations, addinv.id, refstat1.id, refstat1.text, catsref.hasAppointments, " +
		"appt1.apptStatus.id, appt1.appointmentDate, appt1.apptStartTime, pat1.associatedPatient.id , refDetails.dateReferralReceived, catsref.hasDocuments, catsref.hasReferralLetter, refDetails.endDateKPI, ur.id, ur.text, triageOutcomeStatus.id, triageOutcomeStatus.text, (select max(triagePendingDiagnosticResult.id) from TriageOutcome as triageOutcome left join triageOutcome.triagePendingDiagnosticResult as triagePendingDiagnosticResult where (triageOutcome.catsReferral.id= catsref.id)), catsref.rTTClockImpact ) ";	//wdev-19673 //WDEV-20880
		return hqlSB;
	}
	
	//WDEV-21431
	private String getBaseJoinQuery() 
	{
//		return 	"left join catsref.patient as pat1 " +
//			"left join catsref.additionalInvApptsStatus as addinv " +
//			"left join pat1.name.title as title1 " +
//			"left join pat1.identifiers as patid1 " +
//			"left join patid1.type as patidtype1 " +
//			"left join catsref.referralDetails as refDetails " +
//			"left join refDetails.service as service1 " +
//			"left join refDetails.location as loc1 " +
//			"left join catsref.currentStatus as stat1 " +
//			"left join stat1.referralStatus as refstat1 " +
//			"left join catsref.consultationAppt as appt1 " + 
//			"left join refDetails.consultant as cons " +
//			"left join cons.mos as m " +
//			"left join catsref.urgency as ur " +
//			"left join catsref.triageOutcome as triageOutcome left join triageOutcome.triageOutcomeStatus as triageOutcomeStatus "+
//			"left join catsref.triageOutcome as triageOutcome left join triageOutcome.triagePendingDiagnosticResult as triagePendingDiagnosticResult "; //WDEV-20880
		return 	"left join catsref.referralDetails as refDetails " +
		"left join refDetails.service as service1 ";
	}
	
	
	//WDEV-21431
	private String getServicesIds(CATSReferralFilterVo criteria) 
	{
		if(criteria == null)
			return null;
		
		if(criteria.getService() == null && criteria.getServices() == null)
			return null;
		
		StringBuffer ids = new StringBuffer();
		
		if(criteria.getService() != null)
		{
			ids.append(criteria.getService().getID_Service());
		}
		else if(criteria.getServices() != null)
		{
			for( ServiceShortVo cfg : criteria.getServices())
			{
				if(cfg == null)
					continue;
				
				if(ids.length() > 0)
					ids.append(",");
				
				ids.append(cfg.getID_Service());
			}
		}
		
		return ids.toString();
	}

	
	//WDEV-21431
	private CatsReferralListManualAssemblyVoCollection assembleRecords(List<?> refList) 
	{
		CatsReferralListManualAssemblyVo voItem = null;
		CatsReferralListManualAssemblyVoCollection voColl = new CatsReferralListManualAssemblyVoCollection();
		for (int i = 0 ; i < refList.size(); i ++)
		{
//			CatsReferralManualClass doCats = (CatsReferralManualClass)refList.get(i);
			CatsReferral doCats = (CatsReferral)refList.get(i);
			voItem = new CatsReferralListManualAssemblyVo();
	
			voItem.setCatsReferralId(doCats.getId()); // getCatsReferralId());
//			voItem.setPatientName(doCats.getPatientName());
//			voItem.setVerifiedNHSNumber(doCats.getPatientnhsnum());
//			voItem.setAnyNHSNumber(doCats.getAnynhsnum());
//			voItem.setDisplayPatID(doCats.getDysplayPatID()); //WDEV-19621
//			voItem.setPatientDOD(doCats.getPatientDOD() != null ? new ims.framework.utils.Date(doCats.getPatientDOD()) : null);
//			voItem.setLinkedICPID(doCats.getLinkedICPID() != null ? Boolean.TRUE : null);
//			voItem.setLinkedELEID(doCats.getLinkedELEID() != null ? Boolean.TRUE : null);
//			voItem.setIsCAB(doCats.getisCAB());
//			voItem.setReferralLocationName(doCats.getReferralLocationName());
			voItem.setServiceName(doCats.getReferralDetails().getService().getServiceName()); //getServiceName());
//			voItem.setIsFlaggedForReview(doCats.getisFlaggedForReview());
//			voItem.setEnd18WW(doCats.getEnd18WW() != null ? new ims.framework.utils.Date(doCats.getEnd18WW()) : null);
//			voItem.setIsCurrentlyAllocated(doCats.getisCurrentlyAllocated());
//			voItem.setHasInvestigations(doCats.getHasInvestigations());
//			voItem.setCatsCurrentStatus(doCats.getCatsCurrentStatusId() != null ? new LookupInstVo(doCats.getCatsCurrentStatusId(), doCats.getCatsCurrentStatusText(), Boolean.TRUE) : null);
//			voItem.setAdditionalInvStatus(doCats.getAdditionalInvStatusID() != null ? new LookupInstVo(doCats.getAdditionalInvStatusID(), "", Boolean.TRUE) : null);
//			voItem.setHasApointments(doCats.getHasApointments());
//			voItem.setConsultationApptStatus(doCats.getConsAppointmentStatusID() != null ? new LookupInstVo(doCats.getConsAppointmentStatusID(), "", Boolean.TRUE) : null);
//			voItem.setConsAppointmentDate(doCats.getConsAppointmentDate() != null ? new ims.framework.utils.Date(doCats.getConsAppointmentDate()) : null);
//			voItem.setConsultationApptStartTime(doCats.getConsAppointmentStartTime() != null ? doCats.getConsAppointmentStartTime() : null);
//			voItem.setAssociatedPatientId(doCats.getAssociatedPatientId());
//			voItem.setDateReceived(doCats.getDateRecieved() != null ? new ims.framework.utils.Date(doCats.getDateRecieved()) : null);
//			voItem.setReferralDate(doCats.getReferralDate()!= null ? new ims.framework.utils.Date(doCats.getReferralDate()) : null);
//			voItem.setPatSurname(doCats.getPatientSurname());
//			voItem.setPatForename(doCats.getPatientForename());
//			voItem.setPatTitle(doCats.getPatientTitle());
//			voItem.setEndDateKPI(doCats.getEndDateKPI() != null ? new ims.framework.utils.Date(doCats.getEndDateKPI()) : null);
//			voItem.setReferralUrgency(doCats.getReferralUrgencyID() != null ? new LookupInstVo(doCats.getReferralUrgencyID(), doCats.getReferralUrgencyText(), Boolean.TRUE) : null);
//			voItem.setTriageOutcomeStatus(doCats.getTriageOutcomeStatusId() != null ? new LookupInstVo(doCats.getTriageOutcomeStatusId(), doCats.getTriageOutcomeStatusString(), Boolean.TRUE) : null);
//			voItem.setHasTriagePendingDiagnosticResult(doCats.getHasTriagePendingDiagnosticResult()!=null ? Boolean.TRUE: Boolean.FALSE); //WDEV-20880
//			
//			if (doCats.getEnd18WW() != null)
//			{
//				StringBuffer sb = new StringBuffer();
//				sb.append(voItem.getEnd18WW().getYear());
//				
//				if (voItem.getEnd18WW().getMonth() > 9)
//					sb.append(voItem.getEnd18WW().getMonth());
//				else
//				{
//					sb.append("0");
//					sb.append(voItem.getEnd18WW().getMonth());
//				}
//					
//				if (voItem.getEnd18WW().getDay() > 9)
//					sb.append(voItem.getEnd18WW().getDay());
//				else
//				{
//					sb.append("0");
//					sb.append(voItem.getEnd18WW().getDay());
//				}
//				voItem.setEnd18wwJulianDate(sb.toString());
//			}
//			
//			if( voItem.getConsultationApptStatusIsNotNull()	&& voItem.getConsultationApptStatus().equals(Status_Reason.BOOKED))
//			{
//				if (voItem.getConsAppointmentDateIsNotNull())
//				{
//					long lval = Date.daysBetween(new Date(voItem.getConsAppointmentDate()), new Date());
//
//					voItem.setDaysLeft(-(int)lval);
//				}
//			}
//			
//			voItem.setRTTClockImpact(doCats.getRTTClockImpact());

			voColl.add(voItem);
		}
		
		return voColl;	
	}

//	@Override
//	public CatsReferralListManualAssemblyVoCollection listCATSReferrals(CATSReferralFilterVo voCATSFilter)
//	{
//		// TODO Auto-generated method stub
//		return null;
//	}



}
