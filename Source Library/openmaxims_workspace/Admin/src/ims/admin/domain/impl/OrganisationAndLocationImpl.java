//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.22 build 50223.1030)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.helper.Keywords;
import ims.admin.vo.PrinterVo;
import ims.admin.vo.domain.PrinterVoAssembler;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.configuration.domain.objects.Printer;
import ims.core.resource.place.domain.objects.Clinic;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.ClinicRefVo;
import ims.core.resource.place.vo.LocSiteRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.ClinicListVo;
import ims.core.vo.ClinicListVoCollection;
import ims.core.vo.ClinicVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocMostVoCollection;
import ims.core.vo.LocShortMappingsVo;
import ims.core.vo.LocShortMappingsVoCollection;
import ims.core.vo.LocShortVo;
import ims.core.vo.LocShortVoCollection;
import ims.core.vo.LocSiteLiteVoCollection;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocSiteVo;
import ims.core.vo.LocSiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.OrgLiteVo;
import ims.core.vo.OrgLiteVoCollection;
import ims.core.vo.OrgShortVo;
import ims.core.vo.OrgShortVoCollection;
import ims.core.vo.OrganisationMinWithLocSitesVo;
import ims.core.vo.OrganisationMinWithLocSitesVoCollection;
import ims.core.vo.OrganisationVo;
import ims.core.vo.OrganisationVoCollection;
import ims.core.vo.domain.ClinicVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocShortMappingsVoAssembler;
import ims.core.vo.domain.LocShortVoAssembler;
import ims.core.vo.domain.LocSiteLiteVoAssembler;
import ims.core.vo.domain.LocSiteShortVoAssembler;
import ims.core.vo.domain.LocSiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.OrgLiteVoAssembler;
import ims.core.vo.domain.OrgShortVoAssembler;
import ims.core.vo.domain.OrganisationMinWithLocSitesVoAssembler;
import ims.core.vo.domain.OrganisationVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.QueueType;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.interfaces.IPrinter;
import ims.hl7adtout.domain.objects.WardMessageQueue;
import ims.ocrr.vo.lookups.OrderMessageStatus;
import ims.utils.Logging;
import ims.vo.ValueObjectRef;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

public class OrganisationAndLocationImpl extends DomainImpl implements ims.admin.domain.OrganisationAndLocation, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;
	static final Logger				LOGGER				= Logging.getLogger(OrganisationAndLocationImpl.class);
	private static final HashMap<String, LocShortVo>	REMOTE_LOC_CACHE	= new HashMap<String, LocShortVo>();

	/**
	 * List Organisations
	 */
	public ims.core.vo.OrganisationVoCollection listOrganisation(ims.core.vo.OrganisationVo organisation, Boolean excludeGPs, Boolean activeOnly)
	{
		List<?> orgs = listOrganisations(organisation, excludeGPs, activeOnly); //WDEV-20044
		OrganisationVoCollection voCollOrgs = OrganisationVoAssembler.createOrganisationVoCollectionFromOrganisation(orgs);
		
		return voCollOrgs;
	}
	//WDEV-20044
	private ims.core.vo.OrganisationMinWithLocSitesVoCollection listOrganisationLite(ims.core.vo.OrganisationMinWithLocSitesVo organisation, Boolean excludeGPs, Boolean activeOnly)
	{
		List<?> orgs = listOrganisations(null, excludeGPs, activeOnly);
		OrganisationMinWithLocSitesVoCollection voCollOrgs = OrganisationMinWithLocSitesVoAssembler.createOrganisationMinWithLocSitesVoCollectionFromOrganisation(orgs);
		
		return voCollOrgs;
	}
	
	private List<?> listOrganisations(ims.core.vo.OrganisationVo organisation, Boolean excludeGPs, Boolean activeOnly)
	{
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o ";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
		if (organisation == null)
			organisation = new OrganisationVo();

		List orgs = null;

		condStr.append(andStr + " o.type.id != " + OrganisationType.SUPPLIER.getID());
		andStr = " and ";

		if (excludeGPs != null && excludeGPs.booleanValue())
		{
			condStr.append(andStr + " (o.type != :GP or o.type.id is null)");
			markers.add("GP");
			values.add(getDomLookup(OrganisationType.GPP));
			condStr.append(andStr + " (o.type != :PCT or o.type.id is null)");
			markers.add("PCT");
			values.add(getDomLookup(OrganisationType.NHS_PCT));
			andStr = " and ";

		}

		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " o.isActive = :isActive");
			markers.add("isActive");
			values.add(activeOnly);
			andStr = " and ";
		}

		if (organisation.getParentOrganisation() == null)
		{
			condStr.append(andStr + " o.parentOrganisation is null");

			hql += " where ";
			hql += condStr.toString();
			
			hql += " order by o.name";

			orgs = factory.find(hql, markers, values);
		}
		else
		{
			condStr.append(" o.parentOrganisation.id = :parentOrg");
			markers.add("parentOrg");
			values.add(organisation.getParentOrganisation().getID_Organisation());
			andStr = " and ";

			hql += " where ";
			hql += condStr.toString();
			
			hql += " order by o.name";

			orgs = factory.find(hql, markers, values);
		}
		return orgs;
	}	
	public OrgShortVoCollection listOrganisationsShort(OrgShortVo filter)
	{
		List orgs = listDomOrganisation(filter);

		OrgShortVoCollection voCollOrgShorts = OrgShortVoAssembler.createOrgShortVoCollectionFromOrganisation(orgs);
		voCollOrgShorts.sort();
		return voCollOrgShorts;
	}

	public OrgLiteVoCollection listOrganisationsLite(OrgShortVo filter)
	{
		List orgs = listDomOrganisation(filter);
		
		OrgLiteVoCollection voCollOrg = OrgLiteVoAssembler.createOrgLiteVoCollectionFromOrganisation(orgs);
		voCollOrg.sort();
		return voCollOrg;
	}

	private List listDomOrganisation(OrgShortVo filter)
	{
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o where o.type.id != " + OrganisationType.SUPPLIER.getID() + " and o.type.id != " + OrganisationType.GPP.getID();//wdev-5364
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		List orgs = null;

		if (filter.getNameIsNotNull() && filter.getName().length() > 0)
		{
			condStr.append(" o.upperName like :OrgName");
			markers.add("OrgName");
			values.add(filter.getName().toUpperCase() + "%");
			andStr = " and ";

			hql += andStr + condStr.toString();
			orgs = factory.find(hql, markers, values);
		}
		else
		{
			orgs = factory.find(hql);
		}
		return orgs;
	}

	private void populateLocationCollection(LocMostVoCollection voCollLocationSite, LocMostVoCollection voCollLocations)
	{
		for (int i = 0; i < voCollLocationSite.size(); i++)
		{
			if (voCollLocationSite.get(i).getIsVirtualIsNotNull()
				&& ! voCollLocationSite.get(i).getIsVirtual().booleanValue()) //wdev-2730
			{
				voCollLocations.add(voCollLocationSite.get(i));
			}
			populateLocationCollection(voCollLocationSite.get(i).getLocations(), voCollLocations);
		}

	}

	public ims.core.vo.OrganisationVo saveOrganisation(ims.core.vo.OrganisationVo organisation) throws UniqueKeyViolationException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		HashMap<?,?> map = new HashMap<Object, Object>();
		Organisation doOrg = OrganisationVoAssembler.extractOrganisation(factory, organisation,map);
		
		if (!(organisation.getTypeIsNotNull() && organisation.getType().equals(OrganisationType.GPP)))
		{
			// uniqueness constraint removed form the database - must be implemented in code. 
			if (checkOrganisationNameisUnique(organisation.getName(), organisation) != null)
			{
				throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
			}
		}
		
		try
		{
			doOrg.setUpperNames();
			factory.save(doOrg);
			
			//WDEV-10574
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doOrg, "codeMappings", organisation.getCodeMappings(), "getName");
			
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (organisation.getRelatedOrganisationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(organisation.getRelatedOrganisations(), map, factory);
			}
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (organisation.getLocationSitesIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(organisation.getLocationSites(), map, factory);

			}
			
			throw new UniqueKeyViolationException("A record with the same details already exists, Please change", e);
		}
		return OrganisationVoAssembler.create(doOrg);
	}

	
	private void checkChildsForDuplicateTaxonoy(LocSiteVoCollection childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
			if (childs == null || doMap==null)
				return;
			
			for (int i = 0 ; i < childs.size(); i++)
			{
				LocSiteVo locMostVo = childs.get(i);
				Object doObj = doMap.get(locMostVo);
				//If doObj is null it means that nothing has changed in that record and hibernate didn't instantiated that record
				if (doObj instanceof Location)
				{
					//I'm using new Location(((Location) doObj).getId(),((Location) doObj).getVersion()) because LocSite extends Location 
					//and it's possible to have a Location with same mappings and not a LocSite.
					Location loc =(Location) doObj;
					String dupMessage = Keywords.checkDuplicateTaxonomy(factory,new Location(loc.getId(),loc.getVersion()), "codeMappings", locMostVo.getCodeMappings(), "getName");
					if (dupMessage!=null)
						throw new UniqueKeyViolationException(dupMessage);
				}
			}
	}
	
	private void checkChildsForDuplicateTaxonoy(OrganisationVoCollection  childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
		if (childs == null || doMap==null)
			return;
		
		for (int i = 0 ; i < childs.size(); i++)
		{
			OrganisationVo orgVo = childs.get(i);
			Object doObj = doMap.get(orgVo);
			//If doObj is null it means that nothing changed in that record and hibernate didn't instantiated that record
			if (doObj instanceof Organisation)
			{
				String dupMessage = Keywords.checkDuplicateTaxonomy(factory,doObj, "codeMappings", orgVo.getCodeMappings(), "getName");
				if (dupMessage!=null)
					throw new UniqueKeyViolationException(dupMessage);
			}
		}
	}
	

	/**
	 * Save a location site and any locations
	 */
	public ims.core.vo.LocSiteVo saveLocationSite(ims.core.vo.LocSiteVo locationSite) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!locationSite.isValidated())
			throw new DomainRuntimeException("Location Site not Validated.");
			
		DomainFactory factory = getDomainFactory();
		HashMap<?,?> map = new HashMap<Object, Object>();
		LocSite doLocationSite = LocSiteVoAssembler.extractLocSite(factory, locationSite,map);

//		 uniqueness constraint removed form the database - must be implemented in code. 
		if (checkLocationSiteNameIsUnique(locationSite.getName(), locationSite.getID_Location())!= null )
		{
			throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
		}
		
		try
		{
			doLocationSite.setUpperNames();
			factory.save(doLocationSite);
			//WDEV-10574
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocationSite, "codeMappings", locationSite.getCodeMappings(), "getName");
			
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (locationSite.getLocationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(locationSite.getLocations(), map, factory);

			}

			throw new UniqueKeyViolationException("An Location Site with this name already exists, Please change", e);			
		}
		
		return LocSiteVoAssembler.create(doLocationSite);
	}

	

	/**
	 * Save Location
	 */
	public LocMostVo saveLocation(LocMostVo location) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!location.isValidated())
			throw new DomainRuntimeException("Location not Validated.");

		DomainFactory factory = getDomainFactory();

		HashMap<?,?> map = new HashMap<Object, Object>();
		Location doLocation = LocMostVoAssembler.extractLocation(factory, location,map);

		// uniqueness constraint removed form the database - must be implemented in code. 
		if (checkLocationNameIsUnique(location.getName(), location.getID_Location())!= null )
		{
			throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
		}
		
		try
		{
			doLocation.setUpperNames();
			factory.save(doLocation);
			
			// wdev-6404 Clear REMOTE_LOC_CACHE on save
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocation, "codeMappings", location.getCodeMappings(), "getName");
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (location.getLocationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(location.getLocations(), map, factory);

			}
		

			throw new UniqueKeyViolationException("An Location with this name already exists, Please change", e);			
		}
		
		//WDEV-19576 Ward Master File HL7 message
		LocMostVo assembledLoc = LocMostVoAssembler.create(doLocation);
		triggerWardMasterFileEvent(assembledLoc);
		
		return assembledLoc;
	}

	//WDEV-19576 MFNM05 HL7 message processing for Ward Master File event
	public void triggerWardMasterFileEvent(LocationRefVo locRefVo) throws StaleObjectException
	{
		if(locRefVo!=null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.WARDMASTERFILE.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				WardMessageQueue messageQueue = new WardMessageQueue();
				messageQueue.setWard((Location)factory.getDomainObject(locRefVo));
				messageQueue.setProviderSystem(providerSystem);
				messageQueue.setWasProcessed(Boolean.FALSE);
				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				messageQueue.setMsgType(getDomLookup(MsgEventType.M05));
				messageQueue.setQueueType(getDomLookup(QueueType.WARDMASTERFILE));
				factory.save(messageQueue);
			}
			
		}
	}


	private void checkChildsForDuplicateTaxonoy(LocMostVoCollection childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
		for (int i = 0 ; i < childs.size(); i++)
		{
			LocMostVo locMostVo = childs.get(i);
			Object doObj = doMap.get(locMostVo);
			if (doObj instanceof Location)
			{
				String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doObj, "codeMappings", locMostVo.getCodeMappings(), "getName");
				if (dupMessage!=null)
					throw new UniqueKeyViolationException(dupMessage);
			}
		}
	}

	/**
	 * Move an existing organisation to a new location
	 */
	@SuppressWarnings("unchecked")
	public void moveOrganisation(ims.core.vo.OrganisationVo orgToMove, ims.core.vo.OrganisationVo currentParent, ims.core.vo.OrganisationVo destParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Organisation doOrgToMove = OrganisationVoAssembler.extractOrganisation(factory, orgToMove);
		Organisation doOrgCurrentParent = OrganisationVoAssembler.extractOrganisation(factory, currentParent);
		Organisation doOrgDestParent = OrganisationVoAssembler.extractOrganisation(factory, destParent);

		if (doOrgCurrentParent != null)
		{
			doOrgToMove.setParentOrganisation(null);
			doOrgCurrentParent.getRelatedOrganisations().remove(doOrgToMove);
		}
		if (doOrgDestParent != null)
		{
			doOrgToMove.setParentOrganisation(doOrgDestParent);
			doOrgDestParent.getRelatedOrganisations().add(doOrgToMove);
		}
		doOrgToMove.setUpperNames();
		factory.save(doOrgToMove);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
	}

	/**
	 * Move a location site
	 */
	@SuppressWarnings("unchecked")
	public void moveLocSite(ims.core.vo.LocSiteVo locSiteToMove, OrgShortVo currentParent, OrgShortVo destParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		LocSite doLocSite = LocSiteVoAssembler.extractLocSite(factory, locSiteToMove);
		Organisation doOrgCurrentParent = OrgShortVoAssembler.extractOrganisation(factory, currentParent);
		Organisation doOrgDestParent = OrgShortVoAssembler.extractOrganisation(factory, destParent);

		//strange hibernate(v3) error was being generated here and session refresh problems so hence the factory.refresh() calls
		doLocSite.setParentOrganisation(doOrgDestParent);
		doOrgCurrentParent.getLocationSites().remove(doLocSite);
		factory.refresh(doOrgCurrentParent);
		doOrgDestParent.getLocationSites().add(doLocSite);
		factory.save(doLocSite);
		factory.refresh(doOrgCurrentParent);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();		
	}

	/**
	 * moveLocation
	 */
	@SuppressWarnings("unchecked")
	public void moveLocation(LocMostVo locToMove, ims.core.vo.LocSiteVo locSiteCurrentParent, LocMostVo locCurrentParent, ims.core.vo.LocSiteVo locSiteDestParent, LocMostVo locDestParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Location doLocToMove = LocMostVoAssembler.extractLocation(factory, locToMove);
		Location doLocCurrentParent = LocMostVoAssembler.extractLocation(factory, locCurrentParent);
		Location doLocDestParent = LocMostVoAssembler.extractLocation(factory, locDestParent);

		LocSite doLocSiteCurrentParent = LocSiteVoAssembler.extractLocSite(factory, locSiteCurrentParent);
		LocSite doLocSiteDestParent = LocSiteVoAssembler.extractLocSite(factory, locSiteDestParent);

		if (doLocCurrentParent != null)
		{
			doLocToMove.setParentLocation(null);
			if (doLocCurrentParent.getLocations().size() > 0)
				doLocCurrentParent.getLocations().remove(doLocToMove);
		}
		else if (doLocSiteCurrentParent != null)
		{
			doLocToMove.setParentLocation(null);
			if (doLocSiteCurrentParent.getLocations().size() > 0)
				doLocSiteCurrentParent.getLocations().remove(doLocToMove);
		}

		if (locSiteDestParent != null)
		{
			doLocToMove.setParentLocation(doLocSiteDestParent);
			doLocSiteDestParent.getLocations().add(doLocToMove);
		}
		else if (locDestParent != null)
		{
			doLocToMove.setParentLocation(doLocDestParent);
			doLocDestParent.getLocations().add(doLocToMove);
		}
		if(doLocCurrentParent != null)
			factory.refresh(doLocCurrentParent);
		if(doLocSiteCurrentParent != null)
			factory.refresh(doLocSiteCurrentParent);
		
		factory.save(doLocToMove);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();

	}

	public OrganisationVo getOrganisation(Integer id)
	{
		DomainFactory factory = getDomainFactory();
		return OrganisationVoAssembler.create((Organisation) factory.getDomainObject(Organisation.class, id));
	}

	public LocSiteVo getLocSite(Integer id)
	{
		DomainFactory factory = getDomainFactory();
		return LocSiteVoAssembler.create((LocSite) factory.getDomainObject(LocSite.class, id));
	}
	//wdev-12855
	public LocMostVo getLocMost(Integer id) 
	{
		DomainFactory factory = getDomainFactory();
		return LocMostVoAssembler.create((Location)factory.getDomainObject(Location.class, id));
	}
	public PrinterVo getPrinter(IPrinter printer)
	{
		if (printer == null)
			throw new CodingRuntimeException("printer cannot be null in method getPrinter");
			
		DomainFactory factory = getDomainFactory();
		return PrinterVoAssembler.create((Printer) factory.getDomainObject(Printer.class, printer.getIPrinterId()));
	}
	
	public void deleteOrganisation(OrganisationVo orgToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		Organisation doOrganisation = OrganisationVoAssembler.extractOrganisation(factory, orgToDelete);
		Organisation doParentOrg = doOrganisation.getParentOrganisation();
		if (doParentOrg != null)
		{
			doParentOrg.getRelatedOrganisations().remove(doOrganisation);
		}
		
		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doOrganisation);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Organization is in use and can not be deleted.");
		}
	}

	public void deleteLocation(LocMostVo locToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		Location doLocation = LocMostVoAssembler.extractLocation(factory, locToDelete);

		if (doLocation.getServices().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Services associated with this Location. Cannot delete.");
		}
		if (doLocation.getActivityLimitGroup().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Activity Limits associated with this Location. Cannot delete.");
		}

		Location doParentLocation = doLocation.getParentLocation();
		if (doParentLocation != null)
			doParentLocation.getLocations().remove(doLocation);

		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doLocation);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Location is in use and can not be deleted.");
		}
	}

	public void deleteLocSite(LocSiteVo locSiteToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		LocSite doLocSite = LocSiteVoAssembler.extractLocSite(factory, locSiteToDelete);

		if (doLocSite.getServices().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Services associated with this Location Site. Cannot delete.");
		}
		if (doLocSite.getActivityLimitGroup().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Activity Limits associated with this Location Site. Cannot delete.");
		}

		Organisation doParentOrganisation = doLocSite.getParentOrganisation();
		if (doParentOrganisation != null)
			doParentOrganisation.getLocationSites().remove(doLocSite);

		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doLocSite);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Location Site is in use and can not be deleted.");
		}
	}

	public LocMostVoCollection listLocation(LocMostVo locationFilter)
	{
		List locations;
		if (locationFilter == null)
		{
//			wdev-2730
			StringBuffer hql = new StringBuffer();
			hql.append(" from LocSite as ls");
			hql.append(" where");
			hql.append(" and ls.isActive =:active");
			hql.append(" and ls.isRIE is null");
			hql.append(" and ls.isVirtual =:virtual");

			locations = getDomainFactory().find(hql.toString(), new String[]{"active", "virtual"}, new Object[]{Boolean.TRUE, Boolean.FALSE});
		}
		else
		{
			locations = listLocationsByParentLocation(locationFilter.getType(),locationFilter.getParentLocation(),locationFilter.getIsActive(),locationFilter.getReferringHospital(),locationFilter.getTreatingHosp(),null, null); //WDEV-20395
		}
		
		return LocMostVoAssembler.createLocMostVoCollectionFromLocation(locations).sort();
	}
	
	/**
	 * Method wil step into the structure and retrieve from all sub-levels items that match the search criteria
	 * 
	 * @param type
	 * @param parentLocation
	 * @param isActive
	 * @param referringHospital
	 * @param treatingHosp
	 * @param name
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private List listLocationsByParentLocation(LocationType type, LocationRefVo parentLocation, Boolean isActive, Boolean referringHospital, Boolean treatingHosp, Boolean caseNoteFolderLocation, String name)
	{
		//WDEV-6887
		if(name != null)
		{
			String[] arr = null;
			if(name.contains("%"))
			{
				arr = name.split("%");
				if(arr.length > 0)
					name = arr[0] + "%";
				else
					name = "%";
			}
		}

		if(parentLocation == null)
			return listLocations(type, isActive, referringHospital, treatingHosp, name);
		
		
		String ids = getChildLocationsIdsForLocation(parentLocation.getBoId(),type!=null?new int[]{type.getID()}:null,isActive,referringHospital,treatingHosp,caseNoteFolderLocation,null,name,null);
		String hql = "select l from Location l where l.id in("+ids+")"; 
		return  getDomainFactory().find(hql);

		
//		DomainFactory factory = getDomainFactory();
//		Location doLocation = (Location) factory.getDomainObject(Location.class, parentLocation.getID_Location());
//		ArrayList listItems = new ArrayList();
//		buildLocationsList(doLocation, listItems, type, isActive, referringHospital, treatingHosp, caseNoteFolderLocation, name); //WDEV-20395
//
//		return listItems;
	}

//	private void buildLocationsList(Location location, ArrayList<Location> listItems, LocationType type, Boolean isActive, Boolean referringHospital, Boolean treatingHosp,Boolean caseNoteFolderLocation, String name) ////WDEV-20395
//	{
//		Iterator it = location.getLocations().iterator();
//		while(it.hasNext())
//		{
//			Location doLocation = (Location) it.next();
//			if(doLocation.getType().equals(getDomLookup(type)) 
//				&& doLocation.isIsActive().equals(isActive) 
//				&& (referringHospital == null || (doLocation.isReferringHospital() != null && doLocation.isReferringHospital().equals(referringHospital))) 
//				&& (treatingHosp == null || (doLocation.isTreatingHosp() != null && doLocation.isTreatingHosp().equals(treatingHosp))) 
//				&& (name == null || name.equals("%") || doLocation.getUpperName().indexOf(name.toUpperCase()) > -1)
//				&& (caseNoteFolderLocation == null || (doLocation.isCaseNoteFolderLocation() != null && doLocation.isCaseNoteFolderLocation().equals(caseNoteFolderLocation))) 
//				&& Boolean.FALSE.equals(doLocation.isIsVirtual())) //wdev-2730
//			{
//				listItems.add(doLocation);
//			}
//			
//			buildLocationsList(doLocation, listItems, type, isActive, referringHospital, treatingHosp, caseNoteFolderLocation, name);
//		}
//	}

	public LocMostVoCollection listLocSite(OrgShortVo organisation)
	{
		LocMostVoCollection voCollLocation = new LocMostVoCollection();
		DomainFactory factory = getDomainFactory();
		Organisation doOrganisation = (Organisation) factory.getDomainObject(Organisation.class, organisation.getID_Organisation());
		populateLocationCollection(LocMostVoAssembler.createLocMostVoCollectionFromLocation(doOrganisation.getLocationSites()), voCollLocation);
		return voCollLocation;
	}


	public LocSiteLiteVoCollection listLocSite(String locationName)
	{
		String location = locationName != null ? locationName.toUpperCase() + "%" : "%%";

		StringBuffer hql = new StringBuffer();
		hql.append(" from LocSite as ls");
		hql.append(" where");
		hql.append(" ls.upperName like :locationName");
		hql.append(" and ls.isActive =:active");
		hql.append(" and ls.isRIE is null");
		hql.append(" and ls.isVirtual =:virtual");//wdev-2730

		List list = getDomainFactory().find(hql.toString(), new String[]{"locationName", "active", "virtual"}, new Object[]{location, Boolean.TRUE, Boolean.FALSE});

		return LocSiteLiteVoAssembler.createLocSiteLiteVoCollectionFromLocSite(list);
	}
	
	public OrganisationVoCollection listRootOrgs()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return this.listOrganisation(filter, Boolean.TRUE, Boolean.TRUE);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see ims.admin.domain.OrganisationAndLocation#getLocationByLocalCode(java.lang.String,
	 *      ims.core.vo.lookups.LocationType)
	 */
	public LocShortVo getLocationByLocalCode(String localCode, LocationType codeSpecifier)
	{
		if (localCode == null || localCode.equals(""))
			return null;
		if (LOGGER.isInfoEnabled())
			LOGGER.info("Location reverse Lookup Call. localCode:" + localCode);

		if (REMOTE_LOC_CACHE.get(localCode) != null)
		{
			if (LOGGER.isInfoEnabled())
				LOGGER.info("Location reverse Lookup Cache Hit. localCode:" + localCode);
			return REMOTE_LOC_CACHE.get(localCode);
		}
		DomainFactory factory = getDomainFactory();

		String hql = null;
		List locs = null;

		if (codeSpecifier == null)
		{
			hql = " from Location l " +
			" join l.codeMappings as cm" +
			" where cm.taxonomyName = :taxType " + 
			" and cm.taxonomyCode = :localCode ";

			locs = factory.find(hql,new String[]{"taxType", "localCode"}, new Object[]{getDomLookup(TaxonomyType.PAS),localCode});
		}
		else
		{
			hql = " from Location l " +
			" join l.codeMappings as cm" +
			" where cm.taxonomyName = :taxType " + 
			" and cm.taxonomyCode = :localCode " +
			" and l.type = :codeSpecifier ";

			locs = factory.find(hql,new String[]{"taxType", "localCode", "codeSpecifier"}, new Object[]{getDomLookup(TaxonomyType.PAS),localCode,getDomLookup(codeSpecifier)});
		}

		if (locs != null && locs.size() == 1)
		{
			LocShortVo loc = LocShortVoAssembler.create((Location) locs.get(0));
			REMOTE_LOC_CACHE.put(localCode, loc);
			return loc;
		}
		else if (locs != null && locs.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by LocalCode " + localCode);
		}
		return null;
	}
		
	public LocMostVo getLocationByPostCode(String postCode) 
	{
		if (postCode == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from Location l where l.address.postCode = :postCode ";

		List locList = factory.find(hql,new String[]{"postCode"}, new Object[]{postCode});

		if (locList != null && locList.size() == 1)
		{
			return LocMostVoAssembler.create((Location) locList.get(0));
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by Post Code " + postCode);
		}
		return null;
	}
	
	
	public LocSiteShortVo getLocSiteByPostCode(String postCode) 
	{
		if (postCode == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from LocSite l where l.address.postCode = :postCode ";

		List locList = factory.find(hql,new String[]{"postCode"}, new Object[]{postCode});

		if (locList != null && locList.size() == 1)
		{
			return LocSiteShortVoAssembler.create((LocSite) locList.get(0));
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on LocationSite by Post Code " + postCode);
		}
		return null;
	}
	
	private LocSite getDomLocSiteByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return (LocSite)getDomLocationByTaxonomyType(extId, taxonomyType, LocSite.class);		
	}

	private Location getDomLocationByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return getDomLocationByTaxonomyType(extId, taxonomyType, Location.class);
	}

	private Location getDomLocationByTaxonomyType(String extId, TaxonomyType taxonomyType, Class clazz)
	{
		if (extId == null || taxonomyType == null)
			return null;

		String objName = (clazz.equals(Location.class)) ? "Location" : "LocSite";
		DomainFactory factory = getDomainFactory();
		String hql = " from " + objName + " l " +
		" join l.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List locList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (locList != null && locList.size() == 1)
		{
			return (Location) locList.get(0);
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by TaxonomyType " + taxonomyType.getText() + " and code " + extId);
		}
		else
			return null;
	}

	public LocShortMappingsVo getLocationByTaxonomyType(String extId, TaxonomyType taxonomyType) 
	{
		return LocShortMappingsVoAssembler.create(getDomLocationByTaxonomyType(extId, taxonomyType));
	}

	public LocSiteVo getLocSiteByTaxonomyType(String extId, TaxonomyType taxType) 
	{
		return LocSiteVoAssembler.create(getDomLocSiteByTaxonomyType(extId, taxType));
	}
	
	public LocSiteShortVo getLocSiteShortByTaxonomyType(String extId, TaxonomyType taxType)
	{
		return LocSiteShortVoAssembler.create(getDomLocSiteByTaxonomyType(extId, taxType));
	}

	public LocationLiteVo getLocationLiteByTaxonomyType(String extId, TaxonomyType taxType)
	{
		return LocationLiteVoAssembler.create(getDomLocationByTaxonomyType(extId, taxType));
	}

	private Organisation getDomOrganisationByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		if (extId == null || taxonomyType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from Organisation o " +
		" join o.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List orgList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (orgList != null && orgList.size() == 1)
		{
			return (Organisation) orgList.get(0);
		}
		else if (orgList != null && orgList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Organisation by TaxonomyType " + taxonomyType.getText() + " and code " + extId);
		}
		return null;
	}
	
	public OrgLiteVo getOrgLiteByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return OrgLiteVoAssembler.create(getDomOrganisationByTaxonomyType(extId, taxonomyType));
	}
	
	public OrganisationVo getOrganisationByTaxonomyType(String extId, TaxonomyType taxonomyType) 
	{
		return OrganisationVoAssembler.create(getDomOrganisationByTaxonomyType(extId, taxonomyType));
	}
	
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see ims.admin.domain.OrganisationAndLocation#listLocationsMin(ims.core.vo.lookups.LocationType)
	 */
	public ClinicListVoCollection listLocationsMin(LocationType locType)
	{
		DomainFactory factory = getDomainFactory();
		ClinicListVoCollection voCollReturn = new ClinicListVoCollection();
		List lstClinics = factory.find("from Location l where l.type = :type and l.isActive= :isActive and l.isVirtual= :isVirtual", new String[]{"type", "isActive", "isVirtual"}, new Object[]{getDomLookup(locType), Boolean.TRUE, Boolean.FALSE});//wdev-2730

		for (Iterator iter = lstClinics.iterator(); iter.hasNext();)
		{
			Location doLocation = (Location) iter.next();
			ClinicListVo voBaseList = new ClinicListVo();
			voBaseList.setSingleID(doLocation.getId());
			voBaseList.setBoolValue(doLocation.isIsActive());
			voBaseList.setName(doLocation.getName());
			voBaseList.setDescription(doLocation.getExtCode(TaxonomyType.PAS.getId()));

			voCollReturn.add(voBaseList);
		}

		return voCollReturn;
	}

	public OrganisationVoCollection listRootOrgsNoGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.TRUE, Boolean.FALSE); 
	}

	public OrganisationVoCollection listActiveRootOrgsNoGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.TRUE, Boolean.TRUE); 
	}
	public OrganisationMinWithLocSitesVoCollection listActiveRootOrgsNoGppLite()
	{
		OrganisationMinWithLocSitesVo filter = new OrganisationMinWithLocSitesVo();
			
		return listOrganisationLite(filter,  Boolean.TRUE, Boolean.TRUE); 
	}	
	public OrganisationVoCollection listActiveRootOrgsWithGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.FALSE, Boolean.TRUE); 
	}

	public void setOrgActiveState(OrganisationRefVo orgVo, Boolean state) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Organisation org = (Organisation)factory.getDomainObject(Organisation.class, orgVo.getID_Organisation());
		org.setIsActive(state);
		factory.save(org);
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
	}

	public void setLocationActiveState(LocationRefVo locVo, Boolean state) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Location loc = (Location)factory.getDomainObject(Location.class, locVo.getID_Location());
		loc.setIsActive(state);
		factory.save(loc);		

		//WDEV-10574
		REMOTE_LOC_CACHE.clear();

		//WDEV-19576 Ward Master File HL7 message
		triggerWardMasterFileEvent(locVo);				

	}
	
	public ClinicVo getClinicByTaxonomyCode(TaxonomyType type,String taxCode)
	{
		DomainFactory factory = getDomainFactory();
		String hql="select clinic from Clinic as clinic left join clinic.codeMappings as codeMappings " +
				"where (codeMappings.taxonomyCode = :code and codeMappings.taxonomyName =:name )";
		List clinics=factory.find(hql, new String []{"code", "name"},new Object []{taxCode, getDomLookup(type)});
		if (clinics.size()!=0)
		{
			Clinic clinic=(Clinic)clinics.get(0);
			return ClinicVoAssembler.create(clinic);
		}
		else
		{
			return null;
		}
	}

	public ClinicVo saveClinic(ClinicVo clinic) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		
		Clinic domClinic = ClinicVoAssembler.extractClinic(factory, clinic);
		
		// wdev-3603 set uppernames if null
		
		//wdev-14268 , set uppernames at every save
		domClinic.setUpperNames();
		
		factory.save(domClinic);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
		
		return ClinicVoAssembler.create(domClinic);
	}

	private List listLocations(LocationType locType, Boolean activeOnly, Boolean includeReferringHosp, Boolean includeTreatingHosp, String name)
	{
		DomainFactory factory = getDomainFactory();
		
		List locations;

		String hql = " from Location loc ";
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		if (locType != null)
		{
			condStr.append(andStr + " loc.type = :locType");
			markers.add("locType");
			values.add(getDomLookup(locType));
			andStr = " and ";
		}
		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " loc.isActive = :active");
			markers.add("active");
			values.add(activeOnly);
			andStr = " and ";
		}
		if (includeReferringHosp != null && includeReferringHosp.booleanValue())
		{
			condStr.append(andStr + " loc.referringHospital = :referring");
			markers.add("referring");
			values.add(includeReferringHosp);
			andStr = " and ";
		}
		if (includeTreatingHosp != null && includeTreatingHosp.booleanValue())
		{
			condStr.append(andStr + " loc.treatingHosp = :treating");
			markers.add("treating");
			values.add(includeTreatingHosp);
			andStr = " and ";
		}		
		if (name != null)
		{
			condStr.append(andStr + " loc.upperName like :name");
			markers.add("name");
			values.add(name.toUpperCase() + "%");
			andStr = " and ";
		}
		
		//WDEV-7175 - exclude surgeries
		if(locType == null || locType != LocationType.SURGERY)
		{
			condStr.append(andStr + " loc.type <> :surgery ");
			markers.add("surgery");
			values.add(getDomLookup(LocationType.SURGERY));
			andStr = " and ";
		}
		
		//wdev-2730
		condStr.append(andStr + "loc.isVirtual =:isVirtual");
		markers.add("isVirtual");
		values.add(Boolean.FALSE);

		if (andStr.equals(" and "))
		{
			hql += " where ";
		}

		hql += condStr.toString();
		hql += " ORDER BY loc.upperName";						// WDEV-13930
		locations = factory.find(hql, markers, values);
		return locations;
	}
	
	public LocSiteLiteVoCollection listCCAs()
	{
		List locations = listLocations(LocationType.CCA,Boolean.TRUE,null,null,null);
		return LocSiteLiteVoAssembler.createLocSiteLiteVoCollectionFromLocSite(locations).sort();

	}

	public LocShortMappingsVoCollection listActiveHospitals()
	{
		List locations = listLocations(LocationType.HOSP,Boolean.TRUE,null,null,null);
		return  LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation(locations).sort();
	}

	public LocShortMappingsVoCollection listActiveWardsForHospital(LocationRefVo hospital)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null,null);//WDEV-20395
		return  LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation(locations).sort();
	}
	
	public LocShortVoCollection listActiveWardsForHospital(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null,name);//WDEV-20395
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveLocationsByName(String name)
	{
		List locations;
		if (name == null)
		{
			//		wdev-2730
			StringBuffer hql = new StringBuffer();
			hql.append(" from LocSite as ls");
			hql.append(" where");
			hql.append(" and ls.isActive =:active");
			hql.append(" and ls.isRIE is null");
			hql.append(" and ls.isVirtual =:virtual");
	
			locations = getDomainFactory().find(hql.toString(), new String[]{"active", "virtual"}, new Object[]{Boolean.TRUE, Boolean.FALSE});
		}
		else
		{
			locations = listLocations(null, Boolean.TRUE, null, null, name);
		}
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveReferringHospitals()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, Boolean.TRUE, null, null)).sort();
	}

	public LocationLiteVoCollection listActiveTreatingHospitals()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, null, Boolean.TRUE, null)).sort();
	}

	public LocationLiteVoCollection listActiveLocSiteLite()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find("from LocSite ls where ls.isActive = :isActive and ls.type != :SurgeryType and ls.isVirtual = :isVirtual", new String[]{"isActive","SurgeryType","isVirtual"}, new Object[]{Boolean.TRUE,getDomLookup(LocationType.SURGERY),Boolean.FALSE}));
	}

	public LocationLiteVoCollection listActiveLocSiteLiteByName(String nameFilter)
	{
		if (nameFilter == null || nameFilter.length() == 0)
		{
			return listActiveLocSiteLite();
		}
		String locFilter = nameFilter.toUpperCase() + "%";
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find("from LocSite ls where ls.isActive = :isActive and ls.upperName like :nameFilter and ls.isVirtual = :isVirtual", new String[]{"isActive","nameFilter","isVirtual"}, new Object[]{Boolean.TRUE, locFilter,Boolean.FALSE}));
	}

	public ClinicVo getClinic(Integer clinicCode)
	{
		DomainFactory factory = getDomainFactory();
		
		return ClinicVoAssembler.create((Clinic) factory.getDomainObject(Clinic.class, clinicCode.intValue()));
	}

	public LocShortMappingsVo getLocation(Integer location)
	{
		DomainFactory factory = getDomainFactory();
		
		return LocShortMappingsVoAssembler.create((Location) factory.getDomainObject(Location.class, location.intValue()));

	}

	public LocShortVoCollection listActiveWardsForHospitalByName(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null,name); //WDEV-20395
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveWardsForHospitalLite(LocationRefVo hospital)
	{
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null,null)).sort(); //WDEV-20395
	}

	public LocShortVoCollection listActiveClinicsForHospitalByName(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.CLINIC,hospital,Boolean.TRUE,null,null,null,name);//WDEV-20395
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}
	
	public LocationLiteVoCollection listActiveClinicsForHospitalByNameLite(LocationRefVo hospital, String name)
	{
		@SuppressWarnings("rawtypes")
		List locations = listLocationsByParentLocation(LocationType.CLINIC, hospital, Boolean.TRUE, null, null,null,name);//WDEV-20395
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
	}

	public LocationLiteVoCollection listActiveWardsForHospitalByNameLite(LocationRefVo location, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,location,Boolean.TRUE,null,null,null,name);//WDEV-20395
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listLocationByName(String locationName)
	{
		List locations = listLocationsByParentLocation(null,null,Boolean.TRUE,null,null,null,locationName);//WDEV-20395
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveOutpatDeptsForHospitalByNameLite(LocationRefVo parentLoc, String nameFilter)
	{
		List locations = listLocationsByParentLocation(LocationType.OUTPATIENT_DEPT,parentLoc,Boolean.TRUE,null,null,null,nameFilter);//WDEV-20395
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocShortVoCollection listActiveOutpatDeptsForHospitalByName(LocationRefVo hospital, String nameFilter)
	{
		List locations = listLocationsByParentLocation(LocationType.OUTPATIENT_DEPT,hospital,Boolean.TRUE,null,null,null,nameFilter);//WDEV-20395
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}
	
	
	public LocationLiteVoCollection listActiveAandEForHospitalByNameLite(LocationRefVo hosp, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.ANE,hosp,Boolean.TRUE,null,null,null,name);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();	
	}

	public String checkExchequerCodeIsUnique(String taxonomyCode, ValueObjectRef refVo)
	{		
		String dupMessage = "";
		
		dupMessage = checkExchequerCodeIsUniqueInOrganisation(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		dupMessage = checkExchequerCodeIsUniqueInLocSite(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		dupMessage = checkExchequerCodeIsUniqueInLocation(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		return null;
	}

	private String checkExchequerCodeIsUniqueInOrganisation(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from Organisation as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof OrganisationRefVo  && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}
	
	private String checkExchequerCodeIsUniqueInLocation(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from Location as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
	
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof LocationRefVo  && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}
	
	private String checkExchequerCodeIsUniqueInLocSite(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from LocSite as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
	
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof LocationRefVo && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}

	public String checkOrganisationNameisUnique(String orgName, OrganisationRefVo orgRefVo)
	{
		if (orgName == null)
			throw new CodingRuntimeException("Mandatory argument - Organisation Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from Organisation o left join o.type as t where t.id <> :IdType and o.upperName = :name";
		
		//WDEV-19798
		markers.add("IdType");
		values.add(OrganisationType.GPP.getID());
		
		markers.add("name");
		values.add(orgName.toUpperCase());
		
		String andStr = " and ";
		
		if (orgRefVo != null && orgRefVo.getID_OrganisationIsNotNull())
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(orgRefVo.getID_Organisation());
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "An organisation with the name " + orgName + " already exists, please rename the entered organisation";
			return dupMessage;
		}
		
		return null;
	}

	public String checkLocationNameIsUnique(String locationName, Integer locationId)
	{
		if (locationName == null)
			throw new CodingRuntimeException("Mandatory argument - Location Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List<?> list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from Location o left join o.type as t where t.id <> :IdType and t.id <> :IdType2 and o.upperName = :name "; //WDEV-20202
		
		markers.add("IdType");
		values.add(LocationType.SURGERY.getID());
		
		//WDEV-20202
		markers.add("IdType2");
		values.add(LocationType.BAY.getID());
		
		markers.add("name");
		values.add(locationName.toUpperCase());
		
		String andStr = " and ";
		
		if (locationId != null)
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(locationId);
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "A Location with the name '" + locationName + "' already exists, please rename the entered Location";
			return dupMessage;
		}
		
		return null;
	}

	public String checkLocationSiteNameIsUnique(String locSiteName, Integer locSiteId)
	{
		if (locSiteName == null)
			throw new CodingRuntimeException("Mandatory argument - Location Site Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from LocSite o left join o.type as t where t.id <> :IdType and o.upperName = :name";
		
		markers.add("IdType");
		values.add(LocationType.SURGERY.getID());
		
		markers.add("name");
		values.add(locSiteName.toUpperCase());
		
		String andStr = " and ";
		
		if (locSiteId != null )
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(locSiteId);
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "A Location Site with the name " + locSiteName + " already exists, please rename the entered Location Site";
			return dupMessage;
		}
		
		return null;
	}

	public LocShortMappingsVoCollection listActiveReferringHospitalsWithMappings()
	{
		return LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, Boolean.TRUE, null, null)).sort();
	}

	public LocationLiteVoCollection listActiveHospitalsLite()
	{
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(listLocations(LocationType.HOSP,Boolean.TRUE,null,null,null)).sort();
	}



	public OrganisationVoCollection listPCTs(String value, Boolean activeOnly) {
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o ";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		List orgs = null;

		condStr.append(andStr + " o.type.id = " + OrganisationType.NHS_PCT.getID());
		andStr = " and ";


		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " o.isActive = :isActive");
			markers.add("isActive");
			values.add(activeOnly);
			andStr = " and ";
		}
		
		
		if (null!=value && value.length() > 0)
		{
			condStr.append(andStr);
			condStr.append(" o.upperName like :OrgName");
			markers.add("OrgName");
			values.add(value.toUpperCase() + "%");
			andStr = " and ";

		}
		hql += " where ";
		hql +=  condStr.toString();
		orgs = factory.find(hql, markers, values);



		OrganisationVoCollection voCollOrgs = OrganisationVoAssembler.createOrganisationVoCollectionFromOrganisation(orgs);
		voCollOrgs.sort();
		return voCollOrgs;
	}

	public String getActiveHospitalCodeForClinic(ClinicRefVo clinicRefVo, TaxonomyType taxonomyType)
	{
		DomainFactory factory = getDomainFactory();
		Clinic clinic = (Clinic)factory.getDomainObject(clinicRefVo);
		if (clinic==null)
			return null;
		
		Location loc = clinic.getClinicLocation();

		while (loc!=null&&(loc.isIsActive()&&loc.getType()!=null&&loc.getType().equals(getDomLookup(LocationType.HOSP)))) //WDEV-20231 
		{
			loc=loc.getParentLocation();
		}
		if(loc!=null)
			return loc.getExtCode(taxonomyType.getID());
		return null;
	}

	public LocationLiteVoCollection listLocationByOrganisation(OrganisationRefVo organisation, String name) 
	{
		if (name != null)
			name = name.replaceAll("[^a-zA-Z]", "");
		List<Location> locations = new ArrayList<Location>();
		buildLocations(organisation.getID_Organisation(), locations, name,false);
		
		LocationLiteVoCollection locs = LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return locs.sort(true);
	}
	
	private void buildLocations(Object node,List<Location> locations,final String name,Boolean includePathRad)
	{
		if (node == null)
			return;
		
		if(node instanceof Integer)
		{
			List<Integer> orgId = listOrganisationByOrganisation((Integer) node);
			for(int i=0; orgId!=null && i<orgId.size(); i++)
			{
				buildLocations(orgId.get(i), locations,name,includePathRad);
			}

			List<Location> locSiteList = listLocSiteByOrganisation((Integer) node, includePathRad);

			for(int j=0; locSiteList!=null && j<locSiteList.size(); j++)
			{
				buildLocations(locSiteList.get(j), locations,name,includePathRad);
			}
			
			return ;

		}

		if(node instanceof Location)
		{
			Location loc = (Location) node;
			boolean shouldAdd = true;
			if (name!=null && !loc.getName().toUpperCase().contains(name.toUpperCase()))
			{
				shouldAdd = false;
			}
			if (shouldAdd)
				 locations.add(loc);

			List<Location> locationList = listLocationByLocation(loc,includePathRad);

			for(int k = 0; locationList != null && k<locationList.size(); k++)
			{

				buildLocations(locationList.get(k), locations,name,includePathRad);
			}
		}
	}

	@SuppressWarnings("unchecked")
	private List<Location> listLocationByLocation(Location node,Boolean includePathRad) 
	{
		String hql = "";
		if(includePathRad != null && includePathRad)
		{
			hql = "select childLoc from Location as loc left join loc.locations as childLoc where (childLoc.isActive = 1 and childLoc.isVirtual <> 1 and childLoc.type is not null  and childLoc.type.id <> :surgery and loc.id = :id) ";
			return getDomainFactory().find(hql,new String[]{"id","surgery"}, new Object[]{node.getId(),LocationType.SURGERY.getID()});
		}
		else
		{
			hql = "select childLoc from Location as loc left join loc.locations as childLoc where (childLoc.isActive = 1 and childLoc.isVirtual <> 1 and childLoc.type is not null  and childLoc.type.id not in (:path,:rad,:surgery) and loc.id = :id) ";
			return getDomainFactory().find(hql,new String[]{"id","path","rad","surgery"}, new Object[]{node.getId(),LocationType.PATHOLOGYLABORATORY.getID(),LocationType.CLINICALIMAGINGDEPARTMENT.getID(),LocationType.SURGERY.getID()});
		}
	}

	@SuppressWarnings("unchecked")
	private List<Location> listLocSiteByOrganisation(Integer node,Boolean includePathRad)
	{
		String hql = "";
		if(includePathRad != null && includePathRad)
		{
			hql = "select locSite from Organisation as org left join org.locationSites as locSite where (org.id = :id and locSite.isActive = 1 and locSite.isVirtual <> 1)";
			return getDomainFactory().find(hql,"id",node);
		}
		else
		{
			hql = "select locSite from Organisation as org left join org.locationSites as locSite where (org.id = :id and locSite.isActive = 1 and locSite.isVirtual <> 1 and locSite.type is not null  and locSite.type.id not in (:path,:rad,:surgery)) ";
			return getDomainFactory().find(hql,new String[]{"id","path","rad","surgery"}, new Object[]{node,LocationType.PATHOLOGYLABORATORY.getID(),LocationType.CLINICALIMAGINGDEPARTMENT.getID(),LocationType.SURGERY.getID()});
		}
	}

	@SuppressWarnings("unchecked")
	private List<Integer> listOrganisationByOrganisation(Integer node) {
		String getOrgHql ="select org.id from Organisation as org where (org.parentOrganisation.id = :parentId  and org.isActive = 1 and org.type.id not in (:supp,:gpp,:nhs_pct) and org.type is not null)";
		return getDomainFactory().find(getOrgHql,new String[]{"parentId","supp","gpp","nhs_pct"},new Object[]{node,OrganisationType.SUPPLIER.getID(),OrganisationType.GPP.getID(),OrganisationType.NHS_PCT.getID()});
	}

	//WDEV-10065
	public LocationLiteVoCollection listLocationByOrganisationIncludingPathAndRadTypes(OrganisationRefVo org)
	{
		if (org == null)
			throw new CodingRuntimeException("org cannot be null in method listLocationByOrganisation");
		
		List<Location> locations = new ArrayList<Location>();
		
		buildLocations(org.getID_Organisation(), locations, null, true);
		
		LocationLiteVoCollection locs = LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return locs.sort(true);
	}

	/**
	* Gets the Active Hospital mapping for a particular location by walking up the Location tree until it hits a Hospital.
	* http://jira/browse/WDEV-11637
	*/

	public String getActiveHospitalCodeForLoc(LocShortMappingsVo loc,TaxonomyType taxonomyType) {
		DomainFactory factory = getDomainFactory();
		Location location = (Location)factory.getDomainObject(loc);
		return getActiveHospitalCodeForLoc(location,taxonomyType);
	}
	
//http://jira/browse/WDEV-18571 split into BO and VO methods	
	public String getActiveHospitalCodeForLoc(Location location,TaxonomyType taxonomyType) {
		if (location==null)
			return null;

		while (location!=null&&
				(location.isIsActive()&&location.getType()!=null&&!location.getType().equals(getDomLookup(LocationType.HOSP)))
				)
		{
			location=location.getParentLocation();
		}
		if(location!=null)
			return location.getExtCode(taxonomyType.getID());
		return null;
	}
	

	/*http://jira/browse/WDEV-11789
	 * (non-Javadoc)
	 * @see ims.admin.domain.OrganisationAndLocation#getPracticeNationalCodeForSurgery(ims.core.resource.place.vo.LocationRefVo)
	 * Returns the National code of the parctice of a surgery or null.
	 */
	public String getPracticeNationalCodeForSurgery(LocationRefVo surgery)
	{
		DomainFactory factory = getDomainFactory();
		if (surgery==null)
			return null;
		
		 LocSite loc=(LocSite)factory.getDomainObject(surgery);//(Organisation.class, id));
		 if (loc!=null&&
				 loc.getType()!=null&&
				 loc.getType().equals(getDomLookup(LocationType.SURGERY))&&
				 loc.getParentOrganisation()!=null)
		 {
			 return loc.getParentOrganisation().getMappingValueOfType(getDomLookup(TaxonomyType.NAT_LOC_CODE));
		 }
		 else 
		 {
			 return null;
		 }
		 
	}

	public LocationLiteVoCollection listActiveEDs() 
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.ANE, Boolean.TRUE, null, null, null));
	}
	
	//WDEV-19495
	public LocationLiteVoCollection listCaseNoteFolderLocations(String strVal)
	{
		if (strVal == null || strVal.length() == 0)
			throw new CodingRuntimeException("The search string argument cannot be null or blank.");
		
		String hql = " from Location loc where loc.isActive = :ISACTIVE AND loc.upperName like :NAME AND loc.caseNoteFolderLocation = :CASENOTELOCATION  ORDER BY loc.upperName asc";
		
		DomainFactory domainFactory = getDomainFactory();
		
		List<?> results = domainFactory.find(hql, new String[]{"ISACTIVE", "NAME", "CASENOTELOCATION"},  new Object[]{true, "%" + strVal.toUpperCase() + "%", true});
		
		if (results == null || results.isEmpty())
			return null;
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(results);		
	}


	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public LocationLiteVo getHospitalLiteForLocation(ILocation location)
	{
		if(location == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, location.getID()));
		
		if (currentHospital != null)
			return LocationLiteVoAssembler.create(currentHospital);
		
		return null;
	}

	//WDEV-19576
	/**
	 * Save a location site and locations
	 * LocMostVo is passed so that a single HL7 message can be constructed
	 */
	public ims.core.vo.LocSiteVo saveLocationSite(ims.core.vo.LocSiteVo locationSite, ims.core.vo.LocMostVo childLoc) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!locationSite.isValidated())
			throw new DomainRuntimeException("Location Site not Validated.");
			
		DomainFactory factory = getDomainFactory();
		HashMap<?,?> map = new HashMap<Object, Object>();
		LocSite doLocationSite = LocSiteVoAssembler.extractLocSite(factory, locationSite, map);
		Location doChildLoc = LocMostVoAssembler.extractLocation(factory, childLoc, map);
		
//		 uniqueness constraint removed form the database - must be implemented in code. 
		if (checkLocationSiteNameIsUnique(locationSite.getName(), locationSite.getID_Location())!= null )
		{
			throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
		}
		
		try
		{
			doLocationSite.setUpperNames();
			factory.save(doLocationSite);
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocationSite, "codeMappings", locationSite.getCodeMappings(), "getName");
			
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			if (locationSite.getLocationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(locationSite.getLocations(), map, factory);
			}

			throw new UniqueKeyViolationException("An Location Site with this name already exists, Please change", e);			
		}
		
		//WDEV-19576 Ward Master File HL7 message
		if(doChildLoc!=null)
		{
			LocationRefVo locRefVo = LocMostVoAssembler.create(doChildLoc);
			triggerWardMasterFileEvent(locRefVo);
		}
		
		return LocSiteVoAssembler.create(doLocationSite);
	}
	
	//WDEV-20395
	public LocationLiteVoCollection listLocationsByTheParentLocation(LocationType locationtype, LocationRefVo parentLocation, Boolean isActive, Boolean referringHospital, Boolean treatingHosp,Boolean caseNoteFolderLocation, String name)
	{
		List locations = listLocationsByParentLocation(locationtype,parentLocation,isActive,referringHospital,treatingHosp,caseNoteFolderLocation,name);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}
	
	
	//WDEV-21222
	private String getTypesAsStr(int[] locationTypes)
	{
	if(locationTypes==null)
		return "NULL";
	StringBuilder sb = new StringBuilder();
	for (int n : locationTypes) { 
	    if (sb.length() > 0) sb.append(',');
	    sb.append(Integer.toString(n));
	}
	return sb.toString();
	}

	
	String getIsActiveStr(Boolean isActive)
	{
		if (isActive==null)
			return"";
		else if(Boolean.TRUE.equals(isActive))
				return" isactive = 1 ";
		else 
			return" (isactive = 0 or isactive is null) ";
	}

	String getIsTreatingHospitalStr(Boolean isTreatingHospital)
	{
		if (isTreatingHospital==null)
			return"";
		else if(Boolean.TRUE.equals(isTreatingHospital))
				return"  treatingho = 1 ";
		else 
			return" (treatingho = 0 or treatingho is null) ";
	}
	
	String getIsVirtualStr(Boolean isVirtual)
	{
		if (isVirtual==null)
			return"";
		else if(Boolean.TRUE.equals(isVirtual))
				return"  isvirtual = 1 ";
		else 
			return" (isvirtual = 0 or isvirtual is null) ";
	}
	

	String getIsReferringHospitalStr(Boolean isReferringHospital)
	{
		if (isReferringHospital==null)
			return"";
		else if(Boolean.TRUE.equals(isReferringHospital))
				return"  referringh = 1 ";
		else 
			return" (referringh = 0 or referringh is null) ";
	}
	
	String getIsCaseNoteFolderLocationStr(Boolean isCaseNoteFolderLocation)
	{
		if (isCaseNoteFolderLocation==null)
			return"";
		else if(Boolean.TRUE.equals(isCaseNoteFolderLocation))
				return"  casenotefo = 1 ";
		else 
			return" (casenotefo = 0 or casenotefo is null) ";
	}
	
	
	
	private String getChildLocationsIdsForLocation(Integer locationID, int[] locationTypes,Boolean isActive,Boolean isTreatingHospital,Boolean isReferringHospital, Boolean isCaseNoteFolderLocation,Boolean isVirtual,String name,Boolean includeCurrent)
	{
		if (locationID == null)
			return "NULL";
		if(locationTypes==null&&isActive==null&&isVirtual==null&&isTreatingHospital==null&&isReferringHospital==null&&isCaseNoteFolderLocation==null&&name==null)
			return "NULL";

		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		StringBuilder ids = new StringBuilder("");
		
		String sql =";WITH locationCTE AS "+
			"( "+ 
			"SELECT id, name, parentloca, lkp_c_ty, isactive ,isvirtual,treatingho,referringh,casenotefo,uppername "+
			"FROM core_location  "+
			"WHERE id = ? "+
			"UNION ALL "+
			"SELECT l.id, l.name, l.parentloca, l.lkp_c_ty, l.isactive ,l.isvirtual, l.treatingho,l.referringh,l.casenotefo,l.uppername "+ 
			"FROM core_location l  "+
			"INNER JOIN locationCTE s ON l.parentloca = s.id "+ 
			")  "+
			"SELECT * FROM locationCTE "+  
			"where "+catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(getTypeStr(locationTypes),getIsActiveStr(isActive))
					, getIsTreatingHospitalStr(isTreatingHospital)),getIsReferringHospitalStr(isReferringHospital)),
					getIsCaseNoteFolderLocationStr(isCaseNoteFolderLocation)),getIsVirtualStr(isVirtual)),getNameStr(name,false));
		try 
		{
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1,locationID);
			ResultSet rs = ps.executeQuery();
			while (rs.next())
			{
				if(includeCurrent!=null&&Boolean.FALSE.equals(includeCurrent)&&locationID.toString().equals(rs.getString(1)))
						continue;
				else if ("".equals(ids.toString()))
					ids.append(rs.getString(1));
				else
					ids.append(", ").append(rs.getString(1));
			}
			rs.close();
			ps.close();
			conn.close();
		} 
		catch (SQLException e) 
		{
			LOGGER.warn("SQL Exception in getChildLocationsIdsForLocation", e);
			return "NULL";
		}	
		return ids.length() == 0 ? "NULL" : ids.toString();
	}
	
	public String getChildLocationsIdsForLocation(Integer locationID, int[] locationTypes,Boolean isActive)
	{
		return getChildLocationsIdsForLocation(locationID, locationTypes, isActive, null);
	}
	
	private String getTypeStr(int[] locationTypes)
	{
		if(locationTypes==null)
			return "";
		else
			return " lkp_c_ty in ("+getTypesAsStr(locationTypes)+") ";
	}
	
	
	private String getNameStr(String name, boolean containsMatch)
	{
		if (name == null)
			return "";
		String[] arr = null;
		if (name.contains("%"))
		{
			arr = name.split("%");
			if (arr.length > 0)
			{	
				List<String> lst = new ArrayList<String>(Arrays.asList(arr));
				lst.removeAll(Collections.singleton(""));
				name = lst.get(0);
			}	
			else
				name = "%";
		}
		return " uppername like '"+ (containsMatch && (arr == null || arr.length > 0) ? "%" : "") + name.trim().toUpperCase() + "%" + "' ";	
	}

	
	private String getNotTypeStr(int[] locationTypes)
	{
		if(locationTypes==null)
			return "";
		else
			return " lkp_c_ty not in ("+getTypesAsStr(locationTypes)+") ";
	}

	private String catWithAnd(String first,String second)
	{
		if((first!=null&&!first.isEmpty())&&(second!=null&&!second.isEmpty()))
			return first+" AND "+second;
		else if((first==null||first.isEmpty())&&(second==null||second.isEmpty()))
			return "";
		else if(first==null||first.isEmpty())
			return second;
		else if(second==null||second.isEmpty())
			return first;
		else
			return "";
	}
	
	public String getChildLocationsIdsForLocation(Integer locationID, int[] locationTypes,Boolean isActive,Boolean isVirtual)
	{
		if (locationID == null)
			return "NULL";
		if(locationTypes==null&&isActive==null&&isVirtual==null)
			return "NULL";
			
		
		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		
		StringBuilder ids = new StringBuilder("");
		
		String sql =";WITH locationCTE AS "+
				"( "+ 
				"SELECT id, name, parentloca, lkp_c_ty, isactive, isvirtual "+
				"FROM core_location  "+
				"WHERE id = ? "+
				"UNION ALL "+
				"SELECT l.id, l.name, l.parentloca, l.lkp_c_ty, l.isactive, l.isvirtual "+ 
				"FROM core_location l  "+
				"INNER JOIN locationCTE s ON l.parentloca = s.id "+ 
				")  "+
				"SELECT * FROM locationCTE "+  
				"where "+catWithAnd(catWithAnd(getTypeStr(locationTypes), getIsActiveStr(isActive)),getIsVirtualStr(isVirtual));
				
		try 
		{
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1,locationID);
			ResultSet rs = ps.executeQuery();
			while (rs.next())
			{
				if(locationID.toString().equals(rs.getString(1)))
					continue;
				else if ("".equals(ids.toString()))
					ids.append(rs.getString(1));
				else
					ids.append(", ").append(rs.getString(1));
			}
			rs.close();
			ps.close();
			conn.close();
		} 
		catch (SQLException e) 
		{
			LOGGER.warn("SQL Exception in getChildLocationsIdsForLocation", e);
			return "NULL";
		}	
		return  ids.length() == 0 ? "NULL" : ids.toString();
	}
	
	


	public LocationLiteVoCollection listOutpatientlocationsByHospital(LocationRefVo hospital)
	{
		String hql = "select l from Location l where l.id in("+getChildLocationsIdsForLocation(hospital.getBoId(),new int[]{LocationType.OUTPATIENT_DEPT.getID()},Boolean.TRUE) +")"; 
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(hql)).sort();
	}
	
	public LocationLiteVoCollection listCaseNoteLocationByParentLocation(LocSiteRefVo parentLocSite, String name)
	{
		String ids =getChildLocationsIdsForLocation(parentLocSite.getBoId(),new int[]{LocationType.CASE_NOTE_FOLDER_LOCATION.getID()},Boolean.TRUE);
		String hql = "select l from Location l where l.id in("+ids+")";
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(hql)).sort(SortOrder.ASCENDING);
	}
	
	public String getTheatreAndProcedureRoomsIDsForLocation(LocationRefVo locationRef)
	{
		if (locationRef==null)
			return "NULL";
		else
			return getChildLocationsIdsForLocation(locationRef.getBoId(), new int[]{LocationType.THEATRE.getID(),LocationType.PROCEDURE_ROOM.getID()}, Boolean.TRUE, null, null, null, Boolean.FALSE, null,null);
	}

	public List listLocationsByParentLocation(LocationType type,LocationRefVo parentLocation, Boolean isActive, Boolean isVirtual, String name)
	{
		String ids = getChildLocationsIdsForLocation(parentLocation.getID_Location(), new int[] {LocationType.WARD.getID()},Boolean.TRUE,null,null, null,null,name,null);
		String hql = "select l from Location l where l.id in("+ids+")";
		return getDomainFactory().find(hql);
	}

	public LocShortVoCollection getCaseNoteFolderLocationByParent(LocationRefVo locRef, String value, LocationType type)
	{
		List locations = listLocationsByParentLocation(type,locRef,Boolean.TRUE,null,null,Boolean.TRUE,value);
		return LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations);
	}
	
	public LocShortVoCollection getLocationByParent(LocationRefVo locRef,String value, LocationType type1)
	{
		int[] types;
		if( type1.equals(LocationType.CLINIC ))
		{
			types = new int[]{LocationType.CLINIC.getID(), LocationType.OUTPATIENT_DEPT.getID()};
		}
		else if( type1.equals(LocationType.THEATRE ))
		{
			types = new int[]{LocationType.THEATRE.getID(), LocationType.PROCEDURE_ROOM.getID()};
		}
		else
		{
			types = new int[]{type1.getID()};
		}
		String ids = getChildLocationsIdsForLocation(locRef.getBoId(),types,Boolean.TRUE, null, null, null, null, value,null);//http://jira/browse/WDEV-21774 Build 10.5.1
		List<Location> locations = getDomainFactory().find("select l from Location l where l.id in("+ids+")");
		return LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort(true);
	}
	public String getChildLocationsIdsForLocation(Integer locationID,int[] locationTypes, Boolean isActive, Boolean isVirtual,Boolean caseNoteFolder, Boolean includeCurrent)
	{
		return getChildLocationsIdsForLocation(locationID,locationTypes,isActive,null,null,  caseNoteFolder, isVirtual,null,includeCurrent);
	}

	public LocShortMappingsVoCollection listActiveLocationsForHospital(LocationRefVo location,int[] types)
	{
		String ids = getChildLocationsIdsForLocation(location.getBoId(), types, Boolean.TRUE, Boolean.FALSE);
		String hql = "select l from Location l where l.id in("+ids+")";
		return LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation( getDomainFactory().find(hql)).sort(true);
	}
	public LocationLiteVoCollection listRequestorLocation(LocationRefVo hospital, String locationName)
	{
		String ids = getIDsForRequestorLocation(hospital.getBoId(),new int [] {LocationType.CLINIC.getID(),LocationType.WARD.getID()},locationName);
		String hql = "select l from Location l where l.id in("+ids+")";
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(hql)).sort(true);
	}
	private String getIDsForRequestorLocation(Integer locationID, int[] excludedTypes,String name)
	{
		if (locationID == null)
			return "NULL";
		if(excludedTypes==null&&name==null)
			return "NULL";

		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		StringBuilder ids = new StringBuilder("");
		
		String sql =";WITH locationCTE AS "+
			"( "+ 
			"SELECT id, name, parentloca, lkp_c_ty, isactive,uppername,casenotefo,isvirtual,treatingho,referringh "+
			"FROM core_location  "+
			"WHERE id = ? "+
			"UNION ALL "+
			"SELECT l.id, l.name, l.parentloca, l.lkp_c_ty, l.isactive,l.uppername,l.casenotefo,l.isvirtual,l.treatingho,l.referringh "+ 
			"FROM core_location l  "+
			"INNER JOIN locationCTE s ON l.parentloca = s.id "+ 
			")  "+
			"SELECT * FROM locationCTE "+  
			"where "+catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(getNotTypeStr(excludedTypes),getIsActiveStr(Boolean.TRUE)), getIsTreatingHospitalStr(null)),
					getIsReferringHospitalStr(null)),getIsCaseNoteFolderLocationStr(Boolean.TRUE)),getIsVirtualStr(Boolean.FALSE)),getNameStr(name,true));
		try 
		{
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1,locationID);
			ResultSet rs = ps.executeQuery();
			while (rs.next())
			{
				if(locationID.toString().equals(rs.getString(1)))
					continue;
				else if ("".equals(ids.toString()))
					ids.append(rs.getString(1));
				else
					ids.append(", ").append(rs.getString(1));
			}
			rs.close();
			ps.close();
			conn.close();
		} 
		catch (SQLException e) 
		{
			LOGGER.warn("SQL Exception in getChildLocationsIdsForLocation", e);
			return "NULL";
		}	
		return ids.length() == 0 ? "NULL" : ids.toString();
	}
	@Override
	public String getChildLocationsIdsForLocation(Integer locationID,int[] locationTypes, Boolean isActive, Boolean isVirtual,Boolean caseNoteFolder)
	{
		return getChildLocationsIdsForLocation(locationID,locationTypes,isActive,isVirtual,caseNoteFolder,null);
	}
	
	public LocShortMappingsVoCollection listActiveLocationsForHospitalByName(LocationRefVo location, int[] types, String name)
	{
		String ids = getChildLocationsIdsForLocation(location.getBoId(), types, Boolean.TRUE, Boolean.FALSE);
		String hql = "select l from Location l where l.id in ("+ids+") and l.upperName like :NAME ";  
		return LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation( getDomainFactory().find(hql, new String[]{"NAME"},  new Object[]{"%" + name.toUpperCase() + "%"})).sort(true);
	}
	//wdev-22284
	public LocationLiteVoCollection listRequestorLocationWithOrWithoutVirtualLoc(LocationRefVo hospital, String locationName, Boolean virtual)
	{
		return listRequestorLocationWithOrWithoutVirtualLocIncludeWards(hospital, locationName, virtual, Boolean.FALSE);
	}
	private String getIDsForRequestorLocationV(Integer locationID, int[] excludedTypes,String name, Boolean virtual)
	{
		if (locationID == null)
			return "NULL";
		if(excludedTypes==null&&name==null)
			return "NULL";

		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		StringBuilder ids = new StringBuilder("");
		
		String sql =";WITH locationCTE AS "+
			"( "+ 
			"SELECT id, name, parentloca, lkp_c_ty, isactive,uppername,casenotefo,isvirtual,treatingho,referringh "+
			"FROM core_location  "+
			"WHERE id = ? "+
			"UNION ALL "+
			"SELECT l.id, l.name, l.parentloca, l.lkp_c_ty, l.isactive,l.uppername,l.casenotefo,l.isvirtual,l.treatingho,l.referringh "+ 
			"FROM core_location l  "+
			"INNER JOIN locationCTE s ON l.parentloca = s.id "+ 
			")  "+
			"SELECT * FROM locationCTE "+  
			"where "+catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(catWithAnd(getNotTypeStr(excludedTypes),getIsActiveStr(Boolean.TRUE)), getIsTreatingHospitalStr(null)),
					getIsReferringHospitalStr(null)),getIsCaseNoteFolderLocationStr(Boolean.TRUE)),getIsVirtualStr(virtual)),getNameStr(name,true));
		try 
		{
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1,locationID);
			ResultSet rs = ps.executeQuery();
			while (rs.next())
			{
				if(locationID.toString().equals(rs.getString(1)))
					continue;
				else if ("".equals(ids.toString()))
					ids.append(rs.getString(1));
				else
					ids.append(", ").append(rs.getString(1));
			}
			rs.close();
			ps.close();
			conn.close();
		} 
		catch (SQLException e) 
		{
			LOGGER.warn("SQL Exception in getChildLocationsIdsForLocation", e);
			return "NULL";
		}	
		return ids.length() == 0 ? "NULL" : ids.toString();
	}
	//------ end wdev-22284
	@Override
	public LocationLiteVoCollection listRequestorLocationWithOrWithoutVirtualLocIncludeWards(LocationRefVo hospital, String locationName, Boolean virtual,Boolean includeWards)//WDEV-22751
	{
		int[] excludedTypes = new int [2];
		excludedTypes[0] = LocationType.CLINIC.getID();
		if(!Boolean.TRUE.equals(includeWards))
			excludedTypes[1] = LocationType.WARD.getID();
		
		String ids = getIDsForRequestorLocationV(hospital.getBoId(),excludedTypes,locationName,virtual);
		String hql = "select l from Location l where l.id in("+ids+")";
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(hql)).sort(true);
	}
	

}
