//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Florin Blindu using IMS Development Environment (version 1.80 build 4910.25978)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.domain.base.impl.BaseElectiveListConfigurationImpl;
import ims.admin.vo.ServiceForElectiveListConfigVo;
import ims.admin.vo.domain.ElectiveListConfigurationVoAssembler;
import ims.admin.vo.domain.ServiceForElectiveListConfigVoAssembler;
import ims.core.configuration.domain.objects.ElectiveListConfiguration;
import ims.core.configuration.vo.ElectiveListConfigurationRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocSiteRefVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocSiteLiteVoCollection;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocSiteLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.ServiceCategory;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class WaitingListConfigurationImpl extends BaseElectiveListConfigurationImpl
{

	private static final long serialVersionUID = 1L;

	/*
	public ims.core.vo.HcpLiteVoCollection listConsultants(String name)
	{
		HcpFilter filter = new HcpFilter();
		PersonName voName = new PersonName();
		voName.setSurname(name);
		filter.setQueryName(voName);
		
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLite(filter);
	}
	*/
	
	public LocSiteLiteVoCollection listHospitals(String name) //WDEV-20064
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		StringBuffer hql = new StringBuffer();

		hql.append(" select loc from LocSite as loc ");//WDEV-20064
		hql.append(" where loc.upperName like :LocName and loc.isActive = 1 and loc.isVirtual = 0 and loc.type = :Hospital ");
		hql.append(" order by loc.upperName asc");
		
		markers.add("LocName");
		values.add(name.toUpperCase()+"%");
		
		markers.add("Hospital");
		values.add(getDomLookup(LocationType.HOSP));
		
		return LocSiteLiteVoAssembler.createLocSiteLiteVoCollectionFromLocSite(factory.find(hql.toString(), markers, values));
	}

	public ims.admin.vo.ServiceForElectiveListConfigVoCollection listServices(String name)
	{
		//WDEV-20064
		StringBuilder hqlBuilder = new StringBuilder("select s1_1 from Service as s1_1 where s1_1.upperName like :servName and s1_1.isActive = 1 and s1_1.serviceCategory.id =:clinicalCategoryID order by s1_1.upperName asc");
				
		List <?> dos = getDomainFactory().find(hqlBuilder.toString(),new String[] {"servName","clinicalCategoryID"},new Object[] {name.toUpperCase()+"%",ServiceCategory.CLINICAL.getID()});
		
		if (dos == null || dos.size() == 0)
			return null;
		
		return ServiceForElectiveListConfigVoAssembler.createServiceForElectiveListConfigVoCollectionFromService(dos); 
	}

	public ims.admin.vo.ElectiveListConfigurationVo save(ims.admin.vo.ElectiveListConfigurationVo configurationToSave) throws ims.domain.exceptions.StaleObjectException
	{
		if (configurationToSave == null)
		{
			throw new CodingRuntimeException("Cannot save null ElectiveListConfigurationVo");
		}

		DomainFactory factory = getDomainFactory();
		
		ElectiveListConfiguration domainWaitinngListConfig = ElectiveListConfigurationVoAssembler.extractElectiveListConfiguration(factory, configurationToSave);
		factory.save(domainWaitinngListConfig);
		
		return ElectiveListConfigurationVoAssembler.create(domainWaitinngListConfig);
	}

	public ims.admin.vo.ElectiveListConfigurationVo getConfiguration(ims.core.configuration.vo.ElectiveListConfigurationRefVo configurationRef)
	{
		if (configurationRef==null ||configurationRef.getID_ElectiveListConfiguration()==null)
		{
			throw new CodingRuntimeException("Cannot get ElectiveListConfigurationVo on null Id ");
		}

		DomainFactory factory = getDomainFactory();

		ElectiveListConfiguration domainWaitListConfig = (ElectiveListConfiguration) factory.getDomainObject(ElectiveListConfiguration.class,configurationRef.getID_ElectiveListConfiguration());

		return ElectiveListConfigurationVoAssembler.create(domainWaitListConfig);
	}

	public ims.admin.vo.ElectiveListConfigurationVoCollection search(ims.admin.vo.ElectiveListConfigSearchCriteriaVo searchCriteria)
	{
		if (searchCriteria == null)
			throw new CodingRuntimeException("At least one search criteria must be provided");

		DomainFactory factory = getDomainFactory();

		StringBuffer hqlConditions = new StringBuffer();
		
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC  ");
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String andStr = "";

		if (searchCriteria.getWaitingListNameIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" UPPER(wLC.waitingListName) like :WaitingListName ");
			markers.add("WaitingListName");
			values.add(searchCriteria.getWaitingListName().toUpperCase()+"%");
			andStr = " and ";
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.service.id = :Service ");
			markers.add("Service");
			values.add(searchCriteria.getService().getID_Service());
			andStr = " and ";
		}
		
		if (searchCriteria.getFromDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.startDate >= :dateFrom ");
			markers.add("dateFrom");
			DateTime fromDateTime = new DateTime(searchCriteria.getFromDate(), new Time(0, 0));
			values.add(fromDateTime.getJavaDate());
			andStr = " and ";
		}

		if (searchCriteria.getToDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.endDate <= :dateTo ");
			markers.add("dateTo");
			DateTime toDateTime = new DateTime( searchCriteria.getToDate(), new Time(0, 0));
			values.add(toDateTime.getJavaDate());
			andStr = " and ";
		}
		
		if (searchCriteria.getActiveIsNotNull() && searchCriteria.getActive())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.isActive = :Active ");
			markers.add("Active");
			values.add(Boolean.TRUE);
			andStr = " and ";
		}

		if (searchCriteria.getConsultantIsNotNull())
		{
			hql.append(" left join wLC.hCPs as hcps left join hcps.hCP as hcp");
			hqlConditions.append(andStr);
			hqlConditions.append(" hcp.id = :HCPId");
			markers.add("HCPId");
			values.add(searchCriteria.getConsultant().getID_Hcp());
			andStr = " and ";
		}
		
		if (searchCriteria.getHospitalIsNotNull())
		{
			hql.append(" left join wLC.listLocations as listLocs left join listLocs.listLocation as listLoc");
			hqlConditions.append(andStr);
			hqlConditions.append(" listLoc.id = :locId");
			markers.add("locId");
			values.add(searchCriteria.getHospital().getID());
			andStr = " and ";
		}
		
		if (hqlConditions.length() > 0)
		{
			hqlConditions.insert(0, " where (");
			hqlConditions.append(" ) ");
		}

		List<?> list = factory.find((hql.toString() + hqlConditions.toString() + "order by UPPER(wLC.waitingListName) asc ").toString(), markers, values);

		if (list == null || list.size() == 0)
			return null;

		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public HcpLiteVoCollection listConsultants(String name)
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		StringBuffer hqlConditions = new StringBuffer();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "select hcp from Hcp as hcp where hcp.isActive = 1 and (hcp.mos.name.upperSurname like :hcpSname or hcp.mos.name.upperForename like :hcpFname) ";
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");
		
		DomainFactory factory = getDomainFactory();
		List<?> list = factory.find((hql + hqlConditions.toString() + " order by hcp.mos.name.upperSurname , hcp.mos.name.upperForename asc").toString(), markers, values);
		 
		if (list != null && list.size() > 0)
			return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(list);
			
		return null;
	}

	public Boolean existConfigurationWithSameName(String name, ElectiveListConfigurationRefVo waitingListConfigRef)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC where wLC.isActive = 1 and wLC.waitingListName = :WaitingListName  ");
		markers.add("WaitingListName");
		values.add(name);
		
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	public Boolean existConfigurationWithSameCode(String code, ElectiveListConfigurationRefVo waitingListConfigRef, Date startDate, Date endDate)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC where wLC.isActive = 1 and wLC.waitingListCode = :WaitingListCode ");
		markers.add("WaitingListCode");
		values.add(code);
	
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		if (startDate!=null && endDate!=null)
		{
			hql.append(" and ((wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) or ( wLC.startDate <= :EndDate and wLC.endDate >= :EndDate) or (wLC.startDate >= :StartDate and wLC.endDate <= :EndDate) )");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
			
			markers.add("EndDate");
			DateTime endDateTime = new DateTime(endDate, new Time(0, 0));
			values.add(endDateTime.getJavaDate());
		}
		else if (startDate!=null)
		{
			hql.append(" and (wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) ");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	public Boolean isConsultantMarkedAsDefaultForSameServiceForOtherConfiguration(HcpRefVo consultantRef, ServiceForElectiveListConfigVo serviceVo, ElectiveListConfigurationRefVo waitingListConfigRef, Date startDate, Date endDate)
	{
		if (consultantRef==null || consultantRef.getID_Hcp()==null || serviceVo==null || serviceVo.getID_Service()==null)
		{
			throw new CodingRuntimeException("ConsultantRef and ServiceRef should not be null");
		}
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC left join wLC.hCPs as wLCC where wLC.isActive = 1 and wLCC.hCP.id = :hcp and wLCC.defaultForHCP=1 ");
		
		markers.add("hcp");
		values.add(consultantRef.getID_Hcp());
		
		//WDEV-21153 - comment this  code
//		if (serviceVo.getSpecialty()!=null)
//		{
//			hql.append(" and wLC.service.specialty.id=:Specialty ");
//			markers.add("Specialty");
//			values.add(serviceVo.getSpecialty().getID());
//		}
			hql.append(" and wLC.service.id = :serv "); 
			markers.add("serv");
			values.add(serviceVo.getID_Service());
			//end WDEV-21153
			
		
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		if (startDate!=null && endDate!=null)
		{
			hql.append(" and ((wLC.startDate <= :StartDate and  wLC.endDate is null ) or ( wLC.startDate <= :EndDate and wLC.endDate is null) or (wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) or ( wLC.startDate <= :EndDate and wLC.endDate >= :EndDate) or (wLC.startDate >= :StartDate and wLC.endDate <= :EndDate) )");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
			
			markers.add("EndDate");
			DateTime endDateTime = new DateTime(endDate, new Time(0, 0));
			values.add(endDateTime.getJavaDate());
		}
		else if (startDate!=null && endDate==null)
		{
			hql.append(" and ((wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) or (wLC.startDate <= :StartDate and  wLC.endDate is null )or (wLC.endDate >= :StartDate ) or (wLC.endDate is null) ) ");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	//WDEV-18499
	public Boolean canInactivateConfiguration(ElectiveListConfigurationRefVo configRef)
	{
		if (configRef == null)
		{
			throw new CodingRuntimeException("Cannot get Elective Lists on null configurationRef");
		}

		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer();
		//WDEV-18522 
		hql.append(" SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS elConfig left join pel.electiveListStatus as els left join els.electiveListStatus as lels WHERE elConfig.id = :configID and lels.id <> -2603 ");

		Object[] count = factory.find(hql.toString(), new String[] { "configID" }, new Object[] { configRef.getID_ElectiveListConfiguration() }).toArray();

		if (count != null && count.length > 0)
		{
			if (((Long) count[0]).intValue() == 0)
				return Boolean.FALSE;
		}

		return Boolean.TRUE;
	}

	//WDEV-20064
	public LocationLiteVoCollection listCaseNoteLocationByParentLocation(LocSiteRefVo parentLocSite, String name)
	{
		if (parentLocSite==null)
			return null;
		
        if(name != null)
        {
              String[] arr = null;
              if(name.contains("%"))
              {
                    arr = name.split("%");
                    if(arr.length > 0)
                          name = arr[0] + "%";
                    else
                          name = "%";
              }
        }
       
        DomainFactory factory = getDomainFactory();
        Location doLocation = (Location) factory.getDomainObject(Location.class, parentLocSite.getID_Location());
        ArrayList listItems = new ArrayList();
        buildLocationsList(doLocation, listItems, null, true, name);

        return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(listItems).sort(SortOrder.ASCENDING);

	}

	private void buildLocationsList(Location location, ArrayList<Location> listItems, LocationType type, Boolean isActive, String name)
    {
		if((type == null || location.getType().equals(getDomLookup(type))) 
            && location.isIsActive().equals(isActive) 
            && (name == null || name.equals("%") || location.getUpperName().indexOf(name.toUpperCase()) > -1)
            && (location.isIsVirtual().equals(Boolean.FALSE) || (location.isIsVirtual().equals(Boolean.TRUE) && location.getType().equals(getDomLookup(LocationType.CASE_NOTE_FOLDER_LOCATION)))) //WDEV-20844 - to list also locations of type Case Note Folder Location that are virtual locations
            && Boolean.TRUE.equals(location.isCaseNoteFolderLocation())) 
    	{
            listItems.add(location);
    	}
		
		Iterator it = location.getLocations().iterator();
		while(it.hasNext())
		{
            Location doLocation = (Location) it.next();
            if((type == null || doLocation.getType().equals(getDomLookup(type))) 
                  && doLocation.isIsActive().equals(isActive) 
                  && (name == null || name.equals("%") || doLocation.getUpperName().indexOf(name.toUpperCase()) > -1)
                  && (doLocation.isIsVirtual().equals(Boolean.FALSE) || (doLocation.isIsVirtual().equals(Boolean.TRUE) && doLocation.getType().equals(getDomLookup(LocationType.CASE_NOTE_FOLDER_LOCATION)))) //WDEV-20844 - to list also locations of type Case Note Folder Location that are virtual locations
                  && Boolean.TRUE.equals(doLocation.isCaseNoteFolderLocation())) 
            {
                  listItems.add(doLocation);
            }
            
            buildLocationsList(doLocation, listItems, type, isActive, name);
		}
    }

	
}
