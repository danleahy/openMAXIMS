//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Catalin Tomozei using IMS Development Environment (version 1.51 build 2490.17524)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import java.util.ArrayList;
import java.util.List;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.base.impl.BasePracticeAdminImpl;
import ims.admin.helper.Keywords;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
//import ims.core.domain.ADT;
//import ims.core.domain.impl.ADTImpl;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.GP;
import ims.core.vo.LocSiteVo;
import ims.core.vo.OrgShortVoCollection;
import ims.core.vo.OrganisationVo;
import ims.core.vo.OrganisationVoCollection;
import ims.core.vo.domain.GPAssembler;
import ims.core.vo.domain.LocSiteVoAssembler;
import ims.core.vo.domain.OrgShortVoAssembler;
import ims.core.vo.domain.OrganisationVoAssembler;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.QueueType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.hl7adtout.domain.objects.GPPracticeMessageQueue;
import ims.ocrr.vo.lookups.OrderMessageStatus;
import ims.vo.LookupInstVo;

public class GPPracticeAdminImpl extends BasePracticeAdminImpl
{

	private static final long serialVersionUID = 1L;

	
	public OrgShortVoCollection listSearch(OrganisationVo filter)
	{
		DomainFactory factory = getDomainFactory();
		String andStr = " ";
		StringBuffer clause = new StringBuffer();
 
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
		
		if (filter.getIsActiveIsNotNull() &&
				filter.getIsActive().equals(Boolean.TRUE))
		{
			clause.append(andStr + " org.isActive = :isActive and ");
			names.add("isActive");
			values.add(filter.getIsActive());
		}
		if (filter.getCodeMappingsIsNotNull())
		{
			if (filter.getCodeMappings().size() > 0)
			{
				String hql = " select distinct org from Organisation org join org.codeMappings as mappings" +
						" where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode and org.type = :gpPractice and org.isActive = :isActive";
			
				names.add("taxonomyType");
				names.add("taxonomyCode");
				names.add("gpPractice");
				names.add("isActive");
					
				values.add(getDomLookup(filter.getCodeMappings().get(0).getTaxonomyName()));
				values.add(filter.getCodeMappings().get(0).getTaxonomyCode());
				values.add(getDomLookup(OrganisationType.GPP));
				values.add(filter.getIsActive());
				
				List practices = factory.find(hql, names, values);
				return OrgShortVoAssembler.createOrgShortVoCollectionFromOrganisation(practices);
			}
		}
		
		if (filter.getAddressIsNotNull())
 		{
	  		if (filter.getAddress() != null)
			{
				if (filter.getAddress().getLine1() != null && filter.getAddress().getLine1().length() > 0)
				{
					clause.append(andStr + " (upper(org.address.line1) like :partialAddress ");
					clause.append(" or upper(org.address.line2) like :partialAddress");
					clause.append(" or upper(org.address.line3) like :partialAddress");
					clause.append(" or upper(org.address.line4) like :partialAddress");
					clause.append(" or upper(org.address.line5) like :partialAddress )");

					names.add("partialAddress");
					values.add("%" + filter.getAddress().getLine1().toUpperCase() + "%");
					andStr = " and ";
				}
			}
        }
		
		if (filter.getNameIsNotNull())
		{
			clause.append(andStr + " (org.upperName like :practiceName) and"); //WDEV-20219
			names.add("practiceName");
			values.add(filter.getName().toUpperCase() + "%");
		}
		
		String hql = "select org from Organisation as org where ";
		
		hql += clause.toString();
		
		//gp practices only
		hql += " org.type = :gpPractice";
		names.add("gpPractice");
		values.add(getDomLookup(OrganisationType.GPP));
		
		List practices = factory.find(hql,names,values);
		
		return OrgShortVoAssembler.createOrgShortVoCollectionFromOrganisation(practices);
	}
	
	public OrgShortVoCollection list(Boolean activeOnly)
	{		
		return OrgShortVoAssembler.createOrgShortVoCollectionFromOrganisation(
					getDomainFactory().find("select o1_1 from Organisation as o1_1 where (o1_1.type = -82) "));	
	}
	
	public OrganisationVo getOrg(OrganisationRefVo voOrgRef) 
	{
		if(voOrgRef == null || voOrgRef.getID_Organisation() == null)
		{
			throw new DomainRuntimeException("Invalid record");
		}
		
		DomainFactory factory = getDomainFactory();
		Organisation domainObject = (Organisation)factory.getDomainObject(voOrgRef);
		
		return OrganisationVoAssembler.create(domainObject);
	}
	
	public LocSiteVo getLocSite(LocSiteVo voLocSite) 
	{
		if(voLocSite == null || voLocSite.getID_Location() == null)
		{
			throw new DomainRuntimeException("Invalid record");
		}
		
		DomainFactory factory = getDomainFactory();
		LocSite domainObject = (LocSite)factory.getDomainObject(voLocSite);
		
		return LocSiteVoAssembler.create(domainObject);
	}
	
	public OrganisationVo saveOrg(OrganisationVo orgVo) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!orgVo.isValidated())
			throw new DomainRuntimeException("Org has not been validated");
		
		DomainFactory factory = getDomainFactory();
		Organisation doOrg = OrganisationVoAssembler.extractOrganisation(factory, orgVo);
		if (doOrg == null)
			throw new StaleObjectException(doOrg);
		doOrg.setUpperNames();
		
		try 
		{
			factory.save(doOrg);
		} 
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doOrg, "codeMappings", orgVo.getCodeMappings(), "getName");
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			for (int i = 0; i < orgVo.getLocationSites().size(); i++)
			{
				LocSiteVo lsv = orgVo.getLocationSites().get(i);
				LocSite lsd = LocSiteVoAssembler.extractLocSite(factory, lsv);
				
				dupMessage = Keywords.checkDuplicateTaxonomy(factory, lsd, "codeMappings", lsv.getCodeMappings(), "getName");
				if(dupMessage != null)
					throw new UniqueKeyViolationException(dupMessage);
				
			}
			throw new UniqueKeyViolationException("An Record with this name already exists, Please change", e);
		}
		
		//WDEV-19576 Practice Master File HL7 message
		OrganisationVo assembledOrg = OrganisationVoAssembler.create(doOrg);
		triggerGPPracticeMasterFileEvent(assembledOrg);
		
		return assembledOrg;
		
	}

	//WDEV-19576 MFNM05 HL7 processing for GP Practice master file event
	public void triggerGPPracticeMasterFileEvent(OrganisationRefVo gPPractice) throws StaleObjectException
	{
		if(gPPractice!=null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.GPPRACTICEMASTERFILE.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				GPPracticeMessageQueue messageQueue = new GPPracticeMessageQueue();
				messageQueue.setPractice((Organisation)factory.getDomainObject(gPPractice));
				messageQueue.setProviderSystem(providerSystem);
				messageQueue.setWasProcessed(Boolean.FALSE);
				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				messageQueue.setMsgType(getDomLookup(MsgEventType.M05));
				messageQueue.setQueueType(getDomLookup(QueueType.GPPRACTICEMASTERFILE));
				factory.save(messageQueue);
			}
			
		}
	}

	public void deletePractice(OrganisationVo orgToDelete) throws ForeignKeyViolationException
	{
		if(orgToDelete == null)
			throw new RuntimeException("Cannot delete null OrganisationVo");
			
		DomainFactory factory = getDomainFactory();

		Organisation doOrganisation = OrganisationVoAssembler.extractOrganisation(factory, orgToDelete);
		
		if (doOrganisation.getLocationSites().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Surgeries associated with this Practice. Cannot delete.");
		}
		
		factory.delete(doOrganisation);
	}
	
	public void deletePractice(OrganisationVo orgToDelete, Boolean deleteSurgery) throws ForeignKeyViolationException 
	{
		if (deleteSurgery != null && deleteSurgery.booleanValue()) 
		{
			if(orgToDelete != null && orgToDelete.getLocationSitesIsNotNull() && orgToDelete.getLocationSites().size() == 1)
			{
				orgToDelete = deleteLocSite(orgToDelete.getLocationSites().get(0));
			}
		}

		deletePractice(orgToDelete);
	}

	public OrganisationVo deleteLocSite(LocSiteVo locSiteToDelete) throws ForeignKeyViolationException
	{
		if(locSiteToDelete == null)
			throw new RuntimeException("Cannot delete null LocSiteVo");
		
		DomainFactory factory = getDomainFactory();

		LocSite doLocSite = LocSiteVoAssembler.extractLocSite(factory, locSiteToDelete);

		if(doLocSite==null)
			return null;
		
		Organisation doParentOrganisation = doLocSite.getParentOrganisation();
	
		if (doParentOrganisation != null)
			doParentOrganisation.getLocationSites().remove(doLocSite);
		//WDEV-12000 
		else
			return null;

		factory.delete(doLocSite);
		return OrganisationVoAssembler.create(doParentOrganisation); 
	}

	public String[] listGps(OrganisationRefVo organisationRefVo)
	{
		if(organisationRefVo == null)
			return null;
		
		StringBuffer hql = new StringBuffer();
		hql.append("select distinct  g1_1.name.forename, g1_1.name.surname");
		hql.append(" from Gp as g1_1 left join g1_1.practices as g2_1 left join g2_1.practice as o1_1");
		hql.append(" where ");
		hql.append("(o1_1.id = :ORG_ID)");
		hql.append("and g1_1.isRIE is null");
		
		DomainFactory factory = getDomainFactory();
		List list = factory.find(hql.toString(), "ORG_ID", organisationRefVo.getID_Organisation());
		
		String[] gpNames = new String[list.size()];
		for (int i = 0; i < list.size(); i++)
		{
			Object[] element = (Object[]) list.get(i);
			StringBuffer sb = new StringBuffer();
			if(element != null && element.length >= 1)
			{
				if(element[0] instanceof String)
				{
					sb.append((String)element[0]);
					sb.append(" ");
				}
				if(element[1] instanceof String)
					sb.append((String)element[1]);
			}
			gpNames[i] = sb.toString();
		}
		
		return gpNames;
	}



	public OrganisationVoCollection listPracticeParents(String value,
			Boolean activeOnly)
	{
		if (ConfigFlag.UI.DEMOGRAPHICS_TYPE.getValue().equals("UK"))
		{
			OrganisationAndLocation organisationAndLocation = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
			return organisationAndLocation.listPCTs(value, activeOnly);
		}
		// TODO Auto-generated method stub
		return null;
	}
	//wdev-11819
	public String[] listPatients(LocSiteVo locationsite) 
	{
		if(locationsite == null)
			return null;
				
		StringBuffer hql = new StringBuffer();
		hql.append(" select p1_1.name.surname ");
		hql.append(" from Patient as p1_1 left join p1_1.gp as g1_1 left join g1_1.practices as g2_1 left join g2_1.practice as o1_1 left join o1_1.locationSites as l1_1");
		hql.append(" where ");
		hql.append("(l1_1.id = :LOC_ID)");
		hql.append(" and p1_1.isRIE is null");
		
		DomainFactory factory = getDomainFactory();
		List list = factory.find(hql.toString(), "LOC_ID", locationsite.getID_Location());
		
		String[] gpNames = new String[list.size()];
		for (int i = 0; i < list.size(); i++)
		{
			Object element = (Object) list.get(i);
			StringBuffer sb = new StringBuffer();
			if(element != null )
			{
				if(element instanceof String)
				{
					sb.append((String)element);
					sb.append(" ");
				}
				
			}
			gpNames[i] = sb.toString();
		}
		
		return gpNames;

	}	
	//-------------

	//WDEV-15663
	public OrganisationVo getPractice(OrganisationRefVo practiceRef)
	{
		if(practiceRef == null || practiceRef.getID_Organisation() == null)
		{
			throw new DomainRuntimeException("Invalid record");
		}
		
		DomainFactory factory = getDomainFactory();
		 Organisation domainObject = (Organisation)factory.getDomainObject(Organisation.class, practiceRef.getID_Organisation());
		
		return OrganisationVoAssembler.create(domainObject);
	}
}
