//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.62 build 3040.26452)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.pci.domain.impl;

import java.text.DecimalFormat;
import java.util.List;

import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.GpRefVo;
import ims.core.vo.PatientId;
import ims.core.vo.PatientIdCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.domain.PatientIdAssembler;
import ims.core.vo.lookups.PatIdType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.hibernate3.IMSCriteria;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.pci.domain.FamilyRecords;
import ims.pci.domain.RecordingScheduling;
import ims.pci.domain.base.impl.BaseClientDemographicsImpl;
import ims.pci.domain.objects.ClientImmunisationSchedule;
import ims.pci.vo.ClientAddressVo;
import ims.pci.vo.ClientImmunisationScheduleVoCollection;
import ims.pci.vo.ClientVo;
import ims.pci.vo.GpContractVo;
import ims.pci.vo.domain.ClientImmunisationScheduleVoAssembler;
import ims.pci.vo.domain.ClientVoAssembler;
import ims.pci.vo.lookups.VaccineStatus;
import ims.vo.LookupInstVo;

public class ClientDemographicsImpl extends BaseClientDemographicsImpl
{

	private static final long serialVersionUID = 1L;

	public ClientVo getClientFull(PatientShort clientShort)	throws StaleObjectException 
	{
		if(clientShort == null)
			throw new DomainRuntimeException("Client not provided for get call.");
		
		Patient clientDO = getDomPatient(clientShort);
		
		if (clientDO == null)
			return null;
		
		ClientVo clientFound = ClientVoAssembler.create(clientDO);
		
		return clientFound;
	}
	private Patient getDomPatient(PatientShort patVo)	
	{
		DomainFactory factory = getDomainFactory();

		if (patVo.getID_PatientIsNotNull())
		{
			return (Patient) factory.getDomainObject(Patient.class, patVo.getID_Patient().intValue());
		}

		if (patVo.getIdentifiers() == null || patVo.getIdentifiers().size() == 0 || (patVo.getIdentifiers().get(0)) == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid identifier");
		}	
		
		Patient domPatient=null;
		PatientId intfId = null;
		int i=0;
		
		String hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue ";
		
		while (domPatient == null)
		{
			intfId = patVo.getIdentifiers().get(i);
			java.util.List patientList = factory.find(hql, new String[]{"idValue", "idType"}, new Object[]{intfId.getValue(), getDomLookup(intfId.getType())});
			if (patientList != null && !patientList.isEmpty())
			{
				// 	Patient Should be unique per id value and type
				if (patientList.size() > 1)
				{
					throw new DomainRuntimeException("More than one patient found with identifier type = " + intfId.getType() + " and value = " + intfId.getValue());
				}
				domPatient = (Patient) patientList.get(0);
			}
			i++;
			if (i >= patVo.getIdentifiers().size())
				break;
		}
		
		return domPatient;
	}
	
	public ClientVo saveClient(ClientVo client) throws StaleObjectException, UniqueKeyViolationException 
	{
		if (!client.isValidated())
		{
			throw new DomainRuntimeException("ClientVo has not been validated!");
		}
		
		if (client.getIsActive() == null)
		{
			client.setIsActive(Boolean.TRUE);
		}
		
		//WDEV-5399
		if(client.getCommunityCareIsNotNull())
		{
			if(client.getCommunityCare().getIsExtractedIsNotNull() &&  client.getCommunityCare().getIsExtracted())
			{
				client.getCommunityCare().setIsExtracted(false);
			}
			else
			{
				PatientId patientIdentifier = client.getPatientIdentifier(PatIdType.GMSID);
				
				if(patientIdentifier != null && patientIdentifier.getValue() != null && patientIdentifier.getValue().length() > 0)
				{
					client.getCommunityCare().setIsExtracted(false);
				}
			}
		}
		
		DomainFactory factory = getDomainFactory();
		
		Patient domClient = ClientVoAssembler.extractPatient(factory, client);
		
		try
		{
			domClient.getIdentifiers().clear();
			List lst = PatientIdAssembler.extractPatientIdList(factory, client.getIdentifiers());
			domClient.setIdentifiers(lst);
			
			// wdev-4932
			boolean clientIdRequired=true;
			if (domClient.getId() != null)
				clientIdRequired=false;
				
			factory.save(domClient);
			
			// wdev-4932 - now that the client has been saved, we use the identifier to generate the clientId
			// If not a new patient, but there is no clientId for this client, we want to generate it too
			if (!clientIdRequired)
			{
				int i=0;
				for (i=0; i<domClient.getIdentifiers().size(); i++)
				{
					ims.core.patient.domain.objects.PatientId clientId = (ims.core.patient.domain.objects.PatientId) domClient.getIdentifiers().get(i);
					if (clientId != null && clientId.getType() != null && clientId.getType().getId() == PatIdType.CLIENTID.getId())
						break;
				}
				if (i >= domClient.getIdentifiers().size())
					clientIdRequired=true;
			}
			
			
			if (clientIdRequired)
			{
				ims.core.patient.domain.objects.PatientId clientId = new ims.core.patient.domain.objects.PatientId();
				clientId.setValue(generateClientId(domClient.getId()));
				clientId.setType(getDomLookup(new LookupInstVo(PatIdType.CLIENTID.getId())));
				domClient.getIdentifiers().add(clientId);
			}
		}
		catch (UnqViolationUncheckedException e)
		{
			PatientId voPatId = null;
			for (int i = 0; i < client.getIdentifiers().size(); i++)
			{
				voPatId = client.getIdentifiers().get(i);
				PatientIdCollection voCollIds = new PatientIdCollection();
				voCollIds.add(voPatId);
				ClientVo voPatFilter = new ClientVo();
				voPatFilter.setIdentifiers(voCollIds);
				if((voPatFilter = getClientFull(voPatFilter)) != null)
				{	 
					if(!voPatFilter.getID_Patient().equals(domClient.getId()))  
					{
						throw new UniqueKeyViolationException("A Patient with this " + voPatId.getType().getText() + " already exists", e);
					}
				}
			}
			throw new UniqueKeyViolationException("A Unique Constraint Violation Exception has occurred. Cause is unknown. Possible Data Corruption.", e);
		}
		
		return ClientVoAssembler.create(domClient);
	}
	
	private String generateClientId(int patientId) 
	{
		DecimalFormat myFormatter = new DecimalFormat("00000000");
		String output = myFormatter.format(patientId);
		 
		String generatedID = ims.configuration.gen.ConfigFlag.GEN.PCI_CLIENT_PREFIX.getValue() + output;
		
		return generatedID;
	}
	
	public GpContractVo getGPContract(GpRefVo gp, Date date) 
	{
		RecordingScheduling impl = (RecordingScheduling) getDomainImpl(RecordingSchedulingImpl.class);
		return impl.getGpContract(gp, date);
	}
	
	public Boolean isParent(PatientRefVo client) 
	{
		if(client == null || (client != null && !client.getID_PatientIsNotNull()))
			return false;
		
		FamilyRecords impl = (FamilyRecords) getDomainImpl(FamilyRecordsImpl.class);
		
		PatientShortCollection childs = impl.listChilds(client);
		
		if(childs != null && childs.size() > 0)
		{
			return true;
		}
		return false;
	}
	
	public Boolean allowRecordDateOfDeath(PatientRefVo client) 
	{
		if(client == null || !client.getID_PatientIsNotNull())
			throw new CodingRuntimeException("Client is null or id not provided in method allowRecordDateOfDate.");
		
		DomainFactory factory = getDomainFactory();
		
		IMSCriteria criteria = new IMSCriteria(ClientImmunisationSchedule.class, factory);
		criteria.equal("this.client.id", client.getID_Patient());
		
		criteria.join("this.vaccineSummaryStatus", "vaccStatus");
		criteria.join("vaccStatus.currentStatus", "currStatus");
		criteria.join("currStatus.status", "st");
		
		criteria.in("st.id", new Integer[] {VaccineStatus.SCHEDULED.getID(), VaccineStatus.STARTED.getID()});
		
		ClientImmunisationScheduleVoCollection coll = ClientImmunisationScheduleVoAssembler.createClientImmunisationScheduleVoCollectionFromClientImmunisationSchedule(criteria.find());
		
		return (coll!= null && coll.size() > 0) ? false : true;
	}
}
