//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
//This code was generated by George Cristian Josan using IMS Development Environment (version 1.62 build 3070.24992)
//Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.pci.forms.addscheduleconfigurationdialog;

import java.util.ArrayList;

import ims.core.vo.MemberOfStaffLiteVo;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.framework.MessageButtons;
import ims.framework.enumerations.DialogResult;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.exceptions.FormOpenException;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.DateTime;
import ims.pci.forms.addscheduleconfigurationdialog.GenForm.grdSchedulesRow;
import ims.pci.vo.ClientImmunisationScheduleVo;
import ims.pci.vo.ClientLiteVo;
import ims.pci.vo.ClientPCIScheduleProfileVo;
import ims.pci.vo.ScheduleConfigurationRefVoCollection;
import ims.pci.vo.ScheduleConfigurationVo;
import ims.pci.vo.ScheduleConfigurationVoCollection;
import ims.pci.vo.lookups.ScheduleType;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//	EVENTS REGION
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		initialize();
		open();
	}

	@Override
	protected void onMessageBoxClosed(int messageBoxId, DialogResult result) throws PresentationLogicException
	{
		if (form.getLocalContext().getWarningMessageBoxIDIsNotNull())
		{
			if (form.getLocalContext().getWarningMessageBoxID().equals(messageBoxId) && DialogResult.YES.equals(result))
			{
				if (form.getGlobalContext().PCI.getClientImmunisationScheduleIsNotNull() == false)
				{
					engine.showMessage("Please define a valid schedule for this client first!");
					return;
				}
				
				try
				{
					form.getGlobalContext().PCI.getClientImmunisationSchedule().addSchedule(form.grdSchedules().getValue(), (MemberOfStaffLiteVo) domain.getMosUser(), new DateTime());
				}
				catch (IllegalArgumentException e)
				{
					engine.showMessage(e.getMessage());
					return;
				}

				if (save())
					engine.close(DialogResult.OK);
			}
			else
			{
				open();
			}
		}
	}

	@Override
	protected void onBtnSaveClick() throws ims.framework.exceptions.PresentationLogicException
	{
		if (form.getGlobalContext().PCI.getClientImmunisationScheduleIsNotNull())
		{
			if (updateSchedule())
				engine.close(DialogResult.OK);
		}
		else
		{
			if (newSchedule())
				engine.close(DialogResult.OK);
		}
	}



	public String[] validateWarnings()
	{
		if (form.getGlobalContext().Core.getPatientShort() == null)
			throw new CodingRuntimeException("Major Logical Error - A patient must be selected to add a schedule");

		ArrayList<String> listOfWarnings = new ArrayList<String>();

		if (form.getGlobalContext().PCI.getClientImmunisationSchedule() == null)
		{
			try
			{
				ClientLiteVo client = domain.getClient(form.getGlobalContext().Core.getPatientShort());
				if (client == null)
					throw new CodingRuntimeException("Major Logical Error - Selected client does not exist in the data base");

				if (client.getDob() != null)
				{
					ScheduleConfigurationVo schedule = form.grdSchedules().getValue();
					if (client.getDob().isLessThan(schedule.getStartDob()) || (schedule.getEndDob() == null ? false : client.getDob().isGreaterThan(schedule.getEndDob())))
					{
						listOfWarnings.add("Client Date of Birth is outside schedule range of DOB.");
					}
				}
			}
			catch (DomainInterfaceException e)
			{
				engine.showMessage(e.getMessage());
				return null;
			}
		}
		else
		{
			ClientLiteVo client = form.getGlobalContext().PCI.getClientImmunisationSchedule().getClient();

			if (client == null)
				throw new CodingRuntimeException("Major Logical Error - A client must be set in the ClientImmunisationScheduleVo");

			if (client.getDob() != null)
			{
				ScheduleConfigurationVo schedule = form.grdSchedules().getValue();
				if (client.getDob().isLessThan(schedule.getStartDob()) || (schedule.getEndDob() == null ? false : client.getDob().isGreaterThan(schedule.getEndDob())))
				{
					listOfWarnings.add("Client Date of Birth is outside schedule range of DOB.");
				}
			}
		}


		int errorCount = listOfWarnings.size();
		if (errorCount == 0)
			return null;

		String[] result = new String[errorCount];
		for(int x = 0; x < errorCount; x++)
			result[x] = (String)listOfWarnings.get(x);

		return result;
	}

	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		form.getGlobalContext().PCI.setClientAddSchedule(null);
		engine.close(DialogResult.CANCEL);
	}


	@Override
	protected void onGrdSchedulesSelectionChanged() throws PresentationLogicException
	{
		updateControlsState();
	}

	@Override
	protected void onGrdSchedulesSelectionCleared() throws PresentationLogicException
	{
		updateControlsState();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//	FORM LOGIC METHODS
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	@Override
	public void initialize() throws FormOpenException
	{
		form.getGlobalContext().PCI.setClientAddSchedule(null);
	}

	public void open() throws ims.framework.exceptions.PresentationLogicException
	{
		ScheduleConfigurationRefVoCollection clientSchedules = getSchedules();

		try
		{
			setGridSchedules(domain.listSchedules(clientSchedules));

			if (form.grdSchedules().getRows().size() <= 0)
			{
				engine.showMessage("No other schedules defined were found. Define new schedules if you want to add other schedules");
			}
		}
		catch (DomainInterfaceException e)
		{
			engine.showMessage(e.getMessage());
		}

		updateControlsState();
	}

	private void setGridSchedules(ScheduleConfigurationVoCollection listSchedules)
	{
		clearInstanceControls();

		if (listSchedules == null)
			return;

		for (int i = 0; i < listSchedules.size(); i++)
		{
			ScheduleConfigurationVo scheduleConfigurationVo = listSchedules.get(i);
			if (scheduleConfigurationVo != null)
			{
				grdSchedulesRow row = form.grdSchedules().getRows().newRow();
				row.setValue(scheduleConfigurationVo);

				row.setColScheduleName(scheduleConfigurationVo.getScheduleName());
				row.setColStartDOB(scheduleConfigurationVo.getStartDob());
				row.setColEndDOB(scheduleConfigurationVo.getEndDob());
			}
		}
	}


	public void newInstance() throws ims.framework.exceptions.PresentationLogicException
	{
	}

	public void updateInstance()
	{
	}

	public boolean save() throws ims.framework.exceptions.PresentationLogicException
	{
		ClientImmunisationScheduleVo clientImmunisationSchedule = form.getGlobalContext().PCI.getClientImmunisationSchedule();

		// Should not occur - a client immunisation schedule should be defined at this point
		if (clientImmunisationSchedule == null)
			throw new CodingRuntimeException("Major Logical Error - Can not save a null client immunisation schedule");

		// Validate the VO
		String[] validationErrors = clientImmunisationSchedule.validate();

		if (validationErrors != null && validationErrors.length != 0)
		{
			engine.showErrors(validationErrors);
			return false;
		}

		// Attempt to save the VO
		try
		{
			clientImmunisationSchedule = domain.saveClientImmunisationScheduleVo(clientImmunisationSchedule);
			form.getGlobalContext().PCI.setClientImmunisationSchedule(clientImmunisationSchedule);
		}
		catch (DomainInterfaceException e)
		{
			engine.showMessage(e.getMessage());
			return false;
		}
		catch (StaleObjectException e)
		{
			engine.showMessage(ims.configuration.gen.ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			open();
			return false;
		}
		catch (ForeignKeyViolationException e)
		{
			engine.showMessage(e.getMessage());
			return false;
		}
		catch (UniqueKeyViolationException e)
		{
			engine.showMessage(e.getMessage());
			return false;
		}

		return true;
	}

	public void clearInstanceControls()
	{
		form.grdSchedules().getRows().clear();
	}

	public void updateControlsState()
	{
		form.btnSave().setEnabled(form.grdSchedules().getValue() != null);
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//	ALGORITHM FUNCTIONS
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private boolean newSchedule() throws PresentationLogicException
	{
		if (form.getGlobalContext().PCI.getClientImmunisationScheduleIsNotNull())
			throw new CodingRuntimeException("Major Logical Error - Funtion newInstance() is called only to create a new ClientImmunisationSchedule");

		try
		{
			ClientLiteVo client = domain.getClient(form.getGlobalContext().Core.getPatientShort());
			ClientImmunisationScheduleVo schedule = new ClientImmunisationScheduleVo();
			schedule.setClient(client);
			form.getGlobalContext().PCI.setClientImmunisationSchedule(schedule);

			String[] warningsConfirmation = validateWarnings();
			if (warningsConfirmation != null && warningsConfirmation.length != 0)
			{
				String warning = "";
				for (int i = 0; i < warningsConfirmation.length; i++)
				{
					if (warningsConfirmation[i] != null)
					{
						warning += warningsConfirmation[i] + "\n";
					}
				}
				warning += "Do you want to save?";

				form.getLocalContext().setWarningMessageBoxID(engine.showMessage(warning, "Please Confirm", MessageButtons.YESNO));
				return false;
			}

			try
			{
				form.getGlobalContext().PCI.getClientImmunisationSchedule().addSchedule(form.grdSchedules().getValue(), (MemberOfStaffLiteVo) domain.getMosUser(), new DateTime());
			}
			catch (IllegalArgumentException e)
			{
				engine.showMessage(e.getMessage());
				return false;
			}

			return save();
		}
		catch (DomainInterfaceException e)
		{
			engine.showMessage(e.getMessage());
			return false;
		}
	}

	private boolean updateSchedule() throws PresentationLogicException
	{
		ClientImmunisationScheduleVo clientImmunisationSchedule = form.getGlobalContext().PCI.getClientImmunisationSchedule();
		if (clientImmunisationSchedule == null)
			throw new CodingRuntimeException("Major Logical Error - Funtion updateInstance() is called only to add a schedule to ClientImmunisationSchedule");
		
		String[] conflictErrors = clientImmunisationSchedule.getConflictErrors(form.grdSchedules().getValue());
		
		if (conflictErrors != null && conflictErrors.length > 0)
		{
			engine.showErrors(conflictErrors);
			return false;
		}

		String[] warningsConfirmation = validateWarnings();
		if (warningsConfirmation != null && warningsConfirmation.length != 0)
		{
			String warning = "";
			for (int i = 0; i < warningsConfirmation.length; i++)
			{
				if (warningsConfirmation[i] != null)
				{
					warning += warningsConfirmation[i] + "\n";
				}
			}
			warning += "Do you want to save?";

			form.getLocalContext().setWarningMessageBoxID(engine.showMessage(warning, "Please Confirm", MessageButtons.YESNO));
			return false;
		}

		try
		{
			clientImmunisationSchedule.addSchedule(form.grdSchedules().getValue(), (MemberOfStaffLiteVo) domain.getMosUser(), new DateTime());
		}
		catch (IllegalArgumentException e)
		{
			engine.showMessage(e.getMessage());
			return false;
		}

		return save();
	}

	private ScheduleConfigurationRefVoCollection getSchedules()
	{
		ClientImmunisationScheduleVo clientImmunisationSchedule = form.getGlobalContext().PCI.getClientImmunisationSchedule();
		if (clientImmunisationSchedule == null)
			return null;

		if (clientImmunisationSchedule.getScheduleProfiles() == null)
			return null;

		ScheduleConfigurationRefVoCollection refSchedules = new ScheduleConfigurationRefVoCollection();

		for (int i = 0; i < clientImmunisationSchedule.getScheduleProfiles().size(); i++)
		{
			ClientPCIScheduleProfileVo scheduleProfile = clientImmunisationSchedule.getScheduleProfiles().get(i);
			if (scheduleProfile == null)
				continue;
			
			if (Boolean.TRUE.equals(scheduleProfile.getIsDeleted()))
				continue;

			ScheduleConfigurationVo schedule = scheduleProfile.getSchedule();
			if (schedule == null)
				continue;
			
			if (!ScheduleType.PCISCHEDULE.equals(schedule.getScheduleType()))
				continue;
			
			refSchedules.add(schedule);
		}

		return refSchedules;
	}
}
