//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.70 build 3467.22451)
// Copyright (C) 1995-2009 IMS MAXIMS. All rights reserved.

package ims.clinical.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.PatientSearchConfiguration;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.domain.impl.PatientSearchConfigurationImpl;
import ims.admin.vo.AppointmentTrackingstatusColourConfigVo;
import ims.admin.vo.PDSConfigurationVo;
import ims.admin.vo.domain.AppointmentTrackingstatusColourConfigVoAssembler;
import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.CatsReferralVo;
import ims.RefMan.vo.PatientElectiveListForDNAAppointmentsVo;
import ims.RefMan.vo.TCIForPatientElectiveListAppointmentDNAVo;
import ims.RefMan.vo.domain.CatsReferralBreachDatesVoAssembler;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.CatsReferralVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForDNAAppointmentsVoAssembler;
import ims.RefMan.vo.domain.TCIForPatientElectiveListAppointmentDNAVoAssembler;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ERODStatus;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.domain.base.impl.BaseClinicListWithICPActionsImpl;
import ims.clinical.helper.HL7ClinicListWithICPActions;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.AppointmentTrackingstatusColourConfig;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.domain.PDSDemographics;
import ims.core.domain.impl.PDSDemographicsImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Activity;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ActivityWithImageLiteVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.IPandOPSearchCriteriaVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.MissingMappingVoCollection;
import ims.core.vo.Patient;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceLiteVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.ActivityWithImageLiteVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IAppRole;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.icp.vo.OutpatientEpisodeWithICPInfoVo;
import ims.icp.vo.OutpatientEpisodeWithICPInfoVoCollection;
import ims.icp.vo.domain.OutpatientEpisodeWithICPInfoVoAssembler;
import ims.icp.vo.domain.PatientICPLiteVoAssembler;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.PauseDetails;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientEventVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.AppointmentOutcomeDialog;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.AppointmentOutcomeDialogImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Appt_Tracking_Status_History;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.helper.CABRequests;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionServiceAndSlotActivityVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.domain.Appt_Tracking_Status_HistoryVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.lookups.CancelAppointmentReason;
import ims.scheduling.vo.lookups.LookupHelper;
import ims.scheduling.vo.lookups.OutcomeAction;
import ims.scheduling.vo.lookups.ProfileListType;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;



public class ClinicListwithICPActionsImpl extends BaseClinicListWithICPActionsImpl implements HL7ClinicListWithICPActions
{

	private static final long serialVersionUID = 1L;
	private static final int PATIENT_DNA_NAT_CODE = 33;
	private static final Logger			LOG		= Logger.getLogger(ClinicListwithICPActionsImpl.class);

	/**
	 * Get PatientShort
	 */
	public ims.core.vo.PatientShort getPatientShort(ims.core.patient.vo.PatientRefVo voPatientRef)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatientRef.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}

	public LocationLiteVoCollection getActiveHospitals(MemberOfStaffRefVo mos)
	{
		if (mos == null || !mos.getID_MemberOfStaffIsNotNull())
			return null;

		StringBuilder query = new StringBuilder();
		query.append("select location from MemberOfStaff as mos left join mos.locations as hcpLocation left join hcpLocation.location as location ");
		query.append(" where location.type = :LocType and location.isActive = :isActive and location.isVirtual = :isVirtual and mos.id = :mosID");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("LocType");
		paramValues.add(getDomLookup(LocationType.HOSP));

		paramNames.add("isActive");
		paramValues.add(Boolean.TRUE);

		paramNames.add("isVirtual");
		paramValues.add(Boolean.FALSE);

		paramNames.add("mosID");
		paramValues.add(mos.getID_MemberOfStaff());

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(query.toString(), paramNames, paramValues)).sort();
	}

	/**
	 * Select all booking appointments records that match the search criteria and associate them the ICP Information if it exists,
	 * associate latest Appt_Tracking_Status_History record if it exists, and associate AppointmentTrackingstatusColourConfig
	 * record corresponding to Appt_Tracking_Status_History record associated if it exists
	 */
	@SuppressWarnings("rawtypes")
	public OutpatientEpisodeWithICPInfoVoCollection listOPEpisodes(IPandOPSearchCriteriaVo searchCriteria)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		// WDEV-12909
		// Get the AppointmentTrackingStatusConfig records from data base (the actual number should be less than 10, about 6)
		List appointmentTrackingStatusConfig = getDomainFactory().find(" from AppointmentTrackingstatusColourConfig");

		StringBuffer query = new StringBuffer();

		query.append("SELECT icp, appts, apptTrackStatus");
		query.append(", referral");
		query.append(" FROM PatientICP AS icp RIGHT JOIN icp.appointments AS appts LEFT JOIN appts.apptTrackingStatusHistory AS apptTrackStatus LEFT JOIN icp.careContext AS icpContext");
		query.append(", CatsReferral AS referral LEFT JOIN referral.appointments AS refAppt");
		
		//WDEV-18439
		if (searchCriteria.getApptOutcome() != null || searchCriteria.getAppointmentAction() != null || Boolean.TRUE.equals(searchCriteria.getComplete()))
		{
			query.append(" LEFT JOIN appts.outcome AS apptOutcome LEFT JOIN appts.outcomeActions AS outcomeAct LEFT JOIN outcomeAct.appointmentAction AS apptAction LEFT JOIN outcomeAct.outcomeOfAction AS outcomeAction");
			
			//WDEV-18664 WDEV-23836
			if (searchCriteria.getApptDateFrom() != null || searchCriteria.getApptDateTo()!= null)
			{
				query.append(" LEFT JOIN outcomeAct.futureAppointmentDetail AS futureApptDetails") ;
			}
		}
		//WDEV-19320
		if (searchCriteria.getListOwnersIsNotNull() && searchCriteria.getListOwners().size() > 0)
		{
			query.append(" LEFT JOIN appts.session.listOwners as owners") ;
		}
		
		//WDEV-20463 Filter by scheduled session list type
		if(searchCriteria.getListType() != null)
		{
			query.append(" LEFT JOIN appts.session.listType as listType") ;
		} //WDEV-20463
		
		query.append(" WHERE ");
		query.append(" refAppt.id = appts.id AND ");
		query.append(" (apptTrackStatus.id is null or ");
		query.append(" apptTrackStatus.id = (select max(th.id) from Booking_Appointment as ba join ba.apptTrackingStatusHistory as th where ba.id = appts.id))");

		if (searchCriteria.getClinicIsNotNull())
		{
			query.append(" and appts.session.id = :clinic");
			markers.add("clinic");
			values.add(searchCriteria.getClinic().getID_Sch_Session());
		}
		else
		{
			//WDEV-20579
			if (searchCriteria.getHospital() != null)
			{
				String ids = getLocationsIdsForHospital(searchCriteria.getHospital().getID_Location());
				query.append(" and appts.session.schLocation.id in ( " + ids + " )");
			}

			if (searchCriteria.getDate() != null)
			{
				query.append(" and appts.session.sessionDate = :sessionDate");
				markers.add("sessionDate");
				values.add(searchCriteria.getDate().getDate());
			}

			query.append(" and appts.session.isActive = :isActive");
			markers.add("isActive");
			values.add(Boolean.TRUE);

			query.append(" and appts.session.sessionProfileType.id = :OUTPATIENT_SESSION");
			markers.add("OUTPATIENT_SESSION");
			values.add(SchProfileType.OUTPATIENT.getID());
		}
		//WDEV-19320
		if (searchCriteria.getServiceIsNotNull())
		{
			query.append(" and appts.session.service.id = :idService");
			markers.add("idService");
			values.add(searchCriteria.getService().getID_Service());
		}
		//wdev-19503
		if( searchCriteria.getOutPatientLocationIsNotNull())
		{
			query.append(" and appts.session.schLocation.id = :idLocationO");
			markers.add("idLocationO");
			values.add(searchCriteria.getOutPatientLocation().getID_Location());
		}
		//-----------
		//WDEV-19320
		if (searchCriteria.getListOwnersIsNotNull() && searchCriteria.getListOwners().size() > 0)
		{
			query.append(" and owners.hcp.id in (" + getListOwnersIds(searchCriteria.getListOwners()) + ")");			
		}
		if (searchCriteria.getApptOutcome() != null)
		{
			query.append(" and apptOutcome.id = :apptOutcomeID");
			markers.add("apptOutcomeID");
			values.add(searchCriteria.getApptOutcome().getID());
		}

		if (searchCriteria.getAppointmentAction() != null)
		{
			query.append(" and apptAction.id = :appointmentActionID");
			markers.add("appointmentActionID");
			values.add(searchCriteria.getAppointmentAction().getID());
		}

		//WDEV-20463 Filter by scheduled session list type
		if (searchCriteria.getListType() != null)
		{
			query.append (" and listType.id = :listTypeId");
			markers.add("listTypeId");
			values.add(searchCriteria.getListType().getID());
		} //WDEV-20463
		
		if (Boolean.TRUE.equals(searchCriteria.getComplete()))
		{
			query.append(" and outcomeAction.id = :completedOutcomeId");
			markers.add("completedOutcomeId");
			values.add(OutcomeAction.DONE_NOW.getID());
		}

		//WDEV-18664
		if (searchCriteria.getApptDateFrom() != null)
		{
			query.append(" and  futureApptDetails._1stApptFutureApptByDate >= :fromDate");
			markers.add("fromDate");
			values.add(searchCriteria.getApptDateFrom().getDate());
			
		}
		
		if (searchCriteria.getApptDateTo() != null)
		{
			query.append(" and  futureApptDetails._1stApptFutureApptByDate <= :toDate");
			markers.add("toDate");
			values.add(searchCriteria.getApptDateTo().getDate());
		}
		
		query.append(" and appts.apptStatus.id != :CAN_ID ");//WDEV-12965
		
		markers.add("CAN_ID");
		values.add(Status_Reason.CANCELLED.getID());
		
		java.util.List list = getDomainFactory().find(query.toString(), markers, values, 500);
		Iterator it = list.iterator();
		OutpatientEpisodeWithICPInfoVoCollection voColl = new OutpatientEpisodeWithICPInfoVoCollection();

		while (it.hasNext())
		{
			Object[] lstItem = (Object[]) it.next();
			
			Booking_Appointment doOP = (Booking_Appointment) lstItem[1];
			
			// Populate database mapped fields
			OutpatientEpisodeWithICPInfoVo voOPEpis = OutpatientEpisodeWithICPInfoVoAssembler.create(doOP);
			
			// Set ICP Information
			if (lstItem[0] instanceof PatientICP)
			{
				PatientICP domPatientICP = (PatientICP) lstItem[0];
				
				voOPEpis.setICPInfo(PatientICPLiteVoAssembler.create(domPatientICP));
			}
			
			// Set Appointment Tracking Status field from appointment
			if (lstItem[2] instanceof Appt_Tracking_Status_History)
			{
				Appt_Tracking_Status_History domApptTrackingHistory = (Appt_Tracking_Status_History) lstItem[2];
				
				voOPEpis.setCurrentApptTrakingStatus(Appt_Tracking_Status_HistoryVoAssembler.create(domApptTrackingHistory));
				
				// Set Appointment Tracking Status Colour Configuration record
				if (appointmentTrackingStatusConfig != null)
				{
					for (int i = 0; i < appointmentTrackingStatusConfig.size(); i++)
					{
						if (appointmentTrackingStatusConfig.get(i) instanceof AppointmentTrackingstatusColourConfig)
						{
							AppointmentTrackingstatusColourConfig domColourConfig = (AppointmentTrackingstatusColourConfig) appointmentTrackingStatusConfig.get(i);
							
							if (domColourConfig.getTrackingStatus().getId() == domApptTrackingHistory.getTrackingStatus().getId())
							{
								voOPEpis.setAppointmentTrackingStatus(AppointmentTrackingstatusColourConfigVoAssembler.create(domColourConfig));
							}
						}
					}
				}
			}
			
			// WDEV-15944 - Get the CatsReferral for this appointment
			if (lstItem[3] instanceof CatsReferral)
			{
				voOPEpis.setReferral(CatsReferralBreachDatesVoAssembler.create((CatsReferral) lstItem[3]));
			}
			//WDEV-19207
			String bookingCommentsForAppt = getBookingCommentForAppt(doOP);
			voOPEpis.setBookingComments(bookingCommentsForAppt);
			//WDEV-19207---------------
			
			voColl.add(voOPEpis);
		}
		
		return voColl;
	}
	//WDEV-19207
	private String getBookingCommentForAppt(Booking_Appointment apptDO)
	{
		if (apptDO == null)
			return null;
		Object obj = getDomainFactory().find("select sch.bookingComments from Sch_Booking as sch left join sch.appointments as appts where appts.id = :APPTID", new String[]{"APPTID"},new Object[]{apptDO.getId()}).get(0);

		return obj != null && obj instanceof String ? (String)obj : null;

	}
	//WDEV-19320
	private String getListOwnersIds(HcpLiteVoCollection listOwners)
	{
		if (listOwners == null || listOwners.size() ==0)
			return null;
		StringBuilder ids = new StringBuilder();
		String comma ="";
		for (HcpLiteVo listOwner :listOwners)
		{
			if (listOwner == null || listOwner.getID_Hcp() == null)
				continue;
			ids.append(comma + String.valueOf(listOwner.getID_Hcp().intValue()));
			comma = ", ";			
		}

		return ids.toString();
	}
	
	
	public SessionShortVoCollection listClinics(Integer hospital, Date date, ProfileListType listType) 	//wdev-19419
	{
		
		DomainFactory factory = getDomainFactory();
		
		String ids = getLocationsIdsForHospital(hospital);
		
		String query = " from Sch_Session session where session.schLocation.id in ( " + ids + " ) and session.sessionProfileType.id = :OUTPATIENT and session.sessionDate = :sessionDate and session.isActive = :isActive ";
		
		if( listType != null )	
		{
			query += " and session.listType.id = :idListType ";
		}
		
		query += " ORDER BY session.name ASC ";
		
		//WDEV-20463 
//    	return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(query, new String[]{"OUTPATIENT", "sessionDate", "isActive"}, new Object[]{SchProfileType.OUTPATIENT.getID(), date.getDate(), Boolean.TRUE}));
		if (listType != null)
		{
			return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(query, 
					new String[]{"OUTPATIENT", "sessionDate", "isActive","idListType"}, 
					new Object[]{SchProfileType.OUTPATIENT.getID(), date.getDate(), Boolean.TRUE, listType.getId()}));
		}
		else
		{
			return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(query, 
					new String[]{"OUTPATIENT", "sessionDate", "isActive"}, 
					new Object[]{SchProfileType.OUTPATIENT.getID(), date.getDate(), Boolean.TRUE}));
		} //WDEV-20463 
		
	}

	//WDEV-20579
	private String getLocationsIdsForHospital(Integer hospitalID) //WDEV-21222
	{
		if (hospitalID == null)
			return "NULL";
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation( hospitalID,new int[]{LocationType.CLINIC.getID(),LocationType.OUTPATIENT_DEPT.getID()},Boolean.TRUE);
	}
	
	public LocMostVo getLocation(LocationRefVo voLocRef) 
	{
		DomainFactory factory = getDomainFactory();
		return LocMostVoAssembler.create((Location) factory.getDomainObject(Location.class, voLocRef.getID_Location()));
	}

	public Booking_AppointmentVo saveOPEpisode(Booking_AppointmentVo voOP) throws DomainInterfaceException, StaleObjectException 
	{
		if(voOP == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!voOP.isValidated())
			throw new DomainRuntimeException("Record not validated before save");
		
		
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, voOP);		
		factory.save(doAppt);
		
		//WDEV-9657 DNA for ICAB appts - no dna hl7 messages in uksh
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
			{
				if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_DNA), doAppt, "Appt DNA Requested from ClinicListWithIcpActions");	
			}
		}
		
		return Booking_AppointmentVoAssembler.create(doAppt);
	}

	public Booking_AppointmentVo getOpEpisode(Booking_AppointmentRefVo voBookingRef)
	{
		if (voBookingRef == null || voBookingRef.getID_Booking_Appointment() == null)
			return null;
		return Booking_AppointmentVoAssembler.create((Booking_Appointment)getDomainFactory().getDomainObject(Booking_Appointment.class, voBookingRef.getID_Booking_Appointment()));
	}

	public Boolean isNotACurrentInpatient(PatientRefVo voPatRef) 
	{
		String hql = "from InpatientEpisode ip where ip.pasEvent in (select event.id from PASEvent as event where event.patient.id = :patID)";
		DomainFactory factory= getDomainFactory();
		List l = factory.find(hql, new String[] {"patID"}, new Object[] {voPatRef.getID_Patient()});		
		if (l != null && l.size() > 0)
		{
			return false;
		}
		return true;
	}

	public CatsReferralRefVo getCatsReferralRef(Integer bookApptID) 
	{
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{bookApptID});
		
		if (cats != null && cats.size() > 0 && cats.get(0) instanceof CatsReferral)
			return new CatsReferralRefVo(((CatsReferral)cats.get(0)).getId(), ((CatsReferral)cats.get(0)).getVersion());
		
		return null;
	}

	public void saveOPEpisode(Booking_AppointmentVo voOP, CatsReferralListVo voCatsReferral, SessionSlotVo dnaSessionSlot, PatientElectiveListForDNAAppointmentsVo electiveList, Boolean isFirstAppointmentActivity, Boolean isUndoDNA, Boolean isUndoArrival) throws DomainInterfaceException, StaleObjectException
	{
		if(voOP == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!voOP.isValidated())
			throw new DomainRuntimeException("Booking Record not validated before save");
		if(voCatsReferral == null)
			throw new DomainRuntimeException("Invalid Referral to save");
		if(!voCatsReferral.isValidated())
			throw new DomainRuntimeException("Referral Record not validated before save");
		
		//WDEV-9091
		if(dnaSessionSlot != null && !dnaSessionSlot.isValidated())
			throw new CodingRuntimeException("Session Slot is not validated.");
		
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, voOP);		
		
		//WDEV-19772 
		if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue()&& doAppt.getActivity().isFirstAppointment() && voCatsReferral != null)
		{	
			if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) )			
			{
				createNewPatientEvent(doAppt, voCatsReferral, HardCodedEvents.APPOINTMENTATTENDED);	    
			}
			else if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)) && isUndoDNA )			
			{
				createNewPatientEvent(doAppt, voCatsReferral, HardCodedEvents.APPOINTMENTUNDNA);	    
			}
			else if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)) && isUndoArrival )			
			{
				createNewPatientEvent(doAppt, voCatsReferral, HardCodedEvents.APPOINTMENTUNARRIVED);	    
			}
		}
		
		factory.save(doAppt);
		
		
		//WDEV-9657 DNA for ICAB appts - no dna hl7 messages in uksh
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
			{
				if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_DNA), doAppt, "Appt DNA Requested from ClinicListWithIcpActions");	
			}
		}
		
		// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
		// When an appointment is DNA - use the Appointment Outcome Date/Time, or if not available - use the Appointment Date + Current Time
		java.util.Date eventDateTime = null;
		
		if (voOP != null && voOP.getOutcomeDateTime() != null)
		{
			eventDateTime = voOP.getOutcomeDateTime().getJavaDate();
		}
		else
		{
			eventDateTime = new DateTime(voOP.getAppointmentDate(), voOP.getApptStartTime()).getJavaDate();
		}

		//WDEV-18524 
		CatsReferral doCats = updateCatsReferral(factory, voCatsReferral, doAppt, isFirstAppointmentActivity, eventDateTime);

		try
		{
			factory.save(doCats);
		}
		catch(StaleObjectException e)// workaround to not get stale when mark an appt as dna because of WDEV-17644 
		{
			doCats = updateCatsReferral(factory, voCatsReferral, doAppt, isFirstAppointmentActivity, eventDateTime);
			factory.save(doCats);
		}
		
		////WDEV-18524
		if (doCats != null && isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()) && doCats.getJourney() != null && doCats.getJourney().getCurrentClock() != null)
		{	
			DateTime apptDateTime = null;
			Status_Reason status_Reason = null;
			if(doAppt!=null )
			{
				status_Reason =(doAppt.getApptStatus()!= null ? LookupHelper.getStatus_ReasonInstance(getLookupService(), doAppt.getApptStatus().getId()):null);
				apptDateTime = new DateTime(new Date( doAppt.getAppointmentDate()),new Time(doAppt.getArrivalTime()));
			}
			instantiatePatientEvent(doCats,apptDateTime, status_Reason);
		}
		
		if (electiveList != null)
		{
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap(); 
			TCIForPatientElectiveListAppointmentDNAVo currentTCI = electiveList.getTCIDetails();
			TCIForPatientElectiveList domTCIToSave = TCIForPatientElectiveListAppointmentDNAVoAssembler.extractTCIForPatientElectiveList(factory, currentTCI, domMap);
			electiveList.setTCIDetails(null);
			PatientElectiveList domPatientElectiveList = PatientElectiveListForDNAAppointmentsVoAssembler.extractPatientElectiveList(factory, electiveList, domMap);
			
			factory.save(domPatientElectiveList);
			factory.save(domTCIToSave);
		}
		
		
		//WDEV-9091 - starts here
		//if(dnaSessionSlot != null)
		//{			
		//	Session_Slot doSessionSlot = SessionSlotVoAssembler.extractSession_Slot(factory, dnaSessionSlot);
		//	factory.save(doSessionSlot);
		//}
		//WDEV-9091 - ends here
	}
	
	private void createNewPatientEvent(Booking_Appointment doAppt, CatsReferralListVo voCatsReferral, HardCodedEvents event) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		DateTime apptDateTime = null;
		Status_Reason status_Reason = null;
		if(doAppt!=null )
		{
			status_Reason =(doAppt.getApptStatus()!= null ? LookupHelper.getStatus_ReasonInstance(getLookupService(), doAppt.getApptStatus().getId()):null);
			apptDateTime = new DateTime(doAppt.getAppointmentDate()!= null ? new Date( doAppt.getAppointmentDate()): new Date(),
										doAppt.getArrivalTime()!= null ? new Time(doAppt.getArrivalTime()): new Time());
		}
		EventLiteVo hardCodedEvent = getHardCodedEvent(event.getID());
		PatientEventVo savedPatEv = createPatientEvent(voCatsReferral, hardCodedEvent,apptDateTime,status_Reason);
		if (doAppt != null && savedPatEv != null)
			doAppt.getPathwayEvents().add(PatientEventVoAssembler.extractPatientEvent(factory, savedPatEv));		
	}

	private PatientEventVo createPatientEvent(CatsReferralListVo voCatsReferral, EventLiteVo hardCodedEvent,DateTime apptDateTime, Status_Reason apptStatus ) throws StaleObjectException
	{
		CatsReferral catsReferral = CatsReferralListVoAssembler.extractCatsReferral(getDomainFactory(), voCatsReferral);
		PatientPathwayJourney patientJBo = catsReferral != null ? catsReferral.getJourney() : null;
				
		PatientEventVo savedPatEv = null;
		
		if (patientJBo != null && hardCodedEvent != null)
		{				
				DateTime arrivalDateTime = getArrivalDateTime(apptDateTime, apptStatus);
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(catsReferral.getPatient()));
				patEvent.setEvent(hardCodedEvent);
				patEvent.setEventDateTime(HardCodedEvents.PATHWAYUNPAUSED.equals(hardCodedEvent) && patientJBo.getCurrentClock() != null && patientJBo.getCurrentClock().getCurrentPause() != null && patientJBo.getCurrentClock().getCurrentPause().getPauseStop() != null ? new DateTime( patientJBo.getCurrentClock().getCurrentPause().getPauseStop()) : arrivalDateTime!= null? arrivalDateTime: new DateTime());
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(patientJBo));
				
				HL7PathwayIf implPath = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				try
				{
					savedPatEv = implPath.instantiatePatientEvent(patEvent);
				}
				catch (DomainInterfaceException e)
				{ throw new DomainRuntimeException("Domain Error occured in save Event " + e.getMessage(), e);}
		}
		
		return savedPatEv;
	}
	//WDEV-20603
	private DateTime getArrivalDateTime(DateTime apptDateTime, Status_Reason apptStatus) 
	{
	if(!Status_Reason.ARRIVAL.equals(apptStatus))			
			return null;
	
	return new DateTime(apptDateTime);
	}

	public EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[] {"eventID", "statusID"},new Object[] {event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID()});
		
		if (list == null || list.size() == 0)
			return null;
		
		return EventLiteVoAssembler.create((Event)list.get(0));
	}
	
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private CatsReferral updateCatsReferral(DomainFactory factory, CatsReferralListVo voCatsReferral, Booking_Appointment doAppt, Boolean isFirstAppointmentActivity, java.util.Date eventDateTime)
	{
		//WDEV-18524 
		CatsReferral doCats = (CatsReferral) factory.getDomainObject(CatsReferral.class, voCatsReferral.getID_CatsReferral());
		//CatsReferralListVoAssembler.extractCatsReferral(factory, voCatsReferral);
		
		//WDEV-17987 added the code below so the form will do the same thing on "Arrived" and "Undo Arrival" as RefMan.ClinicList
		if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)))
				{
					doCats.setLastApptArrivedDate(new Date().getDate());
				}
			}			
		}
		//WDEV-17987 when Undo Arrival, if there are no other Arrived or Seen appointments for the Referral, clear last appointment arrived date so the context menus are updated correctly
		else if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)) && canClearLastPatArrivedDate(doCats))
				{
					doCats.setLastApptArrivedDate(null);
				}
			} 
		}
		
		
		//WDEV-18325 //WDEV-18524
		PathwayRTTStatus rttSTatusDO = null;
				
		if (isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()))
		{
			PatientPathwayJourney journeyDO = doCats.getJourney();

			int dnaNatCode = PATIENT_DNA_NAT_CODE;

			rttSTatusDO = createPatientRTTStatus(dnaNatCode, eventDateTime);
			
			if  (journeyDO != null)
			{
				if (journeyDO.getCurrentClock() != null)
				{
					PathwayClock ptwClockDO = journeyDO.getCurrentClock();

					ptwClockDO.setCurrentRTTStatus(rttSTatusDO);

					List<PathwayRTTStatus> ptwClockHistory = ptwClockDO.getRTTStatusHistory();

					if (ptwClockHistory == null)
					{
						ptwClockHistory = new java.util.ArrayList();
					}
					
					ptwClockHistory.add(rttSTatusDO);	
				}
			}
			
			doCats.setCurrentRTTStatus(rttSTatusDO);
		}
		
		return doCats;
	}
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPatientRTTStatus(int nationalCode, java.util.Date eventDateTime) //WDEV-18325
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);
		
		rttSTatusDO.setRTTStatus(rttStatusPoint);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(eventDateTime);
		
		rttSTatusDO.setSetting("O");
		
		return rttSTatusDO;
	}

	private void  instantiatePatientEvent(CatsReferral doCats, DateTime apptDateTime, Status_Reason apptStatus ) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		if(doCats == null || doCats.getJourney() == null || doCats.getJourney().getCurrentClock() == null)
			return;
		
		RTTStatusEventMapVo rttEventMap = null;

		if (doCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
		{
			rttEventMap = getRTTStatusEventMap(doCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus());
		}
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;
		
		DateTime arrivalDateTime = getArrivalDateTime(apptDateTime, apptStatus);
		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCats.getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(arrivalDateTime!= null ? arrivalDateTime: null);
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(ims.pathways.domain.impl.HL7PathwayIfImpl.class);
		
		impl.instantiatePatientEvent(patEvent);
	}
		
	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18325
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();
		
		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);
						
		}
		return null;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18325 
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode and event.encounterType is null ";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}

	//WDEV-17987
	private boolean canClearLastPatArrivedDate(CatsReferral doCats)
	{
		if (doCats.getAppointments() == null)
			return true;

		Iterator<?> it1 = doCats.getAppointments().iterator();

		while (it1.hasNext())
		{
			Booking_Appointment doItem = (Booking_Appointment) it1.next();

			if (doItem.getApptStatus() != null && (doItem.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) || doItem.getApptStatus().equals(getDomLookup(Status_Reason.SEEN))))
			{
				return false;
			}
		}

		return true;
	}

	public CatsReferralListVo getCatsReferral(Booking_AppointmentRefVo voBookRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{voBookRefVo.getID_Booking_Appointment()});
		if (cats != null && cats.size() > 0)
			return CatsReferralListVoAssembler.create((CatsReferral)cats.get(0));
		return null;
	}

	public CareContextShortVo getCareContext(CareContextRefVo careContextRef)
	{
		if (careContextRef == null)
			return null;
		DomainObject domainObject = getDomainFactory().getDomainObject(CareContext.class, careContextRef.getID_CareContext());
		if (domainObject instanceof CareContext)
			return CareContextShortVoAssembler.create((CareContext) domainObject);
		return null;
	}

	public Booking_AppointmentVo getBookingAppt(Booking_AppointmentRefVo bookingApptRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		Booking_Appointment apptBo = (Booking_Appointment) factory.getDomainObject(Booking_Appointment.class, bookingApptRefVo.getID_Booking_Appointment());
		return Booking_AppointmentVoAssembler.create(apptBo);
	}

	public Boolean isInpatientCareContext(PatientRefVo patientRef, CareContextRefVo careContextRef)
	{
		if (patientRef == null || !patientRef.getID_PatientIsNotNull())
			throw new CodingRuntimeException("Logical Error - Patient expected");
		
		if (careContextRef == null || !careContextRef.getID_CareContextIsNotNull())
			throw new CodingRuntimeException("Logical Error - Care Context expected");
		
		String hql = "from InpatientEpisode as ip where (ip.pasEvent.id in (select cc.pasEvent.id from CareContext as cc where cc.id = :refID))";
		ArrayList<String> paramNames = new ArrayList<String>();
		paramNames.add("refID");
		
		ArrayList<Object> paramValues = new ArrayList<Object>();
		paramValues.add(careContextRef.getID_CareContext());
		
		InpatientEpisodeLiteVo inpatientEpisode = InpatientEpisodeLiteVoAssembler.create((InpatientEpisode) getDomainFactory().findFirst(hql, paramNames, paramValues));
		
		if (inpatientEpisode == null)
			return Boolean.FALSE;
		
		return Boolean.TRUE;
	}

	//WDEV-11665 - starts here
	public Booking_AppointmentVo saveBookingAppointment(Booking_AppointmentVo appointment) throws DomainInterfaceException,	StaleObjectException, UniqueKeyViolationException 
	{
		if(appointment == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!appointment.isValidated())
			throw new DomainRuntimeException("Record not validated before save");
		
		
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appointment);		
		factory.save(doAppt);
		
		return Booking_AppointmentVoAssembler.create(doAppt);
	}
	
	public AppointmentTrackingstatusColourConfigVo getTrackingColorConfig(LookupInstVo trackingStatus) 
	{
		if(trackingStatus == null)
			throw new CodingRuntimeException("Can not get AppointmentTrackingColorConfigVo for null LookupInstVo.");
		
		DomainFactory factory = getDomainFactory();
		
		return AppointmentTrackingstatusColourConfigVoAssembler.create((AppointmentTrackingstatusColourConfig) factory.findFirst("from AppointmentTrackingstatusColourConfig as atsc where atsc.trackingStatus.id = :statusLookup and atsc.isRIE is null", new String[] {"statusLookup"}, new Object[] {trackingStatus.getID()}));
	}
	//WDEV-11665 - ends here


	public PatientElectiveListForDNAAppointmentsVo getPatientElectiveList(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return null;
		
		String query = "SELECT electivList FROM PatientElectiveList AS electivList LEFT JOIN electivList.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID ";
		
		return PatientElectiveListForDNAAppointmentsVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}

	public Boolean hasTCI(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return Boolean.FALSE;

		String query = "SELECT COUNT (tci.id) FROM TCIForPatientElectiveList AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID and tci.isRIE is null";
		
		long count = getDomainFactory().countWithHQL(query, new String[] {"APPT_ID"}, new Object[] {appointment.getID_Booking_Appointment()});
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	//WDEV-19320
	public ServiceLiteVoCollection listServices(String strVal)
	{
		if (strVal == null || strVal.length() == 0)
			throw new CodingRuntimeException("The search string filter cannot be null or empty.");
		List<?> services = getDomainFactory().find("select srv from Service as srv where srv.isActive = 1 and srv.upperName like :servName", new String[]{"servName"}, new Object[]{strVal.toUpperCase() + "%"}); //WDEV-20219 upper(srv.serviceName)
		
		if (services == null || services.isEmpty())
			return null;
		
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services);
	}

	
	//wdev-19503
	public LocationLiteVoCollection listOutpatientlocationsByHospital(LocationRefVo hospital) //WDEV-21222
	{
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listOutpatientlocationsByHospital(hospital);
	}

	//wdev-19504
	public SessionServiceAndSlotActivityVo getServiceAndActivityByAppt(Booking_AppointmentRefVo appt, Boolean isFlexible)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt param or if for appt is null in method getServiceAndActivityByAppt");
		SessionServiceAndSlotActivityVo voServiceAndSlot = null;
		List items = null;
		
		String hql = "select activity, session.service from Booking_Appointment as appt left join appt.activity as activity left join appt.session as session where (appt.id = :idAppt)";
		items = getDomainFactory().find(hql, new String[]{"idAppt"}, new Object[]{appt.getID_Booking_Appointment()});
			
		if( items != null && items.size() > 0)
		{
			Iterator it = items.iterator();
			if(it.hasNext())
			{
				Object[] item = (Object[]) it.next();
				Activity doActivity = (Activity) item[0];
				Service doService = (Service) item[1];
				
				ActivityRefVo voActivity = new ActivityRefVo(doActivity.getId(), doActivity.getVersion());
				ServiceLiteVo voService = ServiceLiteVoAssembler.create(doService);
				
				voServiceAndSlot = new SessionServiceAndSlotActivityVo();
				voServiceAndSlot.setSessionService(voService);
				voServiceAndSlot.setSlotActivity(voActivity);
			}
		}
	
		return voServiceAndSlot;
		
	}

	

	//wdev-19504
	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		return impl.cancelAppt(appt, requestType, requestSource);
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		updateCatsReferralAdditionalInvStatus(catsReferral, null);
	}
	
	//wdev-19504
	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appt) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral, appt);
		
	}
	//wdev-19504 //WDEV-22845
	public void cancelTCIAndReferralEROD(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo apptRef, CancelAppointmentReason cancellationReason, String cancelComment, Boolean isProviderCancellation, Boolean isPatientCancellation, Boolean cancelledForNonmedicalReason) throws StaleObjectException
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method cancelReferralEROD");
		
		if(apptRef == null || apptRef.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("apptRef is null or id not provided in method getTheatreAppointment");
		
		Integer tciClock = null;

		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		
		PatientElectiveList doPatientElectiveList = null;
		Boolean saveElectiveList = false;
		
		PathwayClock currentClock = null;
		if(doCatsReferral != null && doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null)
		{
			currentClock = doCatsReferral.getJourney().getCurrentClock();
		}
		
		if(currentClock != null)
		{
			String patientElectiveListQuery = "select electiveList from PatientElectiveList as electiveList left join electiveList.referral as cats left join electiveList.pathwayClock as pc where cats.id = :CatsId and pc.id = :PathwayClock";
			List<?> electiveList = factory.find(patientElectiveListQuery, new String[] {"CatsId", "PathwayClock"}, new Object[] {catsReferral.getID_CatsReferral(), currentClock.getId()});
			
			if(electiveList != null && electiveList.size() > 0 && electiveList.get(0) instanceof PatientElectiveList)
			{
				doPatientElectiveList = (PatientElectiveList) electiveList.get(0);	
			}
		}
	
		MemberOfStaff domainMOS = null;
		Object mosUser = getMosUser();
		
		if(mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory,((MemberOfStaffShortVo) getMosUser()));
		}
		
		if (doPatientElectiveList != null)
		{
			ElectiveListStatus status = new ElectiveListStatus();
			status.setElectiveListStatus(getDomLookup(WaitingListStatus.REQUIRES_TCI));
			status.setAuthoringUser(domainMOS);
			status.setStatusDateTime(new java.util.Date());
			status.setStatusComment("Requires new TCI - Previous TCI given was cancelled.");
			
			doPatientElectiveList.setElectiveListStatus(status);
			
			if(doPatientElectiveList.getElectiveListStatusHistory() == null)
				doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());
			
			doPatientElectiveList.getElectiveListStatusHistory().add(status);
			
			TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();
			
			
			if(doTCIDetails != null)
			{
    			doPatientElectiveList.setTCIDetails(null);
    			
    			TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();
    			
    			//WDEV-18249
    			if (isPatientCancellation)
    			{
    				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_PATIENT_2));
    			}
    			else if (isProviderCancellation)
    			{	
    					
            		if(doTCIDetails.getTCIDate() != null && (new java.util.Date()).before(doTCIDetails.getTCIDate()))
            			newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_BEFORE_6));
            		else
            				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
    				
        			
        			if(doPatientElectiveList.getPathwayClock() != null)
        				tciClock = doPatientElectiveList.getPathwayClock().getId();   			
    			}
    			
    			//wdev-18419
    			if( Boolean.TRUE.equals(cancelledForNonmedicalReason))
    			{
    				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
					newOutcome.setCancelledForNonMedicalReason(true);
    				
    				ims.framework.utils.Date dtnow = new ims.framework.utils.Date();
    				dtnow.addDay(28);
    				//doPatientElectiveList.setRequiresTCIBy(dtnow.getDate());
    				doPatientElectiveList.setTCICancelledByProvider(true);
    				
    			}
    			//---------
    			newOutcome.setChangeBy(domainMOS);
    			newOutcome.setStatusDateTime(new java.util.Date());
    			newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.LINKEDTHEATREAPPTCANCELLED));
    			newOutcome.setCancellationReason(cancellationReason != null ? getDomLookup(cancellationReason) : null);
    			newOutcome.setReasonComments(cancelComment);
    			
    			doTCIDetails.setCurrentOutcome(newOutcome);
    			if(doTCIDetails.getOutcomeHistory() == null)
    				doTCIDetails.setOutcomeHistory(new ArrayList());
    			
    			doTCIDetails.getOutcomeHistory().add(newOutcome);
    			
    			if(doPatientElectiveList.getTCIHistory() == null)
    				doPatientElectiveList.setTCIHistory(new ArrayList());
    			
    			doPatientElectiveList.getTCIHistory().add(doTCIDetails);
			}
			
			saveElectiveList = true;
		}
		
		if(Boolean.TRUE.equals(isProviderCancellation))
		{
    		if(doCatsReferral.getElectiveEROD() == null)
    			return;
    		
    		ReferralEROD doErod = null;
    		ReferralEROD elEROD = null;
    		
    		for(int i=0; i<doCatsReferral.getElectiveEROD().size(); i++)
    		{
    			if(doCatsReferral.getElectiveEROD().get(i) instanceof ReferralEROD)
    			{
    				if(((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock() != null && ((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock().getId().equals(tciClock))
    				{
    					doErod = (ReferralEROD) doCatsReferral.getElectiveEROD().get(i);
    					doCatsReferral.getElectiveEROD().remove(i);
    					break;
    				}
    			}
    		}
    		    		
    		if(doErod != null)
    		{
    			doErod.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
    		
    			if(doCatsReferral.getElectiveERODHistory() == null)
    				doCatsReferral.setElectiveERODHistory(new java.util.ArrayList());
    		
    			doCatsReferral.getElectiveERODHistory().add(doErod);
    			
    			if(doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null && doCatsReferral.getJourney().getCurrentClock().getCurrentPause() != null)
    			{
    				PauseDetails currentPause = doCatsReferral.getJourney().getCurrentClock().getCurrentPause();
    				
    				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() != null)
    				{
    					for(int i=0; i<doCatsReferral.getJourney().getCurrentClock().getPauseDetails().size(); i++)
    					{
    						PauseDetails pause = (PauseDetails) doCatsReferral.getJourney().getCurrentClock().getPauseDetails().get(i);
    						if(currentPause.equals(pause) && Boolean.TRUE.equals(pause.isActive()))
    						{
    							doCatsReferral.getJourney().getCurrentClock().getPauseDetails().remove(i);
    							break;
    						}
    					}
    				}
    				
    				currentPause.setActive(false);
    				doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add(currentPause);	
    				
    				//WDEV-19772 
        			if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && doCatsReferral != null && doCatsReferral.getJourney() != null)			
        			{
    					createNewPatientEvent(null, CatsReferralListVoAssembler.create(doCatsReferral), HardCodedEvents.PATHWAYUNPAUSED);	    			
        			}
    			}
    		
    			factory.save(doCatsReferral);
    		}
    		
    		//WDEV-18455 
    		if (doPatientElectiveList != null && doPatientElectiveList.getEROD() != null && doPatientElectiveList.getEROD() instanceof ReferralEROD && doPatientElectiveList.getEROD().getPathWayClock() != null && doPatientElectiveList.getEROD().getPathWayClock().getId().equals(tciClock))
    		{
    			elEROD = (ReferralEROD) doPatientElectiveList.getEROD();
    			doPatientElectiveList.setEROD(null);
    			saveElectiveList = true;
    		}
    		
    		if (elEROD != null)
    		{
    			elEROD.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
    			doPatientElectiveList.getERODHistory().add(elEROD);
    		}
		}
		
		if(saveElectiveList)
			factory.save(doPatientElectiveList);
		
	}
	//wdev-19504
	public CatsReferralVo getCatsReferral(CatsReferralRefVo voCatsRef)
	{
		return CatsReferralVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, voCatsRef.getID_CatsReferral()));
	}
	//wdev-19504
	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException  //WDEV-19543
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralCancelStatus(catsReferral);	
	}

	//wdev-19496
	public ActivityWithImageLiteVo getActivityWithImage(ActivityRefVo activityRef)
	{
		if( activityRef == null || activityRef.getID_Activity() == null )
			throw new CodingRuntimeException("ActivityRefVo is null or id not provided in method getActivityWithImage");
		
		return ActivityWithImageLiteVoAssembler.create((Activity) getDomainFactory().getDomainObject(activityRef));
	}


	/**
	 * Function to undo an AppointmentOutcome 
	 * @throws StaleObjectException 
	 */
	public void undoAppointmentOutcome(Booking_AppointmentRefVo appointment) throws DomainInterfaceException, StaleObjectException
	{
		// Call the function to undo the AppointmentOutcome from AppointmentOutcomeDialog
		AppointmentOutcomeDialog impl = (AppointmentOutcomeDialog) getDomainImpl(AppointmentOutcomeDialogImpl.class);
		impl.undoAppointmentOutcome(appointment);
	}

	public LocationLiteVo getHospitalLiteForLocation(ILocation location) //WDEV-21222
	{
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getHospitalLiteForLocation(location);
	}

	public PDSConfigurationVo getPDSConfiguration() 
	{
		PatientSearchConfiguration impl = (PatientSearchConfiguration) getDomainImpl(PatientSearchConfigurationImpl.class);
		return impl.getPatientSearchConfig();		
	}

	public Patient getPatient(PatientShort patient) throws StaleObjectException 
	{
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.getPatient(patient);
	}

	public Patient updateLocalPatientWithPds(Patient lpiPatient,
			Patient pdsPatient, ArrayList errors, String samlXml,
			IAppRole appRole, MissingMappingVoCollection missingMappings) throws DomainInterfaceException,
			StaleObjectException, ForeignKeyViolationException 
	{
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.updateLocalPatientWithPds(lpiPatient, pdsPatient, errors, samlXml, appRole, missingMappings);
	}

}
