//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 5527.24259)
// Copyright (C) 1995-2015 IMS MAXIMS. All rights reserved.

package ims.clinical.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.PatientSearchConfiguration;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.domain.impl.PatientSearchConfigurationImpl;
import ims.admin.vo.AppointmentTrackingstatusColourConfigVo;
import ims.admin.vo.AppointmentTrackingstatusColourConfigVoCollection;
import ims.admin.vo.PDSConfigurationVo;
import ims.admin.vo.domain.AppointmentTrackingstatusColourConfigVoAssembler;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.vo.CatsReferralCurrentStatusVo;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.PatientElectiveListForDNAAppointmentsVo;
import ims.RefMan.vo.domain.CatsReferralBreachDatesVoAssembler;
import ims.RefMan.vo.domain.CatsReferralCurrentStatusVoAssembler;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForDNAAppointmentsVoAssembler;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.domain.ClinicListWithICPActions;
import ims.clinical.domain.base.impl.BaseOutpatientClinicListImpl;
import ims.clinical.helper.AppointmentForOutpatientClinicManualClass;
import ims.clinical.vo.OutpatientClinicListSearchCriteriaVo;
import ims.core.admin.domain.objects.AppointmentTrackingstatusColourConfig;
import ims.core.admin.domain.objects.CareContext;
import ims.core.clinical.domain.objects.Service;
import ims.core.domain.PDSDemographics;
import ims.core.domain.impl.PDSDemographicsImpl;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Activity;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MissingMappingVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceLiteVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.interfaces.IAppRole;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.scheduling.domain.TheatreSessionManagement;
import ims.scheduling.domain.impl.TheatreSessionManagementImpl;
import ims.scheduling.domain.objects.Appt_Tracking_Status_History;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.AppointmentForOutpatientClinicListManualCustomClassVo;
import ims.scheduling.vo.AppointmentForOutpatientClinicListManualCustomClassVoCollection;
import ims.scheduling.vo.AppointmentForOutpatientClinicListVo;
import ims.scheduling.vo.AppointmentForOutpatientClinicListVoCollection;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionServiceAndSlotActivityVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.domain.AppointmentForOutpatientClinicListVoAssembler;
import ims.scheduling.vo.domain.Appt_Tracking_Status_HistoryVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.lookups.CancelAppointmentReason;
import ims.scheduling.vo.lookups.ProfileListTypeCollection;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class OutpatientClinicListImpl extends BaseOutpatientClinicListImpl
{

	private static final long serialVersionUID = 1L;
	private static final int MAX_NUMBER_OF_RECORDS = 400;//WDEV-23833

	public LocationLiteVoCollection listOutpatientLocationsByHospital(ims.core.resource.place.vo.LocationRefVo hospital)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listOutpatientlocationsByHospital(hospital);
	}
	

	private String getLocationsIdsForHospital(LocationRefVo hospital)
	{
		if (hospital == null || hospital.getID_Location() == null)
			return "NULL";
		
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation( hospital.getID_Location(), new int[]{LocationType.CLINIC.getID(),LocationType.OUTPATIENT_DEPT.getID()}, Boolean.TRUE);
	}
	
	public LocationLiteVoCollection getActiveHospitals(MemberOfStaffRefVo mos)
	{
		if (mos == null || !mos.getID_MemberOfStaffIsNotNull())
			return null;

		StringBuilder query = new StringBuilder();
		query.append("select location from MemberOfStaff as mos left join mos.locations as hcpLocation left join hcpLocation.location as location ");
		query.append(" where location.type = :LocType and location.isActive = :isActive and location.isVirtual = :isVirtual and mos.id = :mosID");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("LocType");
		paramValues.add(getDomLookup(LocationType.HOSP));

		paramNames.add("isActive");
		paramValues.add(Boolean.TRUE);

		paramNames.add("isVirtual");
		paramValues.add(Boolean.FALSE);

		paramNames.add("mosID");
		paramValues.add(mos.getID_MemberOfStaff());

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(query.toString(), paramNames, paramValues)).sort();
	}

	public ServiceLiteVoCollection listServices(String name)
	{
		List<?> services = getDomainFactory().find("select srv from Service as srv where srv.isActive = 1 and srv.upperName like :servName", new String[]{"servName"}, new Object[]{name.toUpperCase() + "%"});
		
		if (services == null || services.isEmpty())
			return null;
		
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services).sort();
	}
	
	
	public AppointmentForOutpatientClinicListManualCustomClassVoCollection listAppointmentsManualAssemblerClass(OutpatientClinicListSearchCriteriaVo searchCriteria)
	{
		// Get Tracking status Color Configuration
		AppointmentTrackingstatusColourConfigVoCollection trackingStatusColorConfig = listTrackingStatusColorConfiguration();
		
		
		// Get Display Patient Identifier type
		String name = ims.configuration.ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue();
		ims.core.vo.lookups.PatIdType displayPatIDType = ims.core.vo.lookups.PatIdType.getNegativeInstance(name);
		
		StringBuilder querySelectPart = new StringBuilder("SELECT new ims.clinical.helper.AppointmentForOutpatientClinicManualClass(");
		querySelectPart.append("appts.id, appts.version, appts.appointmentDate, appts.apptStartTime, ");
		querySelectPart.append("apptStatus.id, apptStatus.text, ");
		querySelectPart.append("activityImage.id, activity.name, ");
		querySelectPart.append("session.name, ");
		querySelectPart.append("appts.isCABBooking, ");
		querySelectPart.append("patient.id, patient.version, ");
		querySelectPart.append("patient.name.surname, patient.name.forename, patientSex.text, patient.dob, ");
		querySelectPart.append(" (SELECT MAX(identifier.value) FROM Patient AS pat1 LEFT JOIN pat1.identifiers AS identifier WHERE pat1.id = patient.id AND identifier.type = ").append(displayPatIDType.getID()).append("), ");
		querySelectPart.append(" (SELECT COUNT(pat2.id) FROM Patient AS pat2 LEFT JOIN pat2.commChannels AS commChannel WHERE pat2.id = patient.id AND commChannel.commValue is not null), ");
		querySelectPart.append("outcome.id, outcome.text, appts.outcomeComments, appts.hasElectiveList, appts.wasPrinted, ");
		querySelectPart.append("recordingUserTitle.text, ");
		querySelectPart.append("bookingLetterRecordingUser.name.surname, bookingLetterRecordingUser.name.forename, ");
		querySelectPart.append("bookingLetter.recordingDateTime, ");
		querySelectPart.append(" (SELECT COUNT(linkedAppt.id) FROM Booking_Appointment AS appt1 LEFT JOIN appt1.linkedAppointments AS linkedAppt WHERE appt1.id = appts.id AND (linkedAppt.isRIE is null OR linkedAppt.isRIE = 0)), ");
		querySelectPart.append("appts.comments, ");
		querySelectPart.append(" (SELECT sch.bookingComments FROM Sch_Booking AS sch LEFT JOIN sch.appointments AS appo WHERE appo.id = appts.id), ");
		querySelectPart.append("referral.id, referral.version, ");
		querySelectPart.append("rttStatus.description, referralDetails.end18WW, ");
		querySelectPart.append("interpreterRequired.id, language.id, language.text, referralDetails.otherLanguage, ");
		querySelectPart.append("referral.isCAB, icabReferral.uBRN, ");
		querySelectPart.append("electiveList.id, electiveList.version, ");
		querySelectPart.append("apptTrackingStatus.statusChangeDateTime, trackingStatus.id, trackingStatus.text, ");
		querySelectPart.append("serviceFunction.text ");
		querySelectPart.append(")");
		
		
		StringBuilder queryFromPart = new StringBuilder(" FROM CatsReferral AS referral ");
		queryFromPart.append(" LEFT JOIN referral.currentRTTStatus AS currentRTTStatus LEFT JOIN currentRTTStatus.rTTStatus AS rttStatus ");
		queryFromPart.append(" LEFT JOIN referral.referralDetails AS referralDetails LEFT JOIN referralDetails.interpreterRequired AS interpreterRequired ");
		queryFromPart.append(" LEFT JOIN referralDetails.language AS language ");
		queryFromPart.append(" LEFT JOIN referral.iCABReferral AS icabReferral ");
		queryFromPart.append(" RIGHT JOIN referral.appointments AS appts ");
		queryFromPart.append(" LEFT JOIN appts.apptStatus AS apptStatus ");
		queryFromPart.append(" LEFT JOIN appts.activity AS activity LEFT JOIN activity.activityImage AS activityImage ");
		queryFromPart.append(" LEFT JOIN appts.session AS session ");
		queryFromPart.append(" LEFT JOIN appts.patient AS patient LEFT JOIN patient.sex AS patientSex ");
		queryFromPart.append(" LEFT JOIN appts.outcome AS outcome ");
		queryFromPart.append(" LEFT JOIN appts.bookingLetter AS bookingLetter LEFT JOIN bookingLetter.recordingUser AS bookingLetterRecordingUser ");
		queryFromPart.append(" LEFT JOIN bookingLetterRecordingUser.name.title AS recordingUserTitle ");
		queryFromPart.append(" LEFT JOIN appts.electiveList AS electiveList ");
		queryFromPart.append(" LEFT JOIN appts.apptTrackingStatusHistory AS apptTrackingStatus ");
		queryFromPart.append(" LEFT JOIN apptTrackingStatus.trackingStatus AS trackingStatus ");
		queryFromPart.append(" LEFT JOIN appts.serviceFunction AS srvFunction LEFT JOIN srvFunction.function AS serviceFunction ");
			
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		
		StringBuilder queryConditionPart = new StringBuilder(" WHERE ");
		queryConditionPart.append(" (apptTrackingStatus.id is null OR apptTrackingStatus.id = (select max(th.id) from Booking_Appointment as ba join ba.apptTrackingStatusHistory as th where ba.id = appts.id)) ");
		
		if (searchCriteria.getClinicIsNotNull())
		{
			queryConditionPart.append(" and session.id = :clinic");
			paramNames.add("clinic");
			paramValues.add(searchCriteria.getClinic().getID_Sch_Session());
		}
		else
		{
			if (searchCriteria.getHospital() != null)
			{
				String ids = getLocationsIdsForHospital(searchCriteria.getHospital().getID_Location());
				queryConditionPart.append(" and session.schLocation.id in ( " + ids + " )");
			}

			if (searchCriteria.getDate() != null)
			{
				queryConditionPart.append(" and session.sessionDate = :sessionDate");
				paramNames.add("sessionDate");
				paramValues.add(searchCriteria.getDate().getDate());
			}

			queryConditionPart.append(" and session.isActive = :isActive");
			paramNames.add("isActive");
			paramValues.add(Boolean.TRUE);

			queryConditionPart.append(" and session.sessionProfileType.id = :OUTPATIENT_SESSION");
			paramNames.add("OUTPATIENT_SESSION");
			paramValues.add(SchProfileType.OUTPATIENT.getID());
		}
		
		if (searchCriteria.getTimeFrom() != null)
		{
			queryConditionPart.append(" and appts.apptStartTime >= :START_TIME");
			paramNames.add("START_TIME");
			paramValues.add(searchCriteria.getTimeFrom().toString());
		}
		
		if (searchCriteria.getTimeTo() != null)
		{
			queryConditionPart.append(" and appts.apptStartTime <= :END_TIME");
			paramNames.add("END_TIME");
			paramValues.add(searchCriteria.getTimeTo().toString());
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			queryConditionPart.append(" and session.service.id = :idService");
			paramNames.add("idService");
			paramValues.add(searchCriteria.getService().getID_Service());
		}
		
		if( searchCriteria.getOutPatientLocationIsNotNull())
		{
			queryConditionPart.append(" and session.schLocation.id = :idLocationO");
			paramNames.add("idLocationO");
			paramValues.add(searchCriteria.getOutPatientLocation().getID_Location());
		}
		
		if (searchCriteria.getListOwnersIsNotNull() && searchCriteria.getListOwners().size() > 0)
		{
			queryFromPart.append(" LEFT JOIN session.listOwners as owners") ;
			queryConditionPart.append(" and owners.hcp.id in (" + getListOwnersIds(searchCriteria.getListOwners()) + ")");			
		}

		if (searchCriteria.getListType() != null && searchCriteria.getListType().size() > 0)
		{
			queryFromPart.append(" LEFT JOIN session.listType as listType") ;
			queryConditionPart.append (" and listType.id IN " + getListTypeIDs(searchCriteria.getListType()));
		}
		
		queryConditionPart.append(" and appts.apptStatus.id != :CAN_ID ");
		
		paramNames.add("CAN_ID");
		paramValues.add(Status_Reason.CANCELLED.getID());

		
		StringBuilder query = new StringBuilder();
		query.append(querySelectPart.toString());
		query.append(queryFromPart.toString());
		query.append(queryConditionPart.toString());
		
		query.append(" ORDER BY appts.apptStartTime");
		
		
		long startOfQuery = System.currentTimeMillis();
		
		List<?> queryResults = getDomainFactory().find(query.toString(), paramNames, paramValues, MAX_NUMBER_OF_RECORDS);//WDEV-23833//WDEV-23823 
		
		long endOfQuery = System.currentTimeMillis();
		
		long queryExecutionTime = (endOfQuery - startOfQuery);
		
		System.out.println("Query execution time: " + queryExecutionTime);
		
		if (queryResults == null || queryResults.size() == 0)
			return null;
		
		
		AppointmentForOutpatientClinicListManualCustomClassVoCollection results = new AppointmentForOutpatientClinicListManualCustomClassVoCollection();
		
		for (int i = 0; i < queryResults.size(); i++)
		{
			AppointmentForOutpatientClinicManualClass queryResult = (AppointmentForOutpatientClinicManualClass) queryResults.get(i);

			AppointmentForOutpatientClinicListManualCustomClassVo appointment = queryResult.toAppointmentForOutpatientClinicListManualCustomClassVo();
			appointment.setTrackingStatusColorConfig(getTrackingStatusColorConfigForAppointment(trackingStatusColorConfig, appointment));
			
			results.add(appointment);
		}
		
		return results;
	}


	private String getListTypeIDs(ProfileListTypeCollection listType)
	{
		StringBuilder ret = new StringBuilder();
		if (listType.size() == 0)
			return null;
		ret.append("(");
		String commaStr = "";
		for (int i =0;i<listType.size();i++)
		{
			ret.append(commaStr).append(listType.get(i).getID());
			commaStr = ", ";
		}
		ret.append(")");
		return ret.toString();
	}

	private AppointmentTrackingstatusColourConfigVoCollection listTrackingStatusColorConfiguration()
	{
		return AppointmentTrackingstatusColourConfigVoAssembler.createAppointmentTrackingstatusColourConfigVoCollectionFromAppointmentTrackingstatusColourConfig(getDomainFactory().find(" from AppointmentTrackingstatusColourConfig"));
	}


	private AppointmentTrackingstatusColourConfigVo getTrackingStatusColorConfigForAppointment(AppointmentTrackingstatusColourConfigVoCollection trackingStatusColorConfig, AppointmentForOutpatientClinicListManualCustomClassVo appointment)
	{
		if (appointment == null || appointment.getTrackingStatusID() == null)
			return null;
		
		if (trackingStatusColorConfig == null)
			return null;
		
		for (AppointmentTrackingstatusColourConfigVo configuration : trackingStatusColorConfig)
		{
			if (appointment.getTrackingStatusID().equals(configuration.getTrackingStatus().getId()))
				return configuration;
		}

		return null;
	}

	
	
	
	public AppointmentForOutpatientClinicListVoCollection listAppointments(OutpatientClinicListSearchCriteriaVo searchCriteria)
	{
		listAppointmentsManualAssemblerClass(searchCriteria);
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		StringBuffer condStr = new StringBuffer();

		// Get the AppointmentTrackingStatusConfig records from data base (the actual number should be less than 10, about 6)
		List appointmentTrackingStatusConfig = getDomainFactory().find(" from AppointmentTrackingstatusColourConfig");

		StringBuffer query = new StringBuffer();

		query.append(" SELECT appts, apptTrackStatus, referral, (select sch.bookingComments from Sch_Booking as sch left join sch.appointments as appo where appo.id = appts.id)");
		query.append(" FROM Booking_Appointment AS appts LEFT JOIN appts.apptTrackingStatusHistory AS apptTrackStatus LEFT JOIN appts.session as sess");
		query.append(", CatsReferral AS referral LEFT JOIN referral.appointments AS refAppt");
		
		condStr.append(" refAppt.id = appts.id AND ");
		condStr.append(" (apptTrackStatus.id is null or ");
		condStr.append(" apptTrackStatus.id = (select max(th.id) from Booking_Appointment as ba join ba.apptTrackingStatusHistory as th where ba.id = appts.id))");

		if (searchCriteria.getClinicIsNotNull())
		{
			condStr.append(" and sess.id = :clinic");
			markers.add("clinic");
			values.add(searchCriteria.getClinic().getID_Sch_Session());
		}
		else
		{
			if (searchCriteria.getHospital() != null)
			{
				String ids = getLocationsIdsForHospital(searchCriteria.getHospital().getID_Location());
				condStr.append(" and sess.schLocation.id in ( " + ids + " )");
			}

			if (searchCriteria.getDate() != null)
			{
				condStr.append(" and sess.sessionDate = :sessionDate");
				markers.add("sessionDate");
				values.add(searchCriteria.getDate().getDate());
			}

			condStr.append(" and sess.isActive = :isActive");
			markers.add("isActive");
			values.add(Boolean.TRUE);

			condStr.append(" and sess.sessionProfileType.id = :OUTPATIENT_SESSION");
			markers.add("OUTPATIENT_SESSION");
			values.add(SchProfileType.OUTPATIENT.getID());
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			condStr.append(" and sess.service.id = :idService");
			markers.add("idService");
			values.add(searchCriteria.getService().getID_Service());
		}
		
		if( searchCriteria.getOutPatientLocationIsNotNull())
		{
			condStr.append(" and sess.schLocation.id = :idLocationO");
			markers.add("idLocationO");
			values.add(searchCriteria.getOutPatientLocation().getID_Location());
		}
		
		if (searchCriteria.getListOwnersIsNotNull() && searchCriteria.getListOwners().size() > 0)
		{
			query.append(" LEFT JOIN sess.listOwners as owners") ;
			condStr.append(" and owners.hcp.id in (" + getListOwnersIds(searchCriteria.getListOwners()) + ")");			
		}

		if (searchCriteria.getListType() != null  && searchCriteria.getListType().size() > 0)
		{
			query.append(" LEFT JOIN sess.listType as listType") ;
			condStr.append (" and listType.id IN " + getListTypeIDs(searchCriteria.getListType()));
		}
		
		condStr.append(" and appts.apptStatus.id != :CAN_ID ");
		
		markers.add("CAN_ID");
		values.add(Status_Reason.CANCELLED.getID());
		
		query.append(" WHERE ");
		query.append(condStr.toString());
		
		List list = getDomainFactory().find(query.toString(), markers, values, 500);
		Iterator it = list.iterator();
		
		AppointmentForOutpatientClinicListVoCollection voColl = new AppointmentForOutpatientClinicListVoCollection();

		while (it.hasNext())
		{
			Object[] lstItem = (Object[]) it.next();
			
			Booking_Appointment appt = (Booking_Appointment) lstItem[0];
			
			// Populate database mapped fields
			AppointmentForOutpatientClinicListVo result = AppointmentForOutpatientClinicListVoAssembler.create(appt);
			
			// Set Appointment Tracking Status field from appointment
			if (lstItem[1] instanceof Appt_Tracking_Status_History)
			{
				Appt_Tracking_Status_History domApptTrackingHistory = (Appt_Tracking_Status_History) lstItem[1];
				
				result.setCurrentApptTrakingStatus(Appt_Tracking_Status_HistoryVoAssembler.create(domApptTrackingHistory));
				
				// Set Appointment Tracking Status Colour Configuration record
				if (appointmentTrackingStatusConfig != null)
				{
					for (int i = 0; i < appointmentTrackingStatusConfig.size(); i++)
					{
						if (appointmentTrackingStatusConfig.get(i) instanceof AppointmentTrackingstatusColourConfig)
						{
							AppointmentTrackingstatusColourConfig domColourConfig = (AppointmentTrackingstatusColourConfig) appointmentTrackingStatusConfig.get(i);
							
							if (domColourConfig.getTrackingStatus().getId() == domApptTrackingHistory.getTrackingStatus().getId())
							{
								result.setTrackingStatusColour(AppointmentTrackingstatusColourConfigVoAssembler.create(domColourConfig));
							}
						}
					}
				}
			}
			
			// CatsReferral for appointment
			if (lstItem[2] instanceof CatsReferral)
			{
				result.setReferral(CatsReferralBreachDatesVoAssembler.create((CatsReferral) lstItem[2]));
			}
			
			//Appointment Comment
			if (lstItem[3] instanceof String)
			{
				result.setBookingComments((String) lstItem[3]);
			}
			
			voColl.add(result);
		}
		
		return voColl;
	}
	
	private String getLocationsIdsForHospital(Integer hospitalID)
	{
		if (hospitalID == null)
			return "NULL";
		
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation( hospitalID,new int[]{LocationType.CLINIC.getID(),LocationType.OUTPATIENT_DEPT.getID()},Boolean.TRUE);
	}
	
	private String getListOwnersIds(HcpLiteVoCollection listOwners)
	{
		if (listOwners == null || listOwners.size() ==0)
			return null;
		
		StringBuilder ids = new StringBuilder();
		String comma ="";
		
		for (HcpLiteVo listOwner :listOwners)
		{
			if (listOwner == null || listOwner.getID_Hcp() == null)
				continue;
			
			ids.append(comma + String.valueOf(listOwner.getID_Hcp().intValue()));
			comma = ", ";			
		}

		return ids.toString();
	}

	public CareContextShortVo getCareContext(CatsReferralRefVo referral)
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select CC from CatsReferral as catsRef left join catsRef.careContext as CC where catsRef.id = :referralID",	new String[]{"referralID"},	new Object[]{referral.getID_CatsReferral()});
		
		if (cats != null && cats.size() > 0)
			return CareContextShortVoAssembler.create((CareContext)cats.get(0));
		
		return null;
	}

	public PatientShort getPatientShort(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		return PatientShortAssembler.create((Patient) getDomainFactory().getDomainObject(Patient.class, patient.getID_Patient()));
	}

	public Booking_AppointmentVo getBookingAppt(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		return Booking_AppointmentVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(Booking_Appointment.class, appointment.getID_Booking_Appointment()));
	}

	public CatsReferralListVo getCatsReferral(Booking_AppointmentRefVo appointment)
	{
		
		List cats = getDomainFactory().find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{appointment.getID_Booking_Appointment()});
		
		if (cats != null && cats.size() > 0)
			return CatsReferralListVoAssembler.create((CatsReferral)cats.get(0));
		
		return null;
	}

	public PatientElectiveListForDNAAppointmentsVo getPatientElectiveList(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		String query = "SELECT electivList FROM PatientElectiveList AS electivList LEFT JOIN electivList.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID ";
		
		return PatientElectiveListForDNAAppointmentsVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}

	public void saveOPEpisode(Booking_AppointmentVo appointment, CatsReferralListVo catsReferral, SessionSlotVo sessionSlot, PatientElectiveListForDNAAppointmentsVo electiveList, Boolean isFirstAppointmentActivity, Boolean isUndoDNA, Boolean isUndoArrival) throws DomainInterfaceException, StaleObjectException
	{
		ClinicListWithICPActions impl = (ClinicListWithICPActions)getDomainImpl(ClinicListwithICPActionsImpl.class);
		impl.saveOPEpisode(appointment, catsReferral, sessionSlot, electiveList, isFirstAppointmentActivity, isUndoDNA, isUndoArrival);
		
	}

	public SessionServiceAndSlotActivityVo getServiceAndActivityByAppt(Booking_AppointmentRefVo appointment)
	{
		if(appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		SessionServiceAndSlotActivityVo voServiceAndSlot = null;
		List items = null;
		
		String hql = "select activity, session.service from Booking_Appointment as appt left join appt.activity as activity left join appt.session as session where (appt.id = :idAppt)";
		items = getDomainFactory().find(hql, new String[]{"idAppt"}, new Object[]{appointment.getID_Booking_Appointment()});
			
		if( items != null && items.size() > 0)
		{
			Iterator it = items.iterator();
			if(it.hasNext())
			{
				Object[] item = (Object[]) it.next();
				Activity doActivity = (Activity) item[0];
				Service doService = (Service) item[1];
				
				ActivityRefVo voActivity = new ActivityRefVo(doActivity.getId(), doActivity.getVersion());
				ServiceLiteVo voService = ServiceLiteVoAssembler.create(doService);
				
				voServiceAndSlot = new SessionServiceAndSlotActivityVo();
				voServiceAndSlot.setSessionService(voService);
				voServiceAndSlot.setSlotActivity(voActivity);
			}
		}
	
		return voServiceAndSlot;
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appointment, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		ClinicListWithICPActions impl = (ClinicListWithICPActions)getDomainImpl(ClinicListwithICPActionsImpl.class);
		return impl.cancelAppt(appointment, requestType, requestSource);
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appointment) throws StaleObjectException
	{
		ClinicListWithICPActions impl = (ClinicListWithICPActions)getDomainImpl(ClinicListwithICPActionsImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral, appointment);
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		ClinicListWithICPActions impl = (ClinicListWithICPActions)getDomainImpl(ClinicListwithICPActionsImpl.class);
		impl.updateCatsReferralCancelStatus(catsReferral);
	}
	
	//WDEV-22845
	public void cancelTCIAndReferralEROD(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appointment, CancelAppointmentReason cancellationReason, String cancelComment, Boolean isProviderCancellation, Boolean isPatientCancellation, Boolean cancelledForNonMedicalReason) throws StaleObjectException
	{
		TheatreSessionManagement theatreImpl = (TheatreSessionManagement) getDomainImpl(TheatreSessionManagementImpl.class);
		theatreImpl.cancelTCIAndReferralEROD(catsReferral, appointment, cancellationReason, cancelComment, isProviderCancellation, isPatientCancellation, cancelledForNonMedicalReason);
	}

	public CatsReferralCurrentStatusVo getCatsReferral(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return null;
		
		return CatsReferralCurrentStatusVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, catsReferral.getID_CatsReferral()));
	}

	public PDSConfigurationVo getPDSConfiguration() 
	{
		PatientSearchConfiguration impl = (PatientSearchConfiguration) getDomainImpl(PatientSearchConfigurationImpl.class);
		return impl.getPatientSearchConfig();		
	}

	public ims.core.vo.Patient getPatient(PatientShort patient) throws StaleObjectException 
	{
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.getPatient(patient);
	}

	public ims.core.vo.Patient updateLocalPatientWithPds(ims.core.vo.Patient lpiPatient,
			ims.core.vo.Patient pdsPatient, ArrayList errors, String samlXml,
			IAppRole appRole, MissingMappingVoCollection missingMappings) throws DomainInterfaceException,
			StaleObjectException, ForeignKeyViolationException 
	{
		PDSDemographics impl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return impl.updateLocalPatientWithPds(lpiPatient, pdsPatient, errors, samlXml, appRole, missingMappings);
	}
	
	//WDEV-23022
	public LocationLiteVo getParentHospital(ILocation iLoc)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getHospitalLiteForLocation(iLoc);
	}

	@Override
	//WDEV-22848 //WDEV-23273- Clinic field should be changed in a querycombo so I added a new parameter called stringName
	public SessionShortVoCollection listClinics(LocationRefVo hospital, Date date, ProfileListTypeCollection listTypes, String stringName)
	{
		if(stringName == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		String ids = getLocationsIdsForHospital(hospital);
		
		String query = " from Sch_Session session where upper(session.name) like :SessionName and session.schLocation.id in ( " + ids + " ) and session.sessionProfileType.id = :OUTPATIENT and session.sessionDate = :sessionDate and session.isActive = :isActive ";
		
		if( listTypes != null && listTypes.size() > 0)	
		{
			query += " and session.listType.id IN " + getListTypeIDs(listTypes) ;
		}
		
		query += " ORDER BY session.name ASC ";		
	
		return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(query, new String[]{"SessionName","OUTPATIENT", "sessionDate", "isActive"}, new Object[]{stringName.toUpperCase()+"%",SchProfileType.OUTPATIENT.getID(), date.getDate(), Boolean.TRUE}));		 

	}
}
