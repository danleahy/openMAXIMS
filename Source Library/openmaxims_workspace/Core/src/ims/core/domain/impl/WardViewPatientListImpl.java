//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.80 build 5360.17707)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.core.domain.impl;

import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedInfoVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedInfoVoAssembler;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.BedSpaceStateStatus;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.PendingTransfers;
import ims.core.admin.pas.vo.BedSpaceStateRefVo;
import ims.core.admin.pas.vo.InpatientEpisodeRefVo;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.pas.vo.PendingEmergencyAdmissionRefVo;
import ims.core.admin.pas.vo.PendingTransfersRefVo;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.BedInfoDialog;
import ims.core.domain.WardView;
import ims.core.domain.base.impl.BaseWardViewPatientListImpl;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.AdmissionDetailVo;
import ims.core.vo.BedSpaceStateLiteVo;
import ims.core.vo.BedSpaceStateStatusLiteVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.CatsReferralPendingEmergencyNonEDAdmissionListVoCollection;
import ims.core.vo.HomeLeaveVo;
import ims.core.vo.InPatientEpisodeADTVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.PatientLite_IdentifiersVo;
import ims.core.vo.PatientLite_IdentifiersVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.PendingTransfersLiteVo;
import ims.core.vo.TrackingForPendingEmergencyAdmitVo;
import ims.core.vo.TrackingForPendingEmergencyAdmitVoCollection;
import ims.core.vo.WardConfigLiteVo;
import ims.core.vo.WardViewPatientListVo;
import ims.core.vo.WardViewPatientListVoCollection;
import ims.core.vo.domain.BedSpaceStateLiteVoAssembler;
import ims.core.vo.domain.BedSpaceStateStatusLiteVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.CatsReferralPendingEmergencyNonEDAdmissionListVoAssembler;
import ims.core.vo.domain.InPatientEpisodeADTVoAssembler;
import ims.core.vo.domain.InpatientEpisodeForWardPatientListVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.PatientLite_IdentifiersVoAssembler;
import ims.core.vo.domain.PendingTransferForBedReadyDetailsVoAssembler;
import ims.core.vo.domain.PendingTransfersLiteVoAssembler;
import ims.core.vo.domain.TrackingForPendingEmergencyAdmitVoAssembler;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.EmergencyAdmissionStatus;
import ims.core.vo.lookups.PendingAdmissionStatus;
import ims.core.vo.lookups.TransferStatus;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.emergency.domain.objects.Tracking;
import ims.emergency.vo.EmergencyAttendanceLiteVo;
import ims.emergency.vo.TrackingRefVo;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class WardViewPatientListImpl extends BaseWardViewPatientListImpl
{
	private static final long serialVersionUID = 1L;

	
	public PatientLite_IdentifiersVoCollection listPatients(LocationRefVo ward, LocationRefVo bay, Object searchType)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		if (searchType == null)
			return null;
		
		// Return null
		return null;
	}


	public WardViewPatientListVoCollection listForPatientsOnTheWard(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState LEFT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		
		query.append(" WHERE pas.location.id = :WARD_ID ");
		query.append(" AND inpatEp.bed is not null AND (inpatEp.isOnHomeLeave is null OR inpatEp.isOnHomeLeave = 0)");
		
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		
		List<?> results = getDomainFactory().find(query.toString(), new String[]{"PENDING_TRANSF",  "WARD_ID"}, new Object[] {TransferStatus.PENDING.getID(), ward.getID_Location()});
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
				wardViewPatient.setCanReopenHomeLeave(canReopenHomeLeave(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	private boolean canReopenHomeLeave(InpatientEpisode doInpat)
	{
		if (Boolean.TRUE.equals(doInpat.isIsOnHomeLeave()) || doInpat.getHomeLeaves() == null || doInpat.getHomeLeaves().size() == 0)
			return false;
		HomeLeaveVo latestHomeLeave = getLatestClosedHomeLeaveForEpisode(doInpat);
		
		return latestHomeLeave != null;
	}

	private HomeLeaveVo getLatestClosedHomeLeaveForEpisode(InpatientEpisode doInpat)
	{
		if (doInpat.getHomeLeaves() == null || doInpat.getHomeLeaves().size() == 0)
			return null;
		
		InPatientEpisodeADTVo voEpisode = InPatientEpisodeADTVoAssembler.create(doInpat);
		if (voEpisode != null)
		{	
		for (int i=voEpisode.getHomeLeaves().size()-1;i>=0;i--)
		{
			if (voEpisode.getHomeLeaves().get(i).getDateReturnedFromHomeLeave() == null)
				voEpisode.getHomeLeaves().remove(i);
		}
		voEpisode.getHomeLeaves().sort(HomeLeaveVo.getDateOnHomeLeaveComparator(SortOrder.DESCENDING));
		if (voEpisode.getHomeLeaves().size() > 0 && voEpisode.getHomeLeaves().get(0) != null)
				return voEpisode.getHomeLeaves().get(0);
		}
		return null;
	}
	public WardViewPatientListVoCollection listForPatientsAwaitingBed(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpatEp.bed AS bed ");
		
		query.append(" WHERE pas.location.id = :WARD_ID AND bed is null AND (inpatEp.isOnHomeLeave is null OR inpatEp.isOnHomeLeave = 0) AND (inpatEp.isReadyToLeave is null OR inpatEp.isReadyToLeave = 0)");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		List<?> results = getDomainFactory().find(query.toString(),  new String[] {"PENDING_TRANSF","WARD_ID"}, new Object[] {TransferStatus.PENDING.getID(), ward.getID_Location()});
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];			
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
				wardViewPatient.setCanReopenHomeLeave(canReopenHomeLeave(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	public WardViewPatientListVoCollection listForPatientsOnHomeLeave(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpatEp.homeLeaves AS hl ");
		query.append(" LEFT JOIN inpatEp.bed AS bed ");

		query.append(" WHERE pas.location.id = :WARD_ID AND inpatEp.isOnHomeLeave = 1 AND (hl.isRIE is null OR hl.isRIE = 0) AND (hl.bedRetained is null OR  hl.bedRetained = 0) AND hl.dateReturnedFromHomeLeave is null AND bed is null");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		List<?> results = getDomainFactory().find(query.toString(),new String[]{"PENDING_TRANSF","WARD_ID"}, new Object[] {TransferStatus.PENDING.getID(),ward.getID_Location()});
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}			
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}
	public WardViewPatientListVoCollection listForPatientsOnHomeLeaveWithBedsRetained(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState LEFT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		
		query.append(" WHERE pas.location.id = :WARD_ID AND inpatEp.isOnHomeLeave = 1 ");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		List<?> results = getDomainFactory().find(query.toString(), new String[] {"PENDING_TRANSF","WARD_ID"},new Object[] {TransferStatus.PENDING.getID(), ward.getID_Location()});
				
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}
	public BedSpaceStateLiteVo getSelectedBedSpaceState(BedSpaceStateRefVo bedSpaceRef)
	{
		DomainFactory factory = getDomainFactory();
		 BedSpaceState doBedSpaceState = (BedSpaceState) factory.getDomainObject(BedSpaceState.class, bedSpaceRef.getID_BedSpaceState());
		 
		return doBedSpaceState != null ? BedSpaceStateLiteVoAssembler.create(doBedSpaceState) : null;
	}	
	public WardViewPatientListVoCollection listForPatientsToBeDischargedWithin24Hours(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpatEp.bed AS bed ");
		//			WDEV-21316
		query.append(" WHERE pas.location.id = :WARD_ID AND inpatEp.estDischargeDate <= :DATE_24H AND ((inpatEp.isConfirmedDischarge = 0 OR inpatEp.isConfirmedDischarge is null) and inpatEp.confirmedDischargeDateTime is null) AND ((inpatEp.isReadyToLeave is null OR inpatEp.isReadyToLeave = 0) and inpatEp.readyToLeaveDecisionDateTime is null)");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");			paramValues.add(ward.getID_Location());
		paramNames.add("DATE_24H");			paramValues.add(new ims.framework.utils.DateTime().addHours(24).getJavaDate());
		paramNames.add("PENDING_TRANSF");   paramValues.add(TransferStatus.PENDING.getID());
		
		List<?> results = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
				wardViewPatient.setCanReopenHomeLeave(canReopenHomeLeave(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	public WardViewPatientListVoCollection listForPatientsWithDischargedConfirmedWithin24Hours(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState, ");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpatEp.bed AS bed ");
		
		query.append(" WHERE pas.location.id = :WARD_ID AND inpatEp.confirmedDischargeDateTime <= :DATE_24H AND inpatEp.isConfirmedDischarge = 1 AND ((inpatEp.isReadyToLeave is null OR inpatEp.isReadyToLeave = 0) AND inpatEp.readyToLeaveDecisionDateTime IS NULL)");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");			paramValues.add(ward.getID_Location());
		paramNames.add("DATE_24H");			paramValues.add(new ims.framework.utils.DateTime().addHours(24).getJavaDate());
		paramNames.add("PENDING_TRANSF");   paramValues.add(TransferStatus.PENDING.getID());
		
		List<?> results = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];			
			Long transferCount = (Long) item[3];
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
				wardViewPatient.setCanReopenHomeLeave(canReopenHomeLeave(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}			
			
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	public WardViewPatientListVoCollection listForPatientsReadyToLeave(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpatEp, patient, bedSpaceState,");
		query.append(" (select count(pt.id) from PendingTransfers as pt left join pt.inpatientEpisode as inp where inp.id = inpatEp.id and pt.currentStatus.id = :PENDING_TRANSF) ");
		query.append(" FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.inpatientEpisode AS inpatEp ");
		query.append(" LEFT JOIN inpatEp.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" WHERE pas.location.id = :WARD_ID");
		query.append(" AND inpatEp.readyToLeaveDecisionDateTime <= :TODAY_HIGH AND inpatEp.isReadyToLeave = 1");
		query.append(" ORDER BY patient.name.upperSurname ");
		
		List<?> results = getDomainFactory().find(query.toString(), new String[]{"PENDING_TRANSF","WARD_ID","TODAY_HIGH"}, new Object[] {TransferStatus.PENDING.getID(),ward.getID_Location(), new DateTime().addHours(24).getJavaDate()});
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			Long transferCount = (Long) item[3];
						
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
				wardViewPatient.setCanReopenHomeLeave(canReopenHomeLeave(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			if (transferCount != null)
			{
				wardViewPatient.setHasPendingTransfer(transferCount.intValue() > 0);
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
		
	}


	public WardViewPatientListVoCollection listForTransferOutPatients(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
	
		StringBuilder query = new StringBuilder("SELECT inpat, patient, bedSpaceState, pendTrans ");
		query.append(" FROM PendingTransfers AS pendTrans ");
		query.append(" LEFT JOIN pendTrans.inpatientEpisode AS inpat LEFT JOIN inpat.pasEvent AS pas ");
		query.append(" LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpat.bed AS bedSpaceState ");
		
		query.append(" WHERE pas.location.id = :WARD_ID AND pendTrans.currentStatus.id = :STATUS ");
		query.append(" ORDER BY patient.name.upperSurname ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");		paramValues.add(ward.getID_Location());
		paramNames.add("STATUS");		paramValues.add(TransferStatus.PENDING.getID());
		
		List<?> results = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			PendingTransfers doTransfer = (PendingTransfers) item[3];
						
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			
			if (doTransfer != null) //WDEV-21083
			{
				wardViewPatient.setPendingTransfer(PendingTransferForBedReadyDetailsVoAssembler.create(doTransfer));
			}			
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	public WardViewPatientListVoCollection listForTransferInPatients(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT inpat, patient, bedSpaceState, pendTrans ");
		
		query.append(" FROM PendingTransfers AS pendTrans ");
		query.append(" LEFT JOIN pendTrans.inpatientEpisode AS inpat LEFT JOIN inpat.pasEvent AS pas ");
		query.append(" LEFT JOIN pas.patient AS patient ");
		query.append(" LEFT JOIN inpat.bed AS bedSpaceState ");
		query.append(" WHERE pendTrans.destinationWard.id = :WARD_ID AND pendTrans.currentStatus.id = :STATUS ");
		query.append(" ORDER BY patient.name.upperSurname ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");		paramValues.add(ward.getID_Location());
		paramNames.add("STATUS");		paramValues.add(TransferStatus.PENDING.getID());
		

		List<?> results = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		if (results == null || results.size() == 0)
			return null;
		
		WardViewPatientListVoCollection wardViewPatientsCollection = new WardViewPatientListVoCollection();
		
		Iterator<?> iterator = results.iterator();
		
		while (iterator.hasNext())
		{
			Object[] item = (Object[]) iterator.next();
			
			InpatientEpisode doInpat = (InpatientEpisode) item[0];
			Patient doPatient = (Patient) item[1];
			BedSpaceState doBedSpace = (BedSpaceState) item[2];
			PendingTransfers doTransfer = (PendingTransfers) item[3];			
			
			WardViewPatientListVo wardViewPatient = new WardViewPatientListVo();
			
			if (doPatient != null && doPatient.getAssociatedPatient() != null)
			{	
				doPatient = doPatient.getAssociatedPatient();
			}	
			PatientLite_IdentifiersVo patient = PatientLite_IdentifiersVoAssembler.create(doPatient);
			wardViewPatient.setPatient(patient);
			
			if (doInpat != null)
			{
				wardViewPatient.setInpatientEpisode(InpatientEpisodeForWardPatientListVoAssembler.create(doInpat));
			}
			
			if (doBedSpace != null)
			{
				wardViewPatient.setBedSpaceState(new BedSpaceStateRefVo(doBedSpace.getId(), doBedSpace.getVersion()));
			}
			
			if (doTransfer != null) //WDEV-21083 
			{
				wardViewPatient.setPendingTransfer(PendingTransferForBedReadyDetailsVoAssembler.create(doTransfer));
			}
			
			wardViewPatientsCollection.add(wardViewPatient);
		}
		
		return wardViewPatientsCollection;
	}


	public TrackingForPendingEmergencyAdmitVoCollection listPendingEDEmergencyAdmission(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT tracking FROM Tracking AS tracking ");
		query.append(" LEFT JOIN tracking.associatedPendingEmergencyAdmission AS pendEmergency ");
		query.append(" LEFT JOIN pendEmergency.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		
		query.append(" WHERE pendEmergency.allocatedWard.id = :WARD_ID ");
		query.append(" AND (pendEmergency.admissionStatus.id = :DISCHARGE_STATUS OR pendEmergency.admissionStatus.id = :DTA_STATUS)");
		
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");				paramValues.add(ward.getID_Location());
		paramNames.add("DISCHARGE_STATUS");		paramValues.add(EmergencyAdmissionStatus.DISCHARGED.getID());	
		paramNames.add("DTA_STATUS");			paramValues.add(EmergencyAdmissionStatus.DTA.getID());
		
		//WDEV-21119
		List<?> results = getDomainFactory().find(query.toString(), paramNames, paramValues);
		if (results == null || results.isEmpty())
			return null;
		TrackingForPendingEmergencyAdmitVoCollection recordsList = TrackingForPendingEmergencyAdmitVoAssembler.createTrackingForPendingEmergencyAdmitVoCollectionFromTracking(results);
		for (TrackingForPendingEmergencyAdmitVo item :recordsList)
		{
			item.setLOS(item.getIntLengthOfStay());
		}
		//WDEV-21119  -- end of
		return recordsList;
	}
	
	
	public CatsReferralPendingEmergencyNonEDAdmissionListVoCollection listPendingEmergencyAdmissions(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT referral FROM CatsReferral AS referral ");
		query.append(" LEFT JOIN referral.patient AS patient ");
		query.append(" LEFT JOIN referral.repatriationRequest AS pendAdmission LEFT JOIN pendAdmission.ward AS ward ");
		query.append(" LEFT JOIN pendAdmission.currentStatus AS pendAdmitStatus LEFT JOIN pendAdmitStatus.status AS status ");
		query.append(" WHERE ");
		query.append(" ward.id = :WARD_ID AND status.id = :STATUS_ID ");
		query.append(" and (pendAdmission.proposedTransferDate IS NULL or pendAdmission.proposedTransferDate < :DATETO)"); //WDEV-21085
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");				paramValues.add(ward.getID_Location());
		paramNames.add("STATUS_ID");			paramValues.add(PendingAdmissionStatus.CREATED.getID());
		paramNames.add("DATETO");				paramValues.add(new Date().addDay(1).getDate());
		
		return CatsReferralPendingEmergencyNonEDAdmissionListVoAssembler.createCatsReferralPendingEmergencyNonEDAdmissionListVoCollectionFromCatsReferral(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}
	


	public PatientElectiveListBedInfoVoCollection listPatientsForElectiveAdmission(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel ");
		query.append(" LEFT JOIN pel.electiveListStatus AS els LEFT JOIN els.electiveListStatus AS elStatus ");
		query.append(" LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.tCIWard AS ward ");
		query.append(" LEFT JOIN pel.patient AS patient ");
		query.append(" WHERE ward.id = :WARD_ID AND  elStatus.id = :TCI_GIVEN AND tci.isActive = 1 AND tci.currentOutcome is null ");
		query.append( " AND tci.tCIDate = :TODAY");
		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("WARD_ID");		paramValues.add(ward.getID_Location());
		paramNames.add("TCI_GIVEN");	paramValues.add(WaitingListStatus.TCI_GIVEN.getID());
		paramNames.add("TODAY");		paramValues.add(new java.util.Date());
		
		return PatientElectiveListBedInfoVoAssembler.createPatientElectiveListBedInfoVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
		
//		query.append(" LEFT JOIN inpat.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
//		query.append(" LEFT JOIN pas.specialty AS inpatSpecialty ");
//		
//		query.append(" WHERE inpat.pasEvent.location.id = :WARD_ID AND inpat.bed is not null ");
//		query.append(" AND (inpatSpecialty is null OR inpatSpecialty.id NOT IN (");

		// TODO - Ask what restriction should be applied here
//			query.append("SELECT wardSpecialty.id FROM WardBayConfig AS wardConfig LEFT JOIN wardConfig.ward AS ward LEFT JOIN wardConfig.specialties AS spec LEFT JOIN spec.instance AS wardSpecialty WHERE ward.id = :WARD_ID ");
		
//		query.append(")");
//		query.append(")");
//		
//		ArrayList<String> paramNames = new ArrayList<String>();
//		ArrayList<Object> paramValues = new ArrayList<Object>();
//		
//		paramNames.add("WARD_ID");
//		paramValues.add(ward.getID_Location());
//		
//		return PatientLite_IdentifiersVoAssembler.createPatientLite_IdentifiersVoCollectionFromPatient(getDomainFactory().find(query.toString(), paramNames, paramValues));
//
//		StringBuilder query = new StringBuilder("SELECT COUNT (pel.id) FROM PatientElectiveList AS pel ");
//		query.append("LEFT JOIN pel.electiveListStatus AS els LEFT JOIN els.electiveListStatus AS elStatus ");
//		query.append("LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.tCIWard AS ward ");
//		query.append("LEFT JOIN pel.patient AS patient ");
//		
//		query.append("WHERE ward.id = :WARD_ID AND elStatus.id = :TCI_GIVEN AND tci.isActive = 1 AND tci.currentOutcome is null ");
//		
//		String[] paramNames = new String[] {"WARD_ID", "TCI_GIVEN"};
//		Object[] paramValues = new Object[] {ward.getID_Location(), WaitingListStatus.TCI_GIVEN.getID()};
//		
//		return (int) getDomainFactory().countWithHQL(query.toString(), paramNames, paramValues);
	}
	

	public InpatientEpisodeLiteVo getInpatientEpisodeLite(InpatientEpisodeRefVo inpatientEpisode)
	{
		if (inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			return null;
		
		return InpatientEpisodeLiteVoAssembler.create((InpatientEpisode) getDomainFactory().getDomainObject(InpatientEpisode.class, inpatientEpisode.getID_InpatientEpisode()));
	}


	public PendingTransfersLiteVo getPendingTransferLite(PendingTransfersRefVo transfer)
	{
		if (transfer == null || transfer.getID_PendingTransfers() == null)
			return null;
		
		return PendingTransfersLiteVoAssembler.create((PendingTransfers) getDomainFactory().getDomainObject(PendingTransfers.class, transfer.getID_PendingTransfers()));
	}


	public void cancelTransfer(PendingTransfersLiteVo transfer, LocationRefVo ward) throws StaleObjectException, ForeignKeyViolationException
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		impl.cancelTransfer(transfer, ward);
	}


	public TrackingRefVo getTrackingForPendingEmergency(PendingEmergencyAdmissionRefVo pendingEmergency)
	{
		if (pendingEmergency == null || pendingEmergency.getID_PendingEmergencyAdmission() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT track FROM Tracking AS track LEFT JOIN track.associatedPendingEmergencyAdmission AS pendEmer ");
		query.append(" WHERE ");
		query.append(" pendEmer.id = :EMER_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>(); 
		
		paramNames.add("EMER_ID");			paramValues.add(pendingEmergency.getID_PendingEmergencyAdmission());
		
		Tracking tracking = (Tracking) getDomainFactory().findFirst(query.toString(), paramNames, paramValues);
		
		return new TrackingRefVo(tracking.getId(), tracking.getVersion());
	}

	public PatientShort getPatientShort(PatientRefVo patientRefVo)
	{
		BedInfoDialog bedDialogImpl = (BedInfoDialog) getDomainImpl(BedInfoDialogImpl.class);
		return bedDialogImpl.getPatient(patientRefVo);
	}


	public PatientElectiveListBedAdmissionVo getPatientElectiveList(PatientElectiveListRefVo patientElectiveList)
	{
		if (patientElectiveList == null || patientElectiveList.getID_PatientElectiveList() == null)
			return null;
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
	}

	
	public PendingTransfersLiteVo getPendingTransferForInpatientEpisode(InpatientEpisodeRefVo voInpatRef)
	{
		BedInfoDialog bedImpl = (BedInfoDialog) getDomainImpl(BedInfoDialogImpl.class);
		return bedImpl.getPendingTransferForInpatient(voInpatRef);
	}
	
	public CareContextShortVo getCareContextForPasEvent(PASEventRefVo pasEventRef)
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		return impl.getCareContextForPasEvent(pasEventRef);
	}

	public WardConfigLiteVo getWardConfig(LocationRefVo wardRef)
	{
		BedInfoDialog bedImpl = (BedInfoDialog) getDomainImpl(BedInfoDialogImpl.class);
		return bedImpl.getWardConfig(wardRef);
	}
	
	public void updatePendingTransfer(PendingTransfersLiteVo pendingTransf)	throws StaleObjectException
	{
		if(pendingTransf == null)
			throw new CodingRuntimeException("pendingTransfer is null in method updatePendingTransfer");
		
		PendingTransfers doTransfer = PendingTransfersLiteVoAssembler.extractPendingTransfers(getDomainFactory(), pendingTransf);
		
		getDomainFactory().save(doTransfer);		
	}

	public CareContextShortVo getCareContextForTrackingAttendance(EmergencyAttendanceLiteVo emergencyAttendanceRef)
	{
		if (emergencyAttendanceRef == null || emergencyAttendanceRef.getID_EmergencyAttendance() == null)
			return null;
		
		String hql = "select cc from Tracking as track left join track.attendance as att left join att.careContext as cc WHERE (att.isRIE is null OR att.isRIE = 0) and att.id = :ATTENDANCE_ID";
		
		CareContext doCareContext = (CareContext) getDomainFactory().findFirst(hql, "ATTENDANCE_ID" , emergencyAttendanceRef.getID_EmergencyAttendance());
		
		return doCareContext != null ? CareContextShortVoAssembler.create(doCareContext) : null;
	}

	
	public void undoReadyToLeave(InpatientEpisodeLiteVo voInpatToUpdate) throws DomainInterfaceException, StaleObjectException
	{
		if (voInpatToUpdate == null || voInpatToUpdate.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("voInpatToUpdate argument is null in method undoReadyToLeave()");
		DomainFactory factory = getDomainFactory();

		InpatientEpisode inpatDO = (InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, voInpatToUpdate.getID_InpatientEpisode());
		if (inpatDO == null || !Boolean.TRUE.equals(inpatDO.isIsReadyToLeave()))
		{	
			throw new DomainInterfaceException((inpatDO == null ? "This inpatient has been discharged by another user." : "This inpatient has been removed from Ready To Leave list by another user.") + " The screen will be refreshed.");
		}
		InpatientEpisode inpatForSaveDO = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(factory, voInpatToUpdate);

		factory.save(inpatForSaveDO);		
	}
	
	//WDEV-22380
	public void returnFromHomeLeaveToWard(InpatientEpisodeLiteVo voInpat, HomeLeaveVo voHomeLeave)	throws DomainInterfaceException, StaleObjectException
	{
		if (voInpat == null)
			throw new CodingRuntimeException("voInpat argumment cannot be null in method returnFromHomeLeaveToWard()");
		
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		AdmissionDetailVo voAdmissionDetail = null;
		
		if (voInpat.getBedIsNotNull())
		{
			DomainFactory domainFactory = getDomainFactory();
			BedSpaceState doBedSpaceState = (BedSpaceState) domainFactory.getDomainObject(BedSpaceState.class, voInpat.getBed().getID_BedSpaceState());
			
			if (doBedSpaceState.getCurrentBedStatus() != null)
			{
				BedSpaceStateStatusLiteVo voBedSpaceStatus = BedSpaceStateStatusLiteVoAssembler.create(doBedSpaceState.getCurrentBedStatus());
				BedSpaceStateStatusLiteVo voPrevBedStatus = (BedSpaceStateStatusLiteVo) voBedSpaceStatus.clone();
				
				doBedSpaceState.setPreviousBedStatus(BedSpaceStateStatusLiteVoAssembler.extractBedSpaceStateStatus(domainFactory, voPrevBedStatus));
				doBedSpaceState.setCurrentBedStatus(new BedSpaceStateStatus());
				doBedSpaceState.getCurrentBedStatus().setStatusDateTime(new DateTime(voHomeLeave.getDateReturnedFromHomeLeave(),(voHomeLeave.getTimeReturnedFromHomeLeave() != null ? voHomeLeave.getTimeReturnedFromHomeLeave() : new Time(0,0))).getJavaDate());
				doBedSpaceState.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.AVAILABLE));

				voHomeLeave.setVacatedBedNumber(doBedSpaceState.getBedSpace() != null ? doBedSpaceState.getBedSpace().getBedNumber() : null);
			}

			doBedSpaceState.setInpatientEpisode(null);
			domainFactory.save(doBedSpaceState);
		}
		
		if (voInpat != null && voInpat.getPasEventIsNotNull())
			voAdmissionDetail  = impl.getAdmissionDetailByPasEvent(voInpat.getPasEvent());
		impl.returnFromHomeLeaveToWardWaitingArea(voInpat, voAdmissionDetail, voHomeLeave);		
	}
}
