//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 5007.25751)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.vo.domain.AppointmentTrackingstatusColourConfigVoAssembler;
import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.CatsReferralCurrentStatusVo;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.PatientElectiveListForDNAAppointmentsVo;
import ims.RefMan.vo.TCIForPatientElectiveListAppointmentDNAVo;
import ims.RefMan.vo.domain.CatsReferralBreachDatesVoAssembler;
import ims.RefMan.vo.domain.CatsReferralCurrentStatusVoAssembler;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForDNAAppointmentsVoAssembler;
import ims.RefMan.vo.domain.TCIForPatientElectiveListAppointmentDNAVoAssembler;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ERODStatus;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.AppointmentTrackingstatusColourConfig;
import ims.core.admin.domain.objects.CareContext;
import ims.core.clinical.domain.objects.Service;
import ims.core.domain.base.impl.BaseWardAttenderImpl;
import ims.core.helper.IPathwayPatientEventHelper;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Activity;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.ServiceLiteVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.WardAttenderAppointmentVo;
import ims.core.vo.WardAttenderAppointmentVoCollection;
import ims.core.vo.WardAttenderSearchCriteriaVo;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.domain.WardAttenderAppointmentVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainSession;
import ims.domain.SessionData;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.SessionConstants;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.Time;
import ims.icp.vo.domain.PatientICPLiteVoAssembler;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.PauseDetails;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientEventVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.objects.Appt_Tracking_Status_History;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionForWardAttenderVoCollection;
import ims.scheduling.vo.SessionServiceAndSlotActivityVo;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.domain.Appt_Tracking_Status_HistoryVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionForWardAttenderVoAssembler;
import ims.scheduling.vo.lookups.CancelAppointmentReason;
import ims.scheduling.vo.lookups.LookupHelper;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

public class WardAttenderImpl extends BaseWardAttenderImpl
{

	private static final long serialVersionUID = 1L;
	private static final int PATIENT_DNA_NAT_CODE = 33;
	
	private ims.domain.FormName WardAttender = new ims.domain.FormName(102436);
	private ims.domain.FormName WardAttenderDialog = new ims.domain.FormName(102482);
	private ims.domain.FormName WardViewDialog = new ims.domain.FormName(102262);
	
	
	public LocationLiteVoCollection getActiveHospitals(MemberOfStaffRefVo mos)
	{
		if (mos == null || mos.getID_MemberOfStaff() == null)
			return null;

		StringBuilder query = new StringBuilder();
		query.append("select location from MemberOfStaff as mos left join mos.locations as hcpLocation left join hcpLocation.location as location where" +
				" location.type = :LocType and location.isActive = :isActive and location.isVirtual = :isVirtual and mos.id = :mosID");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("LocType");
		paramValues.add(getDomLookup(LocationType.HOSP));

		paramNames.add("isActive");
		paramValues.add(Boolean.TRUE);

		paramNames.add("isVirtual");
		paramValues.add(Boolean.FALSE);

		paramNames.add("mosID");
		paramValues.add(mos.getID_MemberOfStaff());

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(query.toString(), paramNames, paramValues)).sort();
	}

	public LocationLiteVoCollection getWardsForHospital(LocationRefVo hospital)
	{
		if (hospital == null)
			return null;
		//http://jira/browse/WDEV-21222 
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		List<?> locations =  impl.listLocationsByParentLocation(LocationType.WARD,hospital, Boolean.TRUE, Boolean.FALSE,null);
		LocationLiteVoCollection locs = LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return locs.sort(true);
	}

	public ServiceLiteVoCollection listServices(String value)
	{
		
		List<?> services = getDomainFactory().find("select srv from Service as srv where srv.isActive = 1 and srv.upperName like :servName", new String[]{"servName"}, new Object[]{value.toUpperCase() + "%"});
		
		if (services == null || services.isEmpty())
			return null;
		
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services).sort();
	}

	public SessionForWardAttenderVoCollection listClinics(LocationRefVo location, Date date)
	{
		String ids = getLocationsIdsForHospital(location);
		
		DomainFactory factory = getDomainFactory();
		String query = " from Sch_Session session where session.schLocation.id in ( " + ids + " ) and session.sessionProfileType.id = :WARD_ATTENDANCE and session.sessionDate = :sessionDate and session.isActive = :isActive ORDER BY session.name ASC";
		
    	return SessionForWardAttenderVoAssembler.createSessionForWardAttenderVoCollectionFromSch_Session(factory.find(query, new String[]{"WARD_ATTENDANCE", "sessionDate", "isActive"}, new Object[]{SchProfileType.WARD_ATTENDANCE.getID(), date.getDate(), Boolean.TRUE}));
	}

	private String getLocationsIdsForHospital(LocationRefVo hospital)
	{
		if(hospital==null)
			return "NULL";
			
		OrganisationAndLocation impl =(OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation(hospital.getBoId(), new int[]{LocationType.WARD.getID()}, Boolean.TRUE,Boolean.FALSE);
	}
	
	public LocMostVo getLocation(LocationRefVo location)
	{
		DomainFactory factory = getDomainFactory();
		return LocMostVoAssembler.create((Location) factory.getDomainObject(Location.class, location.getID_Location()));
	}

	public WardAttenderAppointmentVoCollection listWardAttendances(WardAttenderSearchCriteriaVo searchCriteria)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		List<?> appointmentTrackingStatusConfig = getDomainFactory().find(" from AppointmentTrackingstatusColourConfig");

		StringBuffer query = new StringBuffer();

		query.append("SELECT icp, appts, apptTrackStatus, referral");
		query.append(" FROM PatientICP AS icp RIGHT JOIN icp.appointments AS appts LEFT JOIN appts.apptTrackingStatusHistory AS apptTrackStatus LEFT JOIN icp.careContext AS icpContext");
		query.append(", CatsReferral AS referral LEFT JOIN referral.appointments AS refAppt");
		
		query.append(" WHERE refAppt.id = appts.id AND ");
		query.append(" (apptTrackStatus.id is null or apptTrackStatus.id = (select max(th.id) from Booking_Appointment as ba join ba.apptTrackingStatusHistory as th where ba.id = appts.id))");

		if (searchCriteria.getClinicIsNotNull())
		{
			query.append(" and appts.session.id = :clinic");
			markers.add("clinic");
			values.add(searchCriteria.getClinic().getID_Sch_Session());
		}
		else
		{
			String ids = getLocationsIdsForHospital(searchCriteria.getHospital());
			
			query.append(" and appts.session.schLocation.id in ( " + ids + " )");

			if (searchCriteria.getDate() != null)
			{
				query.append(" and appts.session.sessionDate = :sessionDate");
				markers.add("sessionDate");
				values.add(searchCriteria.getDate().getDate());
			}

			query.append(" and appts.session.isActive = :isActive");
			markers.add("isActive");
			values.add(Boolean.TRUE);

			query.append(" and appts.session.sessionProfileType.id = :WARD_ATTENDANCE_ID");
			markers.add("WARD_ATTENDANCE_ID");
			values.add(SchProfileType.WARD_ATTENDANCE.getID());
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			query.append(" and appts.session.service.id = :idService");
			markers.add("idService");
			values.add(searchCriteria.getService().getID_Service());
		}
		
		if (searchCriteria.getWardIsNotNull())
		{
			query.append(" and appts.session.schLocation.id = :idWard");
			markers.add("idWard");
			values.add(searchCriteria.getWard().getID_Location());
		}
		
		if( searchCriteria.getStatusIsNotNull())
		{
			query.append(" and appts.apptStatus.id = :STATUS_ID");
			markers.add("STATUS_ID");
			values.add(searchCriteria.getStatus().getID());
		}
		
		query.append(" and appts.apptStatus.id <> :CANCELLED_STATUS_ID ");
		markers.add("CANCELLED_STATUS_ID");
		values.add(Status_Reason.CANCELLED.getID());
		
		java.util.List<Object> list = getDomainFactory().find(query.toString(), markers, values, 500);
		Iterator<?> it = list.iterator();
		
		WardAttenderAppointmentVoCollection voColl = new WardAttenderAppointmentVoCollection();

		while (it.hasNext())
		{
			Object[] lstItem = (Object[]) it.next();
			
			Booking_Appointment doAppt = (Booking_Appointment) lstItem[1];
			
			// Populate database mapped fields
			WardAttenderAppointmentVo voWardAppt = WardAttenderAppointmentVoAssembler.create(doAppt);
			
			// Set ICP Information
			if (lstItem[0] instanceof PatientICP)
			{
				PatientICP domPatientICP = (PatientICP) lstItem[0];
				voWardAppt.setICPInfo(PatientICPLiteVoAssembler.create(domPatientICP));
			}
			
			// Set Appointment Tracking Status field from appointment
			if (lstItem[2] instanceof Appt_Tracking_Status_History)
			{
				Appt_Tracking_Status_History domApptTrackingHistory = (Appt_Tracking_Status_History) lstItem[2];
				
				voWardAppt.setCurrentApptTrakingStatus(Appt_Tracking_Status_HistoryVoAssembler.create(domApptTrackingHistory));
				
				// Set Appointment Tracking Status Colour Configuration record
				if (appointmentTrackingStatusConfig != null)
				{
					for (int i = 0; i < appointmentTrackingStatusConfig.size(); i++)
					{
						if (appointmentTrackingStatusConfig.get(i) instanceof AppointmentTrackingstatusColourConfig)
						{
							AppointmentTrackingstatusColourConfig domColourConfig = (AppointmentTrackingstatusColourConfig) appointmentTrackingStatusConfig.get(i);
							
							if (domColourConfig.getTrackingStatus().getId() == domApptTrackingHistory.getTrackingStatus().getId())
							{
								voWardAppt.setAppointmentTrackingStatus(AppointmentTrackingstatusColourConfigVoAssembler.create(domColourConfig));
							}
						}
					}
				}
			}
			
			// Get the CatsReferral for this appointment
			if (lstItem[3] instanceof CatsReferral)
			{
				voWardAppt.setReferral(CatsReferralBreachDatesVoAssembler.create((CatsReferral) lstItem[3]));
			}
			
			String bookingCommentsForAppt = getBookingCommentForAppt(doAppt);
			voWardAppt.setBookingComments(bookingCommentsForAppt);
			
			voColl.add(voWardAppt);
		}
		
		return voColl;
	}

	private String getBookingCommentForAppt(Booking_Appointment apptDO)
	{
		if (apptDO == null)
			return null;
		
		Object obj = getDomainFactory().find("select sch.bookingComments from Sch_Booking as sch left join sch.appointments as appts where appts.id = :APPTID", new String[]{"APPTID"},new Object[]{apptDO.getId()}).get(0);

		return (obj != null && obj instanceof String) ? (String)obj : null;

	}

	public Boolean isNotACurrentInpatient(PatientRefVo patient)
	{
		String hql = "from InpatientEpisode ip where ip.pasEvent in (select event.id from PASEvent as event where event.patient.id = :patID)";
		
		DomainFactory factory= getDomainFactory();
		
		List l = factory.find(hql, new String[] {"patID"}, new Object[] {patient.getID_Patient()});	
		
		if (l != null && l.size() > 0)
		{
			return false;
		}
		
		return true;
	}

	public Booking_AppointmentVo getBookingAppt(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return null;
		
		return Booking_AppointmentVoAssembler.create((Booking_Appointment)getDomainFactory().getDomainObject(Booking_Appointment.class, appointment.getID_Booking_Appointment()));
	}

	public CatsReferralListVo getCatsReferral(Booking_AppointmentRefVo appointment)
	{
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select catsRef from CatsReferral as catsRef left join catsRef.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{appointment.getID_Booking_Appointment()});
		
		if (cats != null && cats.size() > 0)
			return CatsReferralListVoAssembler.create((CatsReferral)cats.get(0));
		
		return null;
	}

	public CareContextShortVo getCareContext(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select CC from CatsReferral as catsRef left join catsRef.careContext as CC where catsRef.id = :referralID",	new String[]{"referralID"},	new Object[]{catsReferral.getID_CatsReferral()});
		
		if (cats != null && cats.size() > 0)
			return CareContextShortVoAssembler.create((CareContext)cats.get(0));
		
		return null;
		
	}

	public PatientElectiveListForDNAAppointmentsVo getPatientElectiveList(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return null;
		
		String query = "SELECT electivList FROM PatientElectiveList AS electivList LEFT JOIN electivList.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID ";
		
		return PatientElectiveListForDNAAppointmentsVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}

	public SessionServiceAndSlotActivityVo getServiceAndActivityByAppt(Booking_AppointmentRefVo appointment)
	{
		if(appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		SessionServiceAndSlotActivityVo voServiceAndSlot = null;
		List items = null;
		
		String hql = "select activity, session.service from Booking_Appointment as appt left join appt.activity as activity left join appt.session as session where (appt.id = :idAppt)";
		items = getDomainFactory().find(hql, new String[]{"idAppt"}, new Object[]{appointment.getID_Booking_Appointment()});
			
		if( items != null && items.size() > 0)
		{
			Iterator it = items.iterator();
			if(it.hasNext())
			{
				Object[] item = (Object[]) it.next();
				Activity doActivity = (Activity) item[0];
				Service doService = (Service) item[1];
				
				ActivityRefVo voActivity = new ActivityRefVo(doActivity.getId(), doActivity.getVersion());
				ServiceLiteVo voService = ServiceLiteVoAssembler.create(doService);
				
				voServiceAndSlot = new SessionServiceAndSlotActivityVo();
				voServiceAndSlot.setSessionService(voService);
				voServiceAndSlot.setSlotActivity(voActivity);
			}
		}
	
		return voServiceAndSlot;
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appointment, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		try
		{
			Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
			ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
			return sessionAdminImp.cancelAppt(appointment, requestType, requestSource);
		}
		catch (ClassNotFoundException e)
		{
			// log the exception in system log - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}
		
		return null;
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo appointment) throws StaleObjectException
	{
		try
		{
			Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
			ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
			sessionAdminImp.updateCatsReferralAdditionalInvStatus(catsReferral, appointment);
		}
		catch (ClassNotFoundException e)
		{
			// log the exception in system log - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}
		
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		try
		{
			Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
			ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
			sessionAdminImp.updateCatsReferralCancelStatus(catsReferral);
		}
		catch (ClassNotFoundException e)
		{
			// log the exception in system log - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}
		
	}

	public void cancelTCIAndReferralEROD(CatsReferralRefVo catsReferral,Booking_AppointmentRefVo appointment, CancelAppointmentReason cancellationReason, String cancellationComments, Boolean isProviderCancellation,	Boolean isPatientCancellation, Boolean cancelledForNonmedicalReason) throws StaleObjectException
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method cancelReferralEROD");
		
		if(appointment == null || appointment.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("apptRef is null or id not provided in method getTheatreAppointment");
		
		Integer tciClock = null;

		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		
		PatientElectiveList doPatientElectiveList = null;
		Boolean saveElectiveList = false;
		
		PathwayClock currentClock = null;
		if(doCatsReferral != null && doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null)
		{
			currentClock = doCatsReferral.getJourney().getCurrentClock();
		}
		
		if(currentClock != null)
		{
			String patientElectiveListQuery = "select electiveList from PatientElectiveList as electiveList left join electiveList.referral as cats left join electiveList.pathwayClock as pc where cats.id = :CatsId and pc.id = :PathwayClock";
			List<?> electiveList = factory.find(patientElectiveListQuery, new String[] {"CatsId", "PathwayClock"}, new Object[] {catsReferral.getID_CatsReferral(), currentClock.getId()});
			
			if(electiveList != null && electiveList.size() > 0 && electiveList.get(0) instanceof PatientElectiveList)
			{
				doPatientElectiveList = (PatientElectiveList) electiveList.get(0);	
			}
		}
	
		MemberOfStaff domainMOS = null;
		Object mosUser = getMosUser();
		
		if(mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory,((MemberOfStaffShortVo) getMosUser()));
		}
		
		if(doPatientElectiveList != null)
		{
			ElectiveListStatus status = new ElectiveListStatus();
			status.setElectiveListStatus(getDomLookup(WaitingListStatus.REQUIRES_TCI));
			status.setAuthoringUser(domainMOS);
			status.setStatusDateTime(new java.util.Date());
			status.setStatusComment("Requires new TCI - Previous TCI given was cancelled.");
			
			doPatientElectiveList.setElectiveListStatus(status);
			
			if(doPatientElectiveList.getElectiveListStatusHistory() == null)
				doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());
			
			doPatientElectiveList.getElectiveListStatusHistory().add(status);
			
			TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();
			
			
			if(doTCIDetails != null)
			{
    			doPatientElectiveList.setTCIDetails(null);
    			
    			TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();
    			
    			//WDEV-18249
    			if (isPatientCancellation)
    			{
    				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_PATIENT_2));
    			}
    			else if (isProviderCancellation)
    			{	
    					
            		if(doTCIDetails.getTCIDate() != null && (new java.util.Date()).before(doTCIDetails.getTCIDate()))
            			newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_BEFORE_6));
            		else
            				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
    				
        			
        			if(doPatientElectiveList.getPathwayClock() != null)
        				tciClock = doPatientElectiveList.getPathwayClock().getId();   			
    			}
    			
    			//wdev-18419
    			if( Boolean.TRUE.equals(cancelledForNonmedicalReason))
    			{
    				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
					newOutcome.setCancelledForNonMedicalReason(true);
    				
    				ims.framework.utils.Date dtnow = new ims.framework.utils.Date();
    				dtnow.addDay(28);
    				//doPatientElectiveList.setRequiresTCIBy(dtnow.getDate());
    				doPatientElectiveList.setTCICancelledByProvider(true);
    				
    			}
    			//---------
    			newOutcome.setChangeBy(domainMOS);
    			newOutcome.setStatusDateTime(new java.util.Date());
    			//WDEV-22845
    			newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.LINKEDTHEATREAPPTCANCELLED));
    			newOutcome.setCancellationReason(cancellationReason != null ? getDomLookup(cancellationReason) : null);
    			newOutcome.setReasonComments(cancellationComments);
    			
    			doTCIDetails.setCurrentOutcome(newOutcome);
    			if(doTCIDetails.getOutcomeHistory() == null)
    				doTCIDetails.setOutcomeHistory(new ArrayList());
    			
    			doTCIDetails.getOutcomeHistory().add(newOutcome);
    			
    			if(doPatientElectiveList.getTCIHistory() == null)
    				doPatientElectiveList.setTCIHistory(new ArrayList());
    			
    			doPatientElectiveList.getTCIHistory().add(doTCIDetails);
			}
			
			saveElectiveList = true;
		}
		
		if(Boolean.TRUE.equals(isProviderCancellation))
		{
    		if(doCatsReferral.getElectiveEROD() == null)
    			return;
    		
    		ReferralEROD doErod = null;
    		ReferralEROD elEROD = null;
    		
    		for(int i=0; i<doCatsReferral.getElectiveEROD().size(); i++)
    		{
    			if(doCatsReferral.getElectiveEROD().get(i) instanceof ReferralEROD)
    			{
    				if(((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock() != null && ((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getPathWayClock().getId().equals(tciClock))
    				{
    					doErod = (ReferralEROD) doCatsReferral.getElectiveEROD().get(i);
    					doCatsReferral.getElectiveEROD().remove(i);
    					break;
    				}
    			}
    		}
    		    		
    		if(doErod != null)
    		{
    			doErod.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
    		
    			if(doCatsReferral.getElectiveERODHistory() == null)
    				doCatsReferral.setElectiveERODHistory(new java.util.ArrayList());
    		
    			doCatsReferral.getElectiveERODHistory().add(doErod);
    			
    			if(doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null && doCatsReferral.getJourney().getCurrentClock().getCurrentPause() != null)
    			{
    				PauseDetails currentPause = doCatsReferral.getJourney().getCurrentClock().getCurrentPause();
    				
    				if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails() != null)
    				{
    					for(int i=0; i<doCatsReferral.getJourney().getCurrentClock().getPauseDetails().size(); i++)
    					{
    						PauseDetails pause = (PauseDetails) doCatsReferral.getJourney().getCurrentClock().getPauseDetails().get(i);
    						if(currentPause.equals(pause) && Boolean.TRUE.equals(pause.isActive()))
    						{
    							doCatsReferral.getJourney().getCurrentClock().getPauseDetails().remove(i);
    							break;
    						}
    					}
    				}
    				
    				currentPause.setActive(false);
    				doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add(currentPause);	
    				
    				//WDEV-19772 
        			if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && doCatsReferral != null && doCatsReferral.getJourney() != null)			
        			{
    					createNewPatientEvent(null, CatsReferralListVoAssembler.create(doCatsReferral), HardCodedEvents.PATHWAYUNPAUSED);	    			
        			}
    			}
    		
    			factory.save(doCatsReferral);
    		}
    		
    		//WDEV-18455 
    		if (doPatientElectiveList != null && doPatientElectiveList.getEROD() != null && doPatientElectiveList.getEROD() instanceof ReferralEROD && doPatientElectiveList.getEROD().getPathWayClock() != null && doPatientElectiveList.getEROD().getPathWayClock().getId().equals(tciClock))
    		{
    			elEROD = (ReferralEROD) doPatientElectiveList.getEROD();
    			doPatientElectiveList.setEROD(null);
    			saveElectiveList = true;
    		}
    		
    		if (elEROD != null)
    		{
    			elEROD.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
    			doPatientElectiveList.getERODHistory().add(elEROD);
    		}
		}
		
		if(saveElectiveList)
			factory.save(doPatientElectiveList);
	}
	
	private void createNewPatientEvent(Booking_Appointment doAppt, CatsReferralListVo voCatsReferral, HardCodedEvents event) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		EventLiteVo hardCodedEvent = getHardCodedEvent(event.getID());
		PatientEventVo savedPatEv = createPatientEvent(voCatsReferral, hardCodedEvent,doAppt);
		if (doAppt != null && savedPatEv != null)
			doAppt.getPathwayEvents().add(PatientEventVoAssembler.extractPatientEvent(factory, savedPatEv));		
	}
	
	public EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[] {"eventID", "statusID"},new Object[] {event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID()});
		
		if (list == null || list.size() == 0)
			return null;
		
		return EventLiteVoAssembler.create((Event)list.get(0));
	}
	
	private DateTime getArrivalOrDNADateTime(Booking_Appointment doAppt) 
	{
		boolean arrivalStatus = Status_Reason.ARRIVAL.equals(LookupHelper.getStatus_ReasonInstance(getLookupService(), doAppt.getApptStatus().getId()));
		boolean dnaStatus = Status_Reason.DNA.equals(LookupHelper.getStatus_ReasonInstance(getLookupService(), doAppt.getApptStatus().getId()));
		
		if(doAppt == null || doAppt.getApptStatus() == null || !(arrivalStatus || dnaStatus))		
			return null;
		Boolean haveTime = doAppt.getArrivalTime() != null &&  doAppt.getApptStartTime()!=null;
		
		return new DateTime(doAppt.getAppointmentDate()!= null ? new Date( doAppt.getAppointmentDate()) : new Date(),
				haveTime ? new Time(arrivalStatus ? doAppt.getArrivalTime() : doAppt.getApptStartTime()): new Time());
	}
	private PatientEventVo createPatientEvent(CatsReferralListVo voCatsReferral, EventLiteVo hardCodedEvent, Booking_Appointment doAppt) throws StaleObjectException
	{
		CatsReferral catsReferral = CatsReferralListVoAssembler.extractCatsReferral(getDomainFactory(), voCatsReferral);
		PatientPathwayJourney patientJBo = catsReferral != null ? catsReferral.getJourney() : null;
				
		PatientEventVo savedPatEv = null;
		
		
		if (patientJBo != null && hardCodedEvent != null)
		{				
				DateTime arrivalOrDNADateTime = getArrivalOrDNADateTime(doAppt);
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(catsReferral.getPatient()));
				patEvent.setEvent(hardCodedEvent);
				patEvent.setEventDateTime(HardCodedEvents.PATHWAYUNPAUSED.equals(hardCodedEvent) && patientJBo.getCurrentClock() != null && patientJBo.getCurrentClock().getCurrentPause() != null && patientJBo.getCurrentClock().getCurrentPause().getPauseStop() != null ? new DateTime( patientJBo.getCurrentClock().getCurrentPause().getPauseStop()) : new DateTime(arrivalOrDNADateTime));//WDEV-20603
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(patientJBo));
				
				try
				{
					Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
					IPathwayPatientEventHelper pathwayImpl = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);
					
					try
					{
						savedPatEv = pathwayImpl.instantiatePatientEvent(patEvent);
					}
					catch (DomainInterfaceException e)
					{ 
						throw new DomainRuntimeException("Domain Error occured in save Event " + e.getMessage(), e);
					}
					
				}
				catch (ClassNotFoundException e)
				{
					// log the exception in system log - but it should be fine
					createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
				}
				
		}
		
		return savedPatEv;
	}

	public CatsReferralCurrentStatusVo getCatsReferral(CatsReferralRefVo catsReferral)
	{
		return CatsReferralCurrentStatusVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, catsReferral.getID_CatsReferral()));
	}

	public void saveWardAttendance(Booking_AppointmentVo wardAttendance, CatsReferralListVo catsReferral, SessionSlotVo dnaSessionSlot, PatientElectiveListForDNAAppointmentsVo electiveList, Boolean isFirstAppointmentActivity, Boolean isUndoDNA, Boolean isUndoArrival) throws DomainInterfaceException, StaleObjectException
	{
		if(wardAttendance == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!wardAttendance.isValidated())
			throw new DomainRuntimeException("Booking Record not validated before save");
		if(catsReferral == null)
			throw new DomainRuntimeException("Invalid Referral to save");
		if(!catsReferral.isValidated())
			throw new DomainRuntimeException("Referral Record not validated before save");
		
		if(dnaSessionSlot != null && !dnaSessionSlot.isValidated())
			throw new CodingRuntimeException("Session Slot is not validated.");
		
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, wardAttendance);		
		
		if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue()&& doAppt.getActivity().isFirstAppointment() && catsReferral != null)
		{	
			if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) )			
			{
				createNewPatientEvent(doAppt, catsReferral, HardCodedEvents.APPOINTMENTATTENDED);	    
			}
			else if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)) && isUndoDNA )			
			{
				createNewPatientEvent(doAppt, catsReferral, HardCodedEvents.APPOINTMENTUNDNA);	    
			}
			else if (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)) && isUndoArrival )			
			{
				createNewPatientEvent(doAppt, catsReferral, HardCodedEvents.APPOINTMENTUNARRIVED);	    
			}
		}
		
		factory.save(doAppt);
		
		// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
		// When booking a first activity appointment - use the booking date for RTT Status (the date the appointment is created, not the appointment date)
		java.util.Date eventDateTime = new java.util.Date();
		
		//WDEV-18524 
		CatsReferral doCats = updateCatsReferral(factory, catsReferral, doAppt, isFirstAppointmentActivity, eventDateTime);

		try
		{
			factory.save(doCats);
		}
		catch(StaleObjectException e)// workaround to not get stale when mark an appt as dna because of WDEV-17644 
		{
			doCats = updateCatsReferral(factory, catsReferral, doAppt, isFirstAppointmentActivity, eventDateTime);
			factory.save(doCats);
		}
		
		////WDEV-18524
		if (doCats != null && isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()) && doCats.getJourney() != null && doCats.getJourney().getCurrentClock() != null)
		{	
			instantiatePatientEvent(doCats);
		}
		
		if (electiveList != null)
		{
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap(); 
			TCIForPatientElectiveListAppointmentDNAVo currentTCI = electiveList.getTCIDetails();
			TCIForPatientElectiveList domTCIToSave = TCIForPatientElectiveListAppointmentDNAVoAssembler.extractTCIForPatientElectiveList(factory, currentTCI, domMap);
			electiveList.setTCIDetails(null);
			PatientElectiveList domPatientElectiveList = PatientElectiveListForDNAAppointmentsVoAssembler.extractPatientElectiveList(factory, electiveList, domMap);
			
			factory.save(domPatientElectiveList);
			factory.save(domTCIToSave);
		}
		
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private CatsReferral updateCatsReferral(DomainFactory factory, CatsReferralListVo voCatsReferral, Booking_Appointment doAppt, Boolean isFirstAppointmentActivity, java.util.Date eventDateTime)
	{
		//WDEV-18524 
		CatsReferral doCats = (CatsReferral) factory.getDomainObject(CatsReferral.class, voCatsReferral.getID_CatsReferral());
		
		//WDEV-17987 added the code below so the form will do the same thing on "Arrived" and "Undo Arrival" as RefMan.ClinicList
		if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)))
				{
					doCats.setLastApptArrivedDate(new Date().getDate());
				}
			}			
		}
		//WDEV-17987 when Undo Arrival, if there are no other Arrived or Seen appointments for the Referral, clear last appointment arrived date so the context menus are updated correctly
		else if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)) && canClearLastPatArrivedDate(doCats))
				{
					doCats.setLastApptArrivedDate(null);
				}
			} 
		}
		
		
		//WDEV-18325 //WDEV-18524
		PathwayRTTStatus rttSTatusDO = null;
				
		if (isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()))
		{
			PatientPathwayJourney journeyDO = doCats.getJourney();

			int dnaNatCode = PATIENT_DNA_NAT_CODE;

			rttSTatusDO = createPatientRTTStatus(dnaNatCode, eventDateTime);
			
			if  (journeyDO != null)
			{
				if (journeyDO.getCurrentClock() != null)
				{
					PathwayClock ptwClockDO = journeyDO.getCurrentClock();

					ptwClockDO.setCurrentRTTStatus(rttSTatusDO);

					List<PathwayRTTStatus> ptwClockHistory = ptwClockDO.getRTTStatusHistory();

					if (ptwClockHistory == null)
					{
						ptwClockHistory = new java.util.ArrayList();
					}
					
					ptwClockHistory.add(rttSTatusDO);	
				}
			}
			
			doCats.setCurrentRTTStatus(rttSTatusDO);
		}
		
		return doCats;
	}
	
	private boolean canClearLastPatArrivedDate(CatsReferral doCats)
	{
		if (doCats.getAppointments() == null)
			return true;

		Iterator<?> it1 = doCats.getAppointments().iterator();

		while (it1.hasNext())
		{
			Booking_Appointment doItem = (Booking_Appointment) it1.next();

			if (doItem.getApptStatus() != null && (doItem.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) || doItem.getApptStatus().equals(getDomLookup(Status_Reason.SEEN))))
			{
				return false;
			}
		}

		return true;
	}
	
	private void  instantiatePatientEvent(CatsReferral doCats) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		if(doCats == null || doCats.getJourney() == null || doCats.getJourney().getCurrentClock() == null)
			return;
		
		RTTStatusEventMapVo rttEventMap = null;

		if (doCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
		{
			rttEventMap = getRTTStatusEventMap(doCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus());
		}
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;
		
		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCats.getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		try
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
			IPathwayPatientEventHelper pathwayImpl = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);
			
			try
			{
				pathwayImpl.instantiatePatientEvent(patEvent);
			}
			catch (DomainInterfaceException e)
			{ 
				throw new DomainRuntimeException("Domain Error occured in save Event " + e.getMessage(), e);
			}
			
		}
		catch (ClassNotFoundException e)
		{
			// log the exception in system log - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}
		
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18325 
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode and event.encounterType is null ";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPatientRTTStatus(int nationalCode, java.util.Date eventDateTime) //WDEV-18325
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);
		
		rttSTatusDO.setRTTStatus(rttStatusPoint);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(eventDateTime);
		
		rttSTatusDO.setSetting("O");
		
		return rttSTatusDO;
	}
	
	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18325
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();
		
		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);
						
		}
		return null;
	}
	
	public void saveBookingAppointment(Booking_AppointmentVo appointment) throws DomainInterfaceException,	StaleObjectException 
	{
		if(appointment == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!appointment.isValidated())
			throw new DomainRuntimeException("Record not validated before save");
		
		
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appointment);		
		factory.save(doAppt);
		
	}

	public LocationLiteVo getAppointmentLocation(Booking_AppointmentRefVo appointment)
	{
		
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		String hql = "select location from Booking_Appointment as appointment left join appointment.session as sess left join sess.schLocation as location where appointment.id = :apptID ";
		List<?> results = getDomainFactory().find(hql, new String[]{"apptID"}, new Object[] {appointment.getID_Booking_Appointment()});
		
		if (results != null && results.size() > 0)
		{	
			
			return LocationLiteVoAssembler.create((Location) results.get(0));			
		}
		
		return null;
	}
	//WDEV-22711 - workaround fix to avoid FWUI change 
	public Boolean isAdmissionScreenAlreadyOpened()
	{
		DomainSession session = getSession();
		SessionData sessData = (SessionData)session.getAttribute(SessionConstants.SESSION_DATA);
		if (sessData == null)
			return false;
		
		ArrayList<?> prevForms = sessData.previousForms.get();
		
		if (prevForms == null || prevForms.size() == 0)
			return false;				
		if ((prevForms.contains(WardAttender.getID()) || prevForms.contains(WardAttenderDialog.getID())) && prevForms.contains(WardViewDialog.getID()))
			return true;		
		return false;
	}
	}
