//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.30 build 2046.20208)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.vo.EDAttendanceFeedVo;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.SuspensionDetailsForPatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.ifCatsReferralVo;
import ims.RefMan.vo.domain.ifCatsReferralVoAssembler;
import ims.RefMan.vo.lookups.CancerType;
import ims.RefMan.vo.lookups.CatsReferralCategory;
import ims.RefMan.vo.lookups.ElectiveAdmissionType;
import ims.RefMan.vo.lookups.ReferralUrgency;
import ims.ccosched.vo.lookups.AppointmentStatus;
import ims.ccosched.vo.lookups.Priority;
import ims.ccosched.vo.lookups.Status;
import ims.clinical.vo.lookups.DischargeLetterStatus;
import ims.clinical.vo.lookups.EDischargeSummarySection;
import ims.clinical.vo.lookups.EDischargeSummarySectionStatus;
import ims.clinical.vo.lookups.VTEAsessmentStatus;
import ims.clinical.vo.lookups.VTEAssessmentContextType;
import ims.clinical.vo.lookups.VTEAssessmentStatusReason;
import ims.coe.vo.lookups.DischargeDestination;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextHistory;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.domain.objects.DementiaConfiguration;
import ims.core.admin.domain.objects.EmergencyAttendance;
import ims.core.admin.domain.objects.EpisodeOfCareHistory;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.domain.objects.VTEAssessmentConfig;
import ims.core.admin.domain.objects.VTEAssessmentExclusions;
import ims.core.admin.pas.domain.objects.AEAttendance;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.BedSpaceStateStatus;
import ims.core.admin.pas.domain.objects.ConsultantStay;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.domain.objects.HomeLeave;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.OutpatientAttendance;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.domain.objects.PendingElectiveAdmission;
import ims.core.admin.pas.domain.objects.PendingEmergencyAdmission;
import ims.core.admin.pas.domain.objects.PendingTransfers;
import ims.core.admin.pas.domain.objects.TransferHistory;
import ims.core.admin.pas.domain.objects.WardStay;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.clinical.domain.objects.AuthoringInformation;
import ims.core.clinical.domain.objects.Dementia;
import ims.core.clinical.domain.objects.DementiaAssessAndInvestigate;
import ims.core.clinical.domain.objects.DementiaFind;
import ims.core.clinical.domain.objects.DementiaWorklistStatus;
import ims.core.clinical.domain.objects.Procedure;
import ims.core.clinical.domain.objects.VTERiskAssessment;
import ims.core.configuration.domain.objects.PrivateInsuranceCompany;
import ims.core.domain.Demographics;
import ims.core.domain.objects.PatientSummaryRecord;
import ims.core.generic.domain.objects.Address;
import ims.core.generic.domain.objects.CommunicationChannel;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Gp;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.GpRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.scheduler.domain.objects.PatientApptDiary;
import ims.core.vo.AneAttendanceVo;
import ims.core.vo.CareContextInterfaceVo;
import ims.core.vo.CareContextInterfaceVoCollection;
import ims.core.vo.ConsultantStayLiteVo;
import ims.core.vo.ConsultantStayVoCollection;
import ims.core.vo.DischargedEpisodeVo;
import ims.core.vo.GpLiteToPracticeLiteVo;
import ims.core.vo.GpLiteVo;
import ims.core.vo.InpatientEpisodeVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocShortMappingsVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.MedicWithMappingsLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.MemberOfStaffShortVoCollection;
import ims.core.vo.OrgShortVo;
import ims.core.vo.OutPatientAttendanceVo;
import ims.core.vo.PasEventVo;
import ims.core.vo.PatientShort;
import ims.core.vo.PendingElectiveAdmissionHl7Vo;
import ims.core.vo.PendingEmergencyAdmissionVo;
import ims.core.vo.PendingEmergencyAdmissionVoCollection;
import ims.core.vo.PrivateInsuranceCompanyVo;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.WardStayVo;
import ims.core.vo.WardStayVoCollection;
import ims.core.vo.ifInpatientEpisodeVo;
import ims.core.vo.ifPendingTransferVo;
import ims.core.vo.domain.AneAttendanceVoAssembler;
import ims.core.vo.domain.CareContextInterfaceVoAssembler;
import ims.core.vo.domain.CommChannelVoAssembler;
import ims.core.vo.domain.DischargedEpisodeVoAssembler;
import ims.core.vo.domain.ExtendedAdmissionDetailVoAssembler;
import ims.core.vo.domain.GpLiteVoAssembler;
import ims.core.vo.domain.GpShortVoAssembler;
import ims.core.vo.domain.HcpAssembler;
import ims.core.vo.domain.InpatientEpisodeVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocShortMappingsVoAssembler;
import ims.core.vo.domain.MedicWithMappingsLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.OrgShortVoAssembler;
import ims.core.vo.domain.OutPatientAttendanceVoAssembler;
import ims.core.vo.domain.PasEventVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PendingElectiveAdmissionHl7VoAssembler;
import ims.core.vo.domain.PendingEmergencyAdmissionVoAssembler;
import ims.core.vo.domain.PersonAddressAssembler;
import ims.core.vo.domain.PrivateInsuranceCompanyVoAssembler;
import ims.core.vo.domain.ifInpatientEpisodeVoAssembler;
import ims.core.vo.domain.ifPendingTransferVoAssembler;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.ChannelType;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.ElectiveAdmissionStatus;
import ims.core.vo.lookups.EmergencyAdmissionStatus;
import ims.core.vo.lookups.HcpDisType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.ManagementIntention;
import ims.core.vo.lookups.MethodOfAdmission;
import ims.core.vo.lookups.MethodOfDischarge;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.MsgUpdateType;
import ims.core.vo.lookups.PasEventType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PatientStatus;
import ims.core.vo.lookups.QueueType;
import ims.core.vo.lookups.SourceOfAdmission;
import ims.core.vo.lookups.SourceOfEmergencyReferral;
import ims.core.vo.lookups.SourceOfReferral;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.TCIType;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.TransferReason;
import ims.core.vo.lookups.WardType;
import ims.correspondence.vo.PasContactVo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.dto_move.domain.objects.ActivityGroup;
import ims.dto_move.domain.objects.Appointment;
import ims.dto_move.domain.objects.AppointmentDetail;
import ims.dto_move.domain.objects.InternalLocation;
import ims.dto_move.domain.objects.Profile;
import ims.dto_move.domain.objects.SchedActivity;
import ims.dtomove.vo.RadioTherapySchedQueueVo;
import ims.dtomove.vo.ifApptDetailsVo;
import ims.dtomove.vo.domain.ifApptDetailsVoAssembler;
import ims.edischarge.domain.objects.DischargeDetails;
import ims.edischarge.domain.objects.ReadyToLeave;
import ims.edischarge.domain.objects.Summary;
import ims.edischarge.domain.objects.SummaryDetail;
import ims.emergency.domain.objects.EDPartialAdmission;
import ims.emergency.vo.ifEDAttendanceVo;
import ims.emergency.vo.ifInpatientADTVo;
import ims.emergency.vo.domain.ifEDAttendanceVoAssembler;
import ims.emergency.vo.domain.ifInpatientADTVoAssembler;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.framework.utils.PartialDate;
import ims.framework.utils.Time;
import ims.hl7.vo.ElectiveListMessageQueueVo;
import ims.hl7.vo.GPMessageQueueVo;
import ims.hl7.vo.GPPracticeMessageQueueVo;
import ims.hl7.vo.MOSMessageQueueVo;
import ims.hl7.vo.WardMessageQueueVo;
import ims.hl7.vo.ifElectiveListMessageQueueVo;
import ims.hl7.vo.ifGPMessageQueueVo;
import ims.hl7.vo.ifGPPracticeMessageQueueVo;
import ims.hl7.vo.ifMOSMessageQueueVo;
import ims.hl7.vo.ifWardMessageQueueVo;
import ims.hl7.vo.domain.ifElectiveListMessageQueueVoAssembler;
import ims.hl7.vo.domain.ifGPMessageQueueVoAssembler;
import ims.hl7.vo.domain.ifGPPracticeMessageQueueVoAssembler;
import ims.hl7.vo.domain.ifMOSMessageQueueVoAssembler;
import ims.hl7.vo.domain.ifWardMessageQueueVoAssembler;
import ims.hl7adtout.domain.objects.InPatientADTMessageQueue;
import ims.hl7adtout.domain.objects.InpatientEpisodeQueue;
import ims.hl7adtout.vo.InPatientADTMessageQueueRefVo;
import ims.ocrr.vo.lookups.OrderCategory;
import ims.ocrr.vo.lookups.OrderMessageStatus;
import ims.ocs_if.vo.InpatientEpisodeQueueVo;
import ims.oncology.domain.objects.PatTreatmentPlan;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.DirectoryofService;
import ims.scheduling.domain.objects.Sch_Booking;
import ims.scheduling.domain.objects.Session_ListOwner;
import ims.scheduling.vo.AppointmentMessageQueueVo;
import ims.scheduling.vo.BookingAppointmentTheatreVo;
import ims.scheduling.vo.BookingAppointmentTheatreVoCollection;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.ifOutBookingAppointmentVo;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.ifOutBookingAppointmentVoAssembler;
import ims.scheduling.vo.domain.ifSessionListOwnerVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;
import ims.vo.interfaces.IHL7OutboundMessageHandler;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.hibernate.StaleObjectStateException;
import org.joda.time.Days;
import org.joda.time.Hours;



public class ADTImpl extends DomainImpl implements ims.core.domain.ADT, ims.domain.impl.Transactional
{
	/**
	 * 
	 */
	private static final long	serialVersionUID	= -4990538760120461815L;
	private static final Logger			LOG		= Logger.getLogger(ADTImpl.class);

	public ims.core.vo.InpatientEpisodeVo admitPatient(PatientShort patVo, ims.core.vo.InpatientEpisodeVo episVo, DateTime transactionDT) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!episVo.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainInterfaceException("Internal Patient ID must be valued.");
		}
		// Ignore the ID if sent in. Don't throw exception. If patient already admitted, will be caught in later check.
		// WDEV-4759 Checking ConfigFlag here as we are associating a saved PasEvent with the Inpatient Episode - the code was nulling our attempts at this 
		DomainFactory factory = getDomainFactory();
		if(ConfigFlag.HL7.ADT_IN_UPDATE_PARTIAL_ADMISSION_ONLY.getValue()) //WDEV-17135
		{
			// Get and update the Partial Admission record
			if(episVo!=null&&episVo.getPasEvent()!=null&&episVo.getPasEvent().getPasEpisodeId()!=null)
			{
				String partialAdmissionId=episVo.getPasEvent().getPasEpisodeId();
				try
				{
					int id=Integer.parseInt(partialAdmissionId);
					EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
					if(episVo!=null&&episVo.getPasEvent()!=null&&episVo.getPasEvent().getLocation()!=null)
					{
						LocationLiteVo wardVo=episVo.getPasEvent().getLocation();
						Location ward=(Location)factory.getDomainObject(Location.class, wardVo.getID());
						partialAdmission.setAllocatedWard(ward);
					}

					factory.save(partialAdmission);
					return null;
				}
				catch (NumberFormatException e)
				{
					if(episVo.getPasEvent()!=null)
					{
						throw new DomainInterfaceException("Failed to parse Partial Admission ID "+episVo.getPasEvent().getPasEpisodeId());
					}
					else
					{
						throw new DomainInterfaceException("Failed to read Partial Admission ID.");
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
					throw new DomainInterfaceException(e.getMessage());
				}
			}
			else throw new DomainInterfaceException("Partial Admission ID not found in PV1-50");
		}
		if (!(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()))
		{
			episVo.setID_InpatientEpisode(null);
			episVo.getPasEvent().setID_PASEvent(null);
		}
		else
		{
			if (episVo.getPasEventIsNotNull()&&episVo.getPasEvent().getID_PASEventIsNotNull())
			{
				CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + episVo.getPasEvent().getID_PASEvent());
				if (doCareContext!=null)
				{
					doCareContext.setContext(getDomLookup( ContextType.INPATIENT));
					
					doCareContext.setCurrentStatus(new CareContextStatusHistory());
					doCareContext.getCurrentStatus().setStatusDateTime(new Date());
					doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
					doCareContext.getStatusHistory().add(doCareContext.getCurrentStatus());
				
					// Set the estiimated Discharge Date if in the InpatientEpisode
					//http://jira/browse/WDEV-13288
					if (episVo.getEstDischargeDate() != null)
						doCareContext.setEstimatedDischargeDate(episVo.getEstDischargeDate().getJavaDate());
					
					factory.save(doCareContext);
				}
				
			}
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo != null)
		{
			//throw new DomainInterfaceException("Patient is already an inpatient. Cannot Admit.");
			return InpatientEpisodeVoAssembler.create(ipDo);
		}

		
		ims.core.patient.domain.objects.Patient domPatient =  (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		
		
//		PASEvent domPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPasEvent().getPasEventId());
		
		//Get TCI PASEvent
		PASEvent domTCIPas=null;
		if (episVo!=null&&episVo.getPreAdmitNumber()!=null)
		 domTCIPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPreAdmitNumber());
		
		
		PendingElectiveAdmission domPEA =  getDomPendingElectiveAdmission(domPatient,domTCIPas);
		if(null!=domPEA)
		{
			domPEA.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
			factory.save(domPEA);
		}
		
		ipDo = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, episVo);
		if (ipDo != null)
		{
			WardStay ws = new WardStay();
			ws.setTransferDateTime(ipDo.getAdmissionDateTime());
			if (ipDo.getPasEvent()!=null)
				ws.setWard(ipDo.getPasEvent().getLocation());
			ws.setWardType(ipDo.getWardType());
			if (ipDo.getBed() != null) //WDEV-20134
				ws.setBedSpace(ipDo.getBed().getBedSpace());
		
			if(ipDo.getPasEvent()!=null&&ipDo.getPasEvent().getConsultant()!=null)
			{
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(ipDo.getPasEvent().getConsultant());
				cs.setTransferDateTime(ipDo.getPasEvent().getEventDateTime());
				cs.setSpecialty(ipDo.getPasEvent().getSpecialty());
				
				ipDo.getConsultantStays().add(cs);
			}
			ipDo.getWardStays().add(ws);
			
			// http://jira/browse/WDEV-19680
			vteOnAdmission(ipDo, domPatient, isElective(domPEA));
			//end http://jira/browse/WDEV-19680
		}
		
		//http://jira/browse/WDEV-20919 - Code to replace commented out code below
		if(ipDo != null && ipDo.getPasEvent() != null)
		{
			triggerAdmissionEvent(ipDo.getPasEvent());
		} //WDEV-20919
		
		factory.save(ipDo);

		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(ipDo,episVo, transactionDT);
		factory.save(ad);
		domPatient.setWard(ipDo.getPasEvent().getLocation());
		domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());		// WDEV-17867 - Retain current responsible consultant
		factory.save(domPatient);
		
		// WDEV-16240 - check to see if a new Dementia Record is required
		createDementiaRecordIfRequired(factory, ad);

		// http://jira/browse/WDEV-20919 Code commented out and InpatientEpisodeVoAssembler.create(ipDo) re-instated
//		// WDEV-19481 Assemble VO before triggerAdmissionEvent
//		InpatientEpisodeVo ipVo = InpatientEpisodeVoAssembler.create(ipDo);
//		
//		ipVo.setAdmissionDetails(new AdmissionDetailRefVo(ad.getId(), ad.getVersion()));
//		
//		if(ipVo.getPasEvent()!=null)
//			triggerAdmissionEvent(ipVo.getPasEvent());
//		
//		triggerAdmissionEvent(ipDo.getPasEvent());
//		
//		return ipVo;
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}

	
//	private void triggerAdmissionEvent(PASEvent pasEvent)
//	{
//		// TODO Auto-generated method stub
//		
//	}


	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		return transferPatient( patVo,  hcp,  ward,null);
	}
	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		return transferPatient( patVo,  hcp,  ward, stay,null,null,null,null);

	}
	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay,LocationRefVo fromWard, DateTime transferDateTime, DateTime transactionDT, LookupInstVo specialty) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (patVo == null)
		{
			throw new DomainRuntimeException("Patient cannot be null!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo == null)
		{
			//Patient is not currently an inpatient, so ignore transfer event.
			return null;	
		}	
		performTransfer(ipDo, patVo, hcp, ward,stay,fromWard,transferDateTime,transactionDT,specialty);
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}

	public ims.core.vo.DischargedEpisodeVo dischargePatient(ims.core.vo.PatientShort patVo, ims.core.vo.DischargedEpisodeVo dischEpisVo, CareContextInterfaceVo voCareContext) throws ForeignKeyViolationException, DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!dischEpisVo.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainInterfaceException("Internal Patient ID must be valued.");
		}

		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		DischargedEpisode disDo = DischargedEpisodeVoAssembler.extractDischargedEpisode(factory, dischEpisVo);
		PASEvent peDo = disDo.getPasEvent();
		
		InpatientEpisode ipDo = getCurrentAdmission(factory, patVo);
		
		AdmissionDetail doAdmissionDetail = null;	//WDEV-12825 
		
		if (ipDo != null)
		{
			//Want to re-use the one that was created for the Admission. No need for a new one on Discharge.
			peDo = ipDo.getPasEvent();
			factory.initialize(peDo);
			
			//WDEV-8312
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
			if(admList != null && admList.size() > 0)
			{
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				doAdmissionDetail.setWard(null);
				doAdmissionDetail.setBed(null);
				//factory.save(doAdmissionDetail); //WDEV-12825 
			}
			
			disDo.setPasEvent(peDo);
			disDo.setAdmissionDetail(doAdmissionDetail);
			disDo.setAdmissionType(ipDo.getAdmissionType());//WDEV-16397

//http://jira/browse/WDEV-19680
//			disDo.setVTEAssessmentStatus(ipDo.getVTEAssessmentStatus());
//			disDo.setVTERiskAssessment(ipDo.getVTERiskAssessment());
			vteOnDischarge(domPatient, disDo, ipDo);
			
//http://jira/browse/WDEV-19680			
			
			
			updateBed(factory, peDo);
			
			if(ipDo != null)
			{
				PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
				if(doTransfer != null)
					getDomainFactory().delete(doTransfer);
				//http://jira/browse/WDEV-13288
				if(ipDo.getDischargeReadyDate()!=null)
				{
					disDo.setDischargeReadyDate(ipDo.getDischargeReadyDate());
				}
				//WDEV-20134
				WardStay oldWardStay = getPreviousOpenWardStay(ipDo.getWardStays());
				oldWardStay.setTransferOutDateTime(disDo.getDischargeDateTime());
				
				//http://jira/browse/WDEV-15997
				disDo.getWardStays().addAll(ipDo.getWardStays());
				
				ConsultantStay currentConsultantStay = getCurrentConsultantStay(ipDo.getConsultantStays());
				if(currentConsultantStay!=null)//WDEV-20545
					currentConsultantStay.setEndDateTime(disDo.getDischargeDateTime());
				
				disDo.getConsultantStays().addAll(ipDo.getConsultantStays());		
			}

			factory.delete(ipDo);
		} 
		else if (ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()==false 
				&& ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()==false
				&& ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()==false) //wdev-16771
		{
			throw new StaleObjectException(null);//null as ipDo no longer exists - wdev-16798
		}
		else if(peDo != null && peDo.getPasEventId()!=null)// Try and get the PAS event   //wdev-15823
		{
			peDo = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient,peDo.getPasEventId());
		}
		
		if( peDo != null )  //wdev-15823
		    factory.save(peDo);
		
		disDo.setPasEvent(peDo);
		factory.save(disDo);
		
		//JME: 20061023: Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear current medic from Patient record. No longer an inpatient, it doesn't have a current responsible medic
		domPatient.setCurrentResponsibleConsultant(null);
		
		// WDEV-18784 & WDEV-18783 - Clear Dementia Worklist status from patient on discharge 
		domPatient.setDementiaWorklistStatus(null);
		domPatient.setDementiaBreachDateTime(null);
		
		factory.save(domPatient);
		
		//WDEV-10231
		if( ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() || ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue() )  //wdev-16427
		{
			CareContext careContextDom=null;
			if(voCareContext != null)
			{
				careContextDom=CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext);
			}
			else
			{
				if( peDo != null)  //wdev-16427
				    careContextDom = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
			}
			if (careContextDom!=null)
			{
				careContextDom.setBedNumber(null);
				careContextDom.setContext(getDomLookup(ContextType.INPATIENT));
				careContextDom.setCurrentStatus(new CareContextStatusHistory());
				careContextDom.getCurrentStatus().setStatusDateTime(new Date());
				// WDEV-12694 Set EndDateTime if not already set i.e. this isn't called from HL7Engine
				if (careContextDom.getEndDateTime() == null)
					careContextDom.setEndDateTime(dischEpisVo.getDischargeDateTime().getJavaDate());
				careContextDom.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
				careContextDom.getStatusHistory().add(careContextDom.getCurrentStatus());
				factory.save(careContextDom);
			
				// Set the admission date time as it may have been updated
				Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + careContextDom.getId());
				if (domSummary != null)
				{
					domSummary.setAdmissionDateTime(careContextDom.getStartDateTime());
					factory.save(domSummary);

					// WDEV-12731 Only update the edischarge details if a letter has NOT been generated 
					if (domSummary.getDischargeDocuments() == null || domSummary.getDischargeDocuments().size() == 0)
					{
						// WDEV-12588 Update the discharging ward, consultant and specialty
						// only if value already set as otherwise problems exist when trying
						// to mark ready to leave
						DischargeDetails domEDischarge = (DischargeDetails) getDomainFactory().findFirst("from DischargeDetails dd where dd.careContext.id = " + careContextDom.getId());
						if (domEDischarge != null)
						{
							if (domEDischarge.getDischargingWard() != null && peDo.getLocation() != null)
								domEDischarge.setDischargingWard(peDo.getLocation());
							if (domEDischarge.getDischargingConsultant() != null && disDo.getPasEvent().getConsultant() != null)
								domEDischarge.setDischargingConsultant(disDo.getPasEvent().getConsultant());
							if (domEDischarge.getDischargingSpecialty() != null && disDo.getPasEvent().getSpecialty() != null)
								domEDischarge.setDischargingSpecialty(disDo.getPasEvent().getSpecialty());
							if (domEDischarge.getDateOfDischarge() != null && disDo.getDischargeDateTime() != null)
								domEDischarge.setDateOfDischarge(disDo.getDischargeDateTime());
							factory.save(domEDischarge);
						}
					}
					
					//WDEV-12825 - Start
					if(doAdmissionDetail == null)
					{
						List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
						if(admList != null && admList.size() > 0)
						{
							doAdmissionDetail =  (AdmissionDetail) admList.get(0);
						}
					}
					
					if(doAdmissionDetail != null)
					{
						if(DischargeLetterStatus.GENERATED.getID() != domSummary.getDischargeLetterStatus().getId() && DischargeLetterStatus.ARCHIVED.getID() != domSummary.getDischargeLetterStatus().getId())
						{
							doAdmissionDetail.setAdmissionDateTime(careContextDom.getStartDateTime());					
						}
					}
					//WDEV-12825 - End
				}
			}
		}
		
		//WDEV-12825
		if(doAdmissionDetail != null)
			factory.save(doAdmissionDetail);
	
		// WDEV-16240 Check if a dementia record is to be updated
		updateDementiaRecordForDischarge(factory, doAdmissionDetail, disDo);
		
		//http://jira/browse/WDEV-20340
//		if (doAdmissionDetail.getPasEvent().getPasEventId() != null)
//			markAssociatedAppoinmentAsDischarged(factory, new Integer(doAdmissionDetail.getPasEvent().getId()));//wdev-18155
		if (doAdmissionDetail != null
				&& doAdmissionDetail.getPasEvent() != null
				&& doAdmissionDetail.getPasEvent().getPasEventId() != null) //WDEV-20340
			markAssociatedAppoinmentAsDischarged(factory, new Integer(doAdmissionDetail.getPasEvent().getId()));//wdev-18155
		
		// WDEV-19481 Assemble VO before triggerDischargeEvent
		DischargedEpisodeVo disVo = DischargedEpisodeVoAssembler.create(disDo);
		
		if(disVo.getPasEvent()!=null)
			triggerDischargeEvent(disVo.getPasEvent());
		
		return disVo;
		
		//return DischargedEpisodeVoAssembler.create(disDo);
	}

	private WardStay getPreviousOpenWardStay(Set wardStays)
	{
		if (wardStays == null)
			return null;
		
		Iterator<?> it = wardStays.iterator();
		
		while (it.hasNext())
		{
			Object ws = it.next();
			
			if (ws instanceof WardStay)
			{
				if (((WardStay) ws).getTransferOutDateTime() == null)
					return (WardStay) ws;
			}
		}
		return null;		
	}


	private void markAssociatedAppoinmentAsDischarged(DomainFactory factory, Integer pasEventID) throws StaleObjectException
	{

		String hql = "from Booking_Appointment ba " + 
		" where ba.pASEvent.id = :eventId " +
		"and ba.currentStatusRecord.status = :statID";

		ArrayList<String> labels = new ArrayList<String>();
		labels.add("eventId");
		labels.add("statID");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(pasEventID);
		values.add(getDomLookup(Status_Reason.ADMITTED));
	
		BookingAppointmentTheatreVoCollection voList = BookingAppointmentTheatreVoAssembler.createBookingAppointmentTheatreVoCollectionFromBooking_Appointment(getDomainFactory().find(hql.toString(), labels, values));

		if (voList != null
			&& voList.size() > 0)
		{
			for (int i = 0 ; i < voList.size() ; i++)
			{
				BookingAppointmentTheatreVo vo = voList.get(i);
				Booking_Appointment doAppt = (Booking_Appointment) getDomainFactory().getDomainObject(vo);
				
				doAppt.getApptStatusHistory().add(doAppt.getCurrentStatusRecord());

				Appointment_Status doApptStat = new Appointment_Status();
				doApptStat.setStatus(getDomLookup(Status_Reason.DISCHARGED));
				doApptStat.setStatusChangeDateTime(new DateTime().getJavaDate());
				doAppt.setCurrentStatusRecord(doApptStat);
				doAppt.setApptStatus(getDomLookup(Status_Reason.DISCHARGED));
				
				factory.save(doAppt);
			}
		}
		
	}


	private BedSpaceState getBedSpaceStateByPasEvent(PASEvent peDo)
	{
		if (peDo == null || peDo.getId() == null)
			throw new CodingRuntimeException("peDo is null or id not provided in method getBedSpaceStateByPasEvent");
		
		String hql = "from BedSpaceState as bed join fetch bed.inpatientEpisode.pasEvent as pe where pe.id = " + peDo.getId();
		List lstBeds = getDomainFactory().find(hql);
		if(lstBeds != null && lstBeds.size() == 1)
			return (BedSpaceState) lstBeds.get(0);
		
		return null;
	}

	public Boolean cancelAdmission(PatientShort patVo) throws ForeignKeyViolationException, StaleObjectException 
	{
		//WDEV-20174
		PasEventVo peVo = null; //WDEV-20174
		
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo == null)
		{
			//Return Silently if patieOnt is not currently an inpatient
			return Boolean.FALSE;					
		}
		PASEvent peDo = ipDo.getPasEvent();
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		vteOnCancelAdmission(ipDo, domPatient);
		
		//WDEV-20174 - Trigger A11 (Cancel Admission HL7 message)
		if(peDo != null)
		{
			peVo = PasEventVoAssembler.create(peDo);
			if(peVo != null)
			{
				triggerCancelAdmissionEvent(peVo);
			}
		} //WDEV-20174
		
		// WDEV-7506, If Episodes are being instantiated, we want
		// to remove the link between the PasEvent and CareContext and close the carecontext
		// to allow deletion to proceed
		disconnectFromPasEvent(factory, peDo);
		if(ipDo != null)
		{
			PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
			if(doTransfer != null)
			{

				//WDEV-20174 Ensure that A26 (Cancel Pending Transfer message is generated for any pending transfer
				if(ipDo.getPasEvent()!=null)
				{
					if(peVo != null)
					{
						triggerCancelPendingTransferEvent(peVo);
					}
				} //WDEV-19974

				getDomainFactory().delete(doTransfer);
			}
			updateBed( factory, peDo); 
		}
		factory.delete(ipDo);
		// wdev-8301 - can't delete as AdmissionDetails will exist
		// factory.delete(peDo);
		
		//JME: 20061023: Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear the Current Responsible Consultant from Patient record. No longer an inpatient
		domPatient.setCurrentResponsibleConsultant(null);
		factory.save(domPatient);
		
		rieDementiaRecords(factory, peDo);  // WDEV-16240 rie the Dementia records as this admission is no longer valid
		return Boolean.TRUE;
	}


	/**
	 * WDEV-7506
	 * disconnectFromPasEvent
	 * Check if there is a CareConext linked to this PasEvent
	 * if there is, remove the link and close the carecontext
	 * @param factory
	 * @param peDo
	 * @throws StaleObjectException 
	 */
	private void disconnectFromPasEvent(DomainFactory factory, PASEvent peDo) throws StaleObjectException 
	{
		if (!(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()||ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()))
			return;
			
		List lst= CareContext.listCareContextByPasEvent(factory, peDo);
		if (lst != null && lst.size() > 0)
		{
			// Only one CareContext per pas event
			CareContext domCareContext = (CareContext) lst.get(0);
			domCareContext.setPasEvent(null);
			domCareContext.setEndDateTime(new java.util.Date());
			//WDEV-10231
			domCareContext.setCurrentStatus(new CareContextStatusHistory());
			domCareContext.getCurrentStatus().setStatusDateTime(new Date());
			domCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.CANCELLED));
			domCareContext.getStatusHistory().add(domCareContext.getCurrentStatus());
			
			factory.save(domCareContext);
		}
	}

	public DischargedEpisodeVo getCurrentDischarge(PatientShort patVo, DischargedEpisodeVo dischEpisVo)
	{
		DomainFactory factory = getDomainFactory();
		DischargedEpisode domDischarge = getCurrentDischargeRecord(factory, patVo, dischEpisVo);
		return (DischargedEpisodeVoAssembler.create(domDischarge));
	}
	
	private DischargedEpisode getCurrentDischargeRecord(DomainFactory factory, PatientShort patVo, DischargedEpisodeVo dischEpisVo)
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		DischargedEpisode disEpisBo = DischargedEpisodeVoAssembler.extractDischargedEpisode(factory, dischEpisVo);
		PASEvent peDo = disEpisBo.getPasEvent();		

		
		String hql = "from DischargedEpisode de " + 
					" where de.pasEvent.patient = :pat " + 
					" and de.pasEvent.pasEventId = :eventId ";
		
		ArrayList<String> labels = new ArrayList<String>();
		labels.add("pat");
		labels.add("eventId");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(domPatient);
		values.add(peDo.getPasEventId());
		if (disEpisBo.getDischargeDateTime() != null)
		{
			hql +=" and de.dischargeDateTime = :disDate";
			labels.add("disDate");
			values.add(disEpisBo.getDischargeDateTime());
		}
		List<?> l = factory.find(hql, labels, values);		
		if (l != null && l.size() > 0)
		{
			if (l.size() > 1)
				throw new DomainRuntimeException("Duplicate data found for Patient, PasEvent and DateTime");
			
			return (DischargedEpisode) l.get(0);
		}
		
		return null;
	}
	

	//wdev-16657
	private PendingEmergencyAdmissionVoCollection listPendingEmergencyAdmissions(DomainFactory factory, PatientShort patVo, PasEventVo pasEvent)
	{
		String hql = "from PendingEmergencyAdmission pea " + 
					" where pea.pasEvent.patient.id = :pat " + 
					" and pea.pasEvent.id = :eventId ";
		
		ArrayList<String> labels = new ArrayList<String>();
		labels.add("pat");
		labels.add("eventId");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(patVo.getID_Patient());
		values.add(pasEvent.getID_PASEvent());
		
		return PendingEmergencyAdmissionVoAssembler.createPendingEmergencyAdmissionVoCollectionFromPendingEmergencyAdmission(getDomainFactory().find(hql.toString(), labels, values));
	}
	//wdev-16657
	
	public InpatientEpisodeVo cancelDischarge(PatientShort patVo, DischargedEpisodeVo dischEpisVo, CareContextInterfaceVo careContextVo) throws ForeignKeyViolationException, StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo != null)
		{
			//No need to do anything. Patient is still an inpatient.
			return InpatientEpisodeVoAssembler.create(ipDo);					
		}
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		DischargedEpisode disEpisBo = getCurrentDischargeRecord(factory, patVo, dischEpisVo);

		PASEvent peDo=null;
		LookupInstance vteStatus=null;
		VTERiskAssessment vteRiskAssessment = null;
		LookupInstance vteStatusReason=null;

		ipDo = new InpatientEpisode();
		if(disEpisBo!=null)
		{
			ipDo.getWardStays().addAll(disEpisBo.getWardStays());
			ipDo.getConsultantStays().addAll(disEpisBo.getConsultantStays());
		}
		
		if (disEpisBo != null)
		{			
			//Need to delete the Discharge record
			peDo = disEpisBo.getPasEvent();
			factory.initialize(peDo);
			
			ipDo.setAdmissionType(disEpisBo.getAdmissionType());//WDEV-16397
			
			vteStatus=disEpisBo.getVTEAssessmentStatus();
			vteRiskAssessment = disEpisBo.getVTERiskAssessment();
			vteStatusReason = disEpisBo.getVTEAssessmentStatusReason();//WDEV-19680
			
			try 
			{
				factory.delete(disEpisBo);
			}
			catch (StaleObjectStateException e)   //wdev-16427 
			{
				throw new StaleObjectException(null);
			}
		}
		
		// wdev-7261 - No PasEvent, so there was no discharge record for the patient
		if (peDo == null)
			throw new DomainRuntimeException("Discharge Record not found for this Patient");
		
		ipDo.setPasEvent(peDo);
		ipDo.setIsOnLeave(Boolean.FALSE);
		
		//WDEV-14993 - starts here
		AdmissionDetail addmissionDetails =null;
		if (ipDo!=null)
		{
			addmissionDetails = getCurrentAdmissionDetail(ipDo.getPasEvent());
			ipDo.setAdmissionDateTime(addmissionDetails.getAdmissionDateTime());
			ipDo.setEstDischargeDate(addmissionDetails.getEstDischargeDate()); //WDEV-20324
			ipDo.setWardType(addmissionDetails.getWardType());//WDEV-20324
			ipDo.setReasonForAdmission(addmissionDetails.getReasonForAdmission());//WDEV-20324

			// WDEV-16346 reset the ward in Admission Detail
			addmissionDetails.setWard(ipDo.getPasEvent().getLocation());
			
			//http://jira/browse/WDEV-15128 Added flag condition
			if(ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue()&&
					ipDo.getPasEvent()!=null && ipDo.getPasEvent().getLocation()!=null &&
					!Boolean.TRUE.equals(ipDo.getPasEvent().getLocation().isVTEAsessmentNotRequired()))
			{
				ipDo.setVTEAssessmentStatus(vteStatus);
				ipDo.setVTERiskAssessment(vteRiskAssessment);
				ipDo.setVTEAssessmentStatusReason(vteStatusReason);
			}
		}//WDEV-14993 - ends here
		
		try 
		{
			factory.save(ipDo);
			domPatient.setWard(ipDo.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Consultant for Patient record
			domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
			factory.save(domPatient);
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}
		
		// WDEV-12588 - If CareContext not null, save it as bed number and end datetime cleared
		if (careContextVo != null && (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() || ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()) || ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue() )		//wdev-16428
		{
			CareContext careContextDom=CareContextInterfaceVoAssembler.extractCareContext(factory, careContextVo);
			if(careContextDom!=null)
			{
				careContextDom.setCurrentStatus(new CareContextStatusHistory());
				careContextDom.getCurrentStatus().setStatusDateTime(new Date());
				careContextDom.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
				careContextDom.getStatusHistory().add(careContextDom.getCurrentStatus());
				factory.save(careContextDom);
			// Flag the summary as it exists, but the discharge was cancelled from PAS
			Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + careContextDom.getId());
			if (domSummary != null)
			{
				domSummary.setWasPatientDischargedThenUndone(true);
				factory.save(domSummary);
			}

			// It was agreed to leave the discharge details (as displayed on Ready to Leave) as is if the
			// discharge letter was generated – the customer will have to use the supplementary details to 
			// send any letters to GP to reflect any new discharge details.. We will only set these list of
			// fields that I listed on the Ready To Leave to NULL when no discharge letter was generated.
			if (domSummary != null && (domSummary.getDischargeDocuments()== null || domSummary.getDischargeDocuments().size() == 0))
			{
				// Documents found, so update ready to leave values
				ReadyToLeave domReadyToLeave = (ReadyToLeave) getDomainFactory().findFirst("from ReadyToLeave rl where rl.careContext.id = " + careContextDom.getId());
				if (domReadyToLeave != null)
				{
					domReadyToLeave.setIsComplete(false);
					domReadyToLeave.setCompletedOn(null);
					domReadyToLeave.setCompletedBy(null);
										
					domReadyToLeave.getDischargeDetails().setDischargingWard(null);
					domReadyToLeave.getDischargeDetails().setDischargeMethod(null);
					domReadyToLeave.getDischargeDetails().setDischargeDestination(null);
					domReadyToLeave.getDischargeDetails().setDischargingConsultant(null);
					domReadyToLeave.getDischargeDetails().setDischargingSpecialty(null);
					domReadyToLeave.getDischargeDetails().setMethodOfDischarge(null);
					domReadyToLeave.getDischargeDetails().setDateOfDischarge(null);
					factory.save(domReadyToLeave);
				}
				
				// No discharge letters generated, set summary back to inprogress
				SummaryDetail domSumm = domSummary.getSummaryDetailRecord(factory.getLookupInstance(EDischargeSummarySection.READY_TO_LEAVE.getID()));
				if (domSumm != null)
				{
					domSumm.setProgressStatus(factory.getLookupInstance(EDischargeSummarySectionStatus.IN_PROGRESS.getID()));
					factory.save(domSumm);
				}
			}
		}
		}
		
		// WDEV-16240 Check if a dementia record is to be updated
		updateDementiaRecordForCancelDischarge(factory, addmissionDetails);
				
		return InpatientEpisodeVoAssembler.create(ipDo);
	}
	
	public void cancelAppointment(OutPatientAttendanceVo attendance, CareContextInterfaceVo voCareContext) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		
		OutpatientAttendance domAtt = OutPatientAttendanceVoAssembler.extractOutpatientAttendance(factory, attendance);
		
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue())
		{
			if(voCareContext != null)
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext));
		}
		
		// WDEV-13455
		// We may want to record this appointment within the Patient Diary
		if (ConfigFlag.DOM.RECORD_INTO_PATIENT_DIARY.getValue())
		{
			PatientApptDiary diary = createDiaryEntry(domAtt,attendance.getApptType(),attendance.getRecordingUser());
			factory.save(diary);
		}
		factory.save(domAtt);
	}

	public OutPatientAttendanceVo getOutpatientAppointment(PasEventVo pasEventVo)
	{
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from OutpatientAttendance o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return OutPatientAttendanceVoAssembler.create((OutpatientAttendance) lst.get(0));
		}
		
		return null;
	}
	
	public void updateInpatient(InpatientEpisodeVo inpatientRecord,	CareContextInterfaceVo voCareContext)	throws StaleObjectException
	{
		updateInpatient(inpatientRecord, voCareContext, true);
	}

	public void updateInpatient(InpatientEpisodeVo inpatientEpisode,CareContextInterfaceVo voCareContext, Boolean updatePatientRecord)	throws StaleObjectException
	{
		if (!inpatientEpisode.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		DomainFactory factory = getDomainFactory();
		
		if(ConfigFlag.HL7.ADT_IN_UPDATE_PARTIAL_ADMISSION_ONLY.getValue()) //WDEV-17135
		{
			// Get and update the Partial Admission record
			if(inpatientEpisode!=null&&inpatientEpisode.getPasEvent()!=null&&inpatientEpisode.getPasEvent().getPasEpisodeId()!=null)
			{
				String partialAdmissionId=inpatientEpisode.getPasEvent().getPasEpisodeId();
				try
				{
					int id=Integer.parseInt(partialAdmissionId);
					EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
					if(inpatientEpisode!=null&&inpatientEpisode.getPasEvent()!=null&&inpatientEpisode.getPasEvent().getLocation()!=null)
					{
						LocationLiteVo wardVo=inpatientEpisode.getPasEvent().getLocation();
						Location ward=(Location)factory.getDomainObject(Location.class, wardVo.getID());
						partialAdmission.setAllocatedWard(ward);
					}
					if(inpatientEpisode!=null&&inpatientEpisode.getAdmissionDateTimeIsNotNull())
					{
						partialAdmission.setAllocatedDateTime(inpatientEpisode.getAdmissionDateTime().getJavaDate());
					}
					factory.save(partialAdmission);
					return;
				}
				catch (NumberFormatException e)
				{
					if(inpatientEpisode.getPasEvent()!=null)
					{
						throw new DomainRuntimeException("Failed to parse Partial Admission ID "+inpatientEpisode.getPasEvent().getPasEpisodeId());
					}else
					{
						throw new DomainRuntimeException("Failed to read Partial Admission ID.");
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
					throw new DomainRuntimeException(e.getMessage());
				}
			}
			else throw new DomainRuntimeException("Partial Admission ID not found in PV1-50");
		}
		//WDEV-22326 
		CareContextInterfaceVoCollection careContextsOnAdmission = null;
		DateTime admDateTime = inpatientEpisode.getAdmissionDateTime().copy();		
		boolean admissionDateTimeChanged = admDateTime != null && inpatientEpisode.getAdmissionDetailUpdates() != null && !admDateTime.equals(inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime());
		if (inpatientEpisode.getAdmissionDetailUpdatesIsNotNull() && admissionDateTimeChanged)
		{			
			inpatientEpisode = updateAdditionalAdmissionInfoOnEdit(inpatientEpisode);
			careContextsOnAdmission = getCareContextsForPasEvent(inpatientEpisode.getPasEvent(),admDateTime);
			if (careContextsOnAdmission != null)
			{
				for (int i=0;i<careContextsOnAdmission.size();i++)
				{	
					CareContextInterfaceVo careContextIfVo = careContextsOnAdmission.get(i);
					careContextIfVo.setStartDateTime(inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime());
					if (inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime() != null)
					{	
						careContextIfVo.getEpisodeOfCare().setStartDate(inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime().getDate());
						careContextIfVo.getEpisodeOfCare().getCareSpell().setStartDate(inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime().getDate());
					}					
				}				
			}
		}	
		InpatientEpisode domInpat = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, inpatientEpisode);
		if (careContextsOnAdmission != null)
		{
			HashMap map =  new HashMap();
			for (int i=0;i<careContextsOnAdmission.size();i++)
			{				
				CareContextInterfaceVo careContextIfVo = careContextsOnAdmission.get(i);
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, careContextIfVo, map));
			}			
		}
		
		//WDEV-22326 --end
		if (Boolean.TRUE.equals(updatePatientRecord)) //WDEV-22326 
		{	
			Patient domPatient = (Patient) factory.getDomainObject(Patient.class, inpatientEpisode.getPasEvent().getPatient().getID_Patient());
			//http://jira/browse/WDEV-16830		
			//		if (domPatient.getWard() == null)
			if (domInpat.getPasEvent() != null
					&&domInpat.getPasEvent().getLocation()!=null
					&&domInpat.getPasEvent().getLocation().getType().equals(getDomLookup(LocationType.WARD)))
			{
				domPatient.setWard(domInpat.getPasEvent().getLocation());
				// WDEV-17867 - Set Current Responsible Clinician in Patient record
				domPatient.setCurrentResponsibleConsultant(domInpat.getPasEvent().getConsultant());
				factory.save(domPatient);
			}
		}//WDEV-22326 --end
		factory.save(domInpat);
		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(domInpat,inpatientEpisode, null); //WDEV-10593
		//factory.save(ad);//WDEV-12825
		//WDEV-22326
		if (ad != null && admissionDateTimeChanged)
		{
			PatientElectiveList patientElectiveList = getPatientElectiveListForAdmission(factory, ad);
			if (patientElectiveList  != null)
				factory.save(patientElectiveList);	
		}
	
		//WDEV-10231
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue())
		{
			if(voCareContext != null)
			{
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext));
			
				// Further change - EDischargeSummary AdmissionDateTime to be updated
				Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + voCareContext.getID_CareContext());
				if (domSummary != null)
				{
					domSummary.setAdmissionDateTime(voCareContext.getStartDateTime().getJavaDate());
					factory.save(domSummary);
					
					//WDEV-12825
					if(DischargeLetterStatus.GENERATED.getID() != domSummary.getDischargeLetterStatus().getId() && DischargeLetterStatus.ARCHIVED.getID() != domSummary.getDischargeLetterStatus().getId())
					{
						ad.setAdmissionDateTime(voCareContext.getStartDateTime().getJavaDate());					
					}
				}
			}
		}
		
		factory.save(ad);//WDEV-12825
		
		// WDEV-16240 - check if a Dementia record is to be updated
		updateDementiaRecordForInpatient(factory, ad);
	}


	private PatientElectiveList getPatientElectiveListForAdmission(DomainFactory factory, AdmissionDetail ad) throws StaleObjectException
	{
		String pelQuery = "select pel from PatientElectiveList as pel left join pel.admissions as ad where ad.id = " + ad.getId() + " AND (pel.isRIE is null OR pel.isRIE = 0)";
		List <PatientElectiveList> pelList = factory.find(pelQuery);
		PatientElectiveList patientElectiveList = null;
		if (pelList != null && pelList.size() > 0)
		{
			patientElectiveList =  (PatientElectiveList) pelList.get(0);
		}

		if (patientElectiveList == null)
		{
			String pel2Query = "select p1_1 from PatientElectiveList as p1_1 left join p1_1.tCIDetails as t1_1 left join t1_1.admissionDetail as a1_1 where t1_1.admissionDetail.id = " + ad.getId() + " AND (p1_1.isRIE is null OR p1_1.isRIE = 0)";
			List <PatientElectiveList> pelList2 = factory.find(pel2Query);
			if(pelList2 != null && pelList2.size() > 0)
			{
				patientElectiveList =  (PatientElectiveList) pelList2.get(0);
			}
		}

		if (patientElectiveList != null)
		{
			if (patientElectiveList.getElectiveListStatus() != null && patientElectiveList.getElectiveListStatus().getStatusDateTime() != null)
			{
				patientElectiveList.getElectiveListStatus().setStatusDateTime(ad.getAdmissionDateTime());					
			}
			if (patientElectiveList.getTCIDetails() != null)
			{
				if (patientElectiveList.getTCIDetails().getTCITime() != null)
				{	
					patientElectiveList.getTCIDetails().setTCITime(new DateTime(ad.getAdmissionDateTime()).getTime().toString());
				}
				if (patientElectiveList.getTCIDetails().getCurrentOutcome() != null && patientElectiveList.getTCIDetails().getCurrentOutcome().getStatusDateTime() != null)
				{
					patientElectiveList.getTCIDetails().getCurrentOutcome().setStatusDateTime(ad.getAdmissionDateTime());
				}
			}
			if(patientElectiveList.getElectiveListReason()!=null && patientElectiveList.getElectiveListReason().getId() == ElectiveListReason.TREATMENT.getId())
			{
				if (patientElectiveList.getPathwayClock() != null)
				{	
					if (patientElectiveList.getPathwayClock().getStopDate() != null)
						patientElectiveList.getPathwayClock().setStopDate(ad.getAdmissionDateTime());
					if (patientElectiveList.getPathwayClock().getCurrentRTTStatus() != null)
						patientElectiveList.getPathwayClock().getCurrentRTTStatus().setStatusDateTime(ad.getAdmissionDateTime());	
				}				
			}
		}
		return patientElectiveList;
	}
	//WDEV-22326
	private InpatientEpisodeVo updateAdditionalAdmissionInfoOnEdit(InpatientEpisodeVo inpatientEpisode)
	{
		if (inpatientEpisode == null)
			return null;
		WardStayVo admissionWardStay = getWardStayForAdmission(inpatientEpisode);
		DateTime admissionDateTime = inpatientEpisode.getAdmissionDetailUpdates().getAdmissionDateTime();
		if (admissionWardStay != null)
		{	
			admissionWardStay.setTransferDateTime(admissionDateTime);				
		}	
		ConsultantStayLiteVo admissionConsultantStay = getConsultantStayForAdmission(inpatientEpisode);
		if (admissionConsultantStay != null)
		{	
			admissionConsultantStay.setTransferDateTime(admissionDateTime);
		}
		inpatientEpisode.setAdmissionDateTime(admissionDateTime);
		if (inpatientEpisode.getPasEventIsNotNull())
		{
			inpatientEpisode.getPasEvent().setEventDateTime(admissionDateTime);
		}
		if (inpatientEpisode.getBedIsNotNull() && inpatientEpisode.getBed().getCurrentBedStatusIsNotNull())
		{
			inpatientEpisode.getBed().getCurrentBedStatus().setStatusDateTime(admissionDateTime);
		}
		return inpatientEpisode;
	}

	private CareContextInterfaceVoCollection getCareContextsForPasEvent(PasEventVo pasEvent, DateTime admDateTime)
	{
		if (pasEvent == null)
			return null;
		List ret = getDomainFactory().find("select cc from CareContext as cc left join cc.pasEvent as pevent where pevent.id = :PEVENT_ID and cc.startDateTime = :START_DATE", new String[]{"PEVENT_ID", "START_DATE"}, new Object[]{pasEvent.getID_PASEvent(),admDateTime.getJavaDate()});
		if (ret == null || ret.isEmpty())
			return null;
		return CareContextInterfaceVoAssembler.createCareContextInterfaceVoCollectionFromCareContext(ret);
	}


	private ConsultantStayLiteVo getConsultantStayForAdmission(InpatientEpisodeVo inpatientEpisode)
	{		
		ConsultantStayVoCollection conStays = inpatientEpisode.getConsultantStays();
		if (conStays == null)
			return null;
		for (int i=0;i<conStays.size();i++)
		{
			if (conStays.get(i) == null)
				continue;
			if (conStays.get(i).getTransferDateTime() != null && conStays.get(i).getTransferDateTime().equals(inpatientEpisode.getAdmissionDateTime()))
				return conStays.get(i);
		}
		return null;
	}


	private WardStayVo getWardStayForAdmission(InpatientEpisodeVo inpatientEpisode)
	{
		WardStayVoCollection wardStays = inpatientEpisode.getWardStays();
		if (wardStays == null)
			return null;
		for (int i=0;i<wardStays.size();i++)
		{
			if (wardStays.get(i) == null)
				continue;
			if (wardStays.get(i).getTransferDateTime() != null && wardStays.get(i).getTransferDateTime().equals(inpatientEpisode.getAdmissionDateTime()))
				return wardStays.get(i);
		}
		return null;
	}


	public void recordInpatientLeave(PatientRefVo patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		InpatientEpisode epis = getCurrentAdmission(factory, patient);
		if (epis != null)
		{
			epis.setIsOnLeave(Boolean.TRUE);
			factory.save(epis);
		}
	}

	public void cancelInpatientLeave(PatientShort patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Patient domPatient = PatientShortAssembler.extractPatient(factory, patient);
		InpatientEpisode epis = getCurrentAdmission(factory, patient);
		if (epis != null)
		{
		PASEvent pasevent=epis.getPasEvent();
		Location loc=(Location)factory.getDomainObject(Location.class, domPatient.getWard().getId());
		pasevent.setLocation(loc);
		epis.setPasEvent(pasevent);
	
		epis.setIsOnLeave(Boolean.FALSE);
		factory.save(epis);
		}
	}

	public InpatientEpisode getCurrentAdmission(PatientRefVo patVo) //WDEV-20324 Added getCurrentAdmission to the domain interface
	{
		DomainFactory factory = getDomainFactory();
		return this.getCurrentAdmission(factory, patVo);
	}
	
	private AdmissionDetail populateAdmissionDetailfromInpatientEpisode(InpatientEpisode ie,InpatientEpisodeVo episVo, DateTime transactionDT)
	{
		if (ie==null)
			throw new DomainRuntimeException("InpatientEpisode must not be null");
		
		PASEvent pe = ie.getPasEvent();
		AdmissionDetail ad = getCurrentAdmissionDetail(pe);
		
		if (ad == null)
			ad = new AdmissionDetail();
		ad.setPasEvent(pe);
		if(pe!=null)
		{
			if (ad.getId() == null)
				ad.setAdmissionWard(pe.getLocation());
			ad.setWard(pe.getLocation());			
			ad.setConsultant(pe.getConsultant());
			ad.setSpecialty(pe.getSpecialty());
			ad.setAdmissionDateTime(pe.getEventDateTime());
		}
			
		if(episVo!=null)
		{
			ad.setWardType(getDomLookup(episVo.getWardType()));
			ad.setMethodOfAdmission(getDomLookup(episVo.getMethodOfAdmission()));
			ad.setSourceOfAdmission(getDomLookup(episVo.getSourceOfAdmission()));
			ad.setReasonForAdmission(episVo.getReasonForAdmission());
			ad.setIsChaplainRequired(episVo.getIsChaplainRequired());
			//WDEV-14833 
			if(episVo.getPatientStatusIsNotNull())
			{
				ad.setPatientStatus(getDomLookup(episVo.getPatientStatus()));
			}
			
			//WDEV-16397
			if (Boolean.TRUE.equals(ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()) && episVo.getExtendedDetailsIsNotNull())
			{
				ad.setExtendedDetails(ExtendedAdmissionDetailVoAssembler.extractExtendedAdmissionDetail(getDomainFactory(), episVo.getExtendedDetails()));
			}
		}
		if(episVo.getEstDischargeDate()!=null)
		{
			ad.setEstDischargeDate(episVo.getEstDischargeDate().getJavaDate());
		}
		
		//WDEV-10593
		if(ad.getAdmissionTransactionDateTime() == null && transactionDT != null)
			ad.setAdmissionTransactionDateTime(transactionDT.getJavaDate());
		
		if (episVo.getAdmissionDetailUpdatesIsNotNull())
		{
			ad.setAdmissionDateTime(episVo.getAdmissionDetailUpdates().getAdmissionDateTime() != null ? episVo.getAdmissionDetailUpdates().getAdmissionDateTime().getJavaDate() : null);
			ad.setPatientStatus(episVo.getAdmissionDetailUpdates().getPatientCategory() != null ? getDomLookup(episVo.getAdmissionDetailUpdates().getPatientCategory()) : null);
			ad.setSourceOfEmergencyReferral(episVo.getAdmissionDetailUpdates().getSourceOfEmergencyReferral() != null ? getDomLookup(episVo.getAdmissionDetailUpdates().getSourceOfEmergencyReferral()) : null);
			ad.setIsChaplainRequired(episVo.getAdmissionDetailUpdates().getRequiresChaplain()); //WDEV-23030
			
			if (ad.getAdmissionRTTOutcome() != null)
			{
				if (ad.getAdmissionRTTOutcome().getFinalClock() != null && ad.getAdmissionRTTOutcome().getFinalClock().getStopDate() != null)
					ad.getAdmissionRTTOutcome().getFinalClock().setStopDate(episVo.getAdmissionDetailUpdates().getAdmissionDateTime().getJavaDate());
				if (ad.getAdmissionRTTOutcome().getFinalRTTStatus() != null)
					ad.getAdmissionRTTOutcome().getFinalRTTStatus().setStatusDateTime(episVo.getAdmissionDetailUpdates().getAdmissionDateTime().getJavaDate());
			}					
		}
		return ad;
	}
	
	private AdmissionDetail getCurrentAdmissionDetail(PASEvent pasEvent)
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from AdmissionDetail ad where ad.pasEvent=:pasEvent";
		List<?> l = factory.find(hql,new String[]{"pasEvent"},new Object[]{pasEvent});
		if (l != null && l.size() > 0)
		{
			return (AdmissionDetail)l.get(0);
		}
		return null;
	}
	
	private InpatientEpisode getCurrentAdmission(DomainFactory factory, PatientRefVo patVo) 
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		String hql = "from InpatientEpisode ip where ip.pasEvent.patient.id = :pat";
		List<?> l = factory.find(hql, new String[] {"pat"}, new Object[] {domPatient.getId()});		
		if (l != null && l.size() > 0)
		{
			return (InpatientEpisode)l.get(0);
		}
		return null;
	}

	private void performTransfer(InpatientEpisode ipDo, PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay,LocationRefVo fromWard, DateTime transferDateTime, DateTime transactionDT, LookupInstVo specialty)
	{
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		PASEvent peDo = ipDo.getPasEvent();	
		Medic medic = peDo.getConsultant();
		Location loc = peDo.getLocation();
		Medic newConsultant = null;
		
		if (hcp != null)
		{
			Hcp domHcp = (Hcp)factory.getDomainObject(Hcp.class, hcp.getID_Hcp());
			if (domHcp instanceof Medic)
				newConsultant = (Medic)domHcp;
		}
		if (ward != null)
		{
			loc = (Location)factory.getDomainObject(Location.class, ward.getID_Location());
		}
		if (stay!=null&&ipDo.getPasEvent()!=null
				&&null!=ipDo.getPasEvent().getEventDateTime()) // update the discharge date
		{
			try{
//			DateTime dt= new DateTime(ipDo.getAdmissionDateTime());
			DateTime  jAdmitDate= new DateTime(	ipDo.getPasEvent().getEventDateTime());
			jAdmitDate.addDays(stay);
			ipDo.setEstDischargeDate(jAdmitDate.getJavaDate());
			}catch (Exception e)
			{
				LOG.warn("Update to estimated discharge date failed.", e);
			}
			
		}
		
		//Transfer will only update the Consultant or the Location
		Location fromWardLoc=null;
		if(fromWard!=null)
		{
			fromWardLoc=(Location)factory.getDomainObject(Location.class,fromWard.getID_Location());
		}
		
		if( loc!= null)
		{
			if (fromWardLoc == null || !(fromWardLoc.getId().equals(loc.getId())))
			{
				WardStay oldWardStay = getPreviousOpenWardStay(ipDo.getWardStays()); ////WDEV-20134 close previous stay
				if (oldWardStay != null)
				{
					oldWardStay.setTransferOutDateTime(transferDateTime.getJavaDate());
				}
				
				WardStay wardStay = new WardStay();
				wardStay.setWard(fromWardLoc);
				if (transferDateTime != null)
				{
					wardStay.setTransferDateTime(transferDateTime.getJavaDate());
				}
				ipDo.getWardStays().add(wardStay);
			}
		}
		if(newConsultant!=null)
		{
			if(!newConsultant.equals(medic))
			{
				ConsultantStay oldCS = getCurrentConsultantStay(ipDo.getConsultantStays());
				if(oldCS != null)
				{
					oldCS.setEndDateTime(transferDateTime.getJavaDate());
				}
				
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(newConsultant);
				if(transferDateTime!=null)
				{
					cs.setTransferDateTime(transferDateTime.getJavaDate());
				}
				cs.setSpecialty(peDo != null ? peDo.getSpecialty() : null);
				
				ipDo.getConsultantStays().add(cs);
			}
			
			medic=newConsultant;
		}
		peDo.setConsultant(medic);
		peDo.setLocation(loc);
		try 
		{
			factory.save(peDo);
			factory.save(ipDo);
			
			//WDEV-7990
			if (ward != null && hasWardChanged(loc,fromWardLoc))
				updateBed(factory, peDo);
			
			domPatient.setWard(ipDo.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Clinician for Patient record
			domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
			factory.save(domPatient);
			
			//WDEV-8315
			if(peDo != null)
			{
				// WDEV-12588 - set specialty if supplied
				if (specialty != null)
					peDo.setSpecialty(factory.getLookupInstance(specialty.getID()));
					
				List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
				if(admList != null && admList.size() > 0)
				{
					AdmissionDetail doAdmissionDetail =  (AdmissionDetail) admList.get(0);
					if(loc != null)
						doAdmissionDetail.setWard(loc);
					
					//http://jira/browse/WDEV-19415
					if(newConsultant!=null)
						doAdmissionDetail.setConsultant(newConsultant);
					
					//WDEV-10421 - create a record in the history for the transfer performed on the PAS
					TransferHistory doTransferHistory = new TransferHistory();
					doTransferHistory.setTransferringFromWard(fromWardLoc);
					//WDEV-11882
					if(transferDateTime != null)
						doTransferHistory.setAcceptTransferDateTime(transferDateTime.getJavaDate());
					doTransferHistory.setAcceptingOrRejectingWard(loc);
					//WDEV-10593
					if(transactionDT != null)
						doTransferHistory.setMarkedForTransferOutDateTime(transactionDT.getJavaDate());
					
					doAdmissionDetail.getTransferHistory().add(doTransferHistory);
										
					
					doAdmissionDetail.setBed(null);
					factory.save(doAdmissionDetail);
				}
			}
			
			// WDEV-12588  - Update Associated CareContext if exist and functionality required
			if (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() 
					|| ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()
					|| ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue())
			{
				CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
				if (doCareContext != null)
				{
					// WDEV-13901 - If specialty or consultant change, keep a history
					if ((doCareContext.getEpisodeOfCare().getResponsibleHCP() != null && doCareContext.getEpisodeOfCare().getResponsibleHCP().getId() != peDo.getConsultant().getId()) ||
							(doCareContext.getEpisodeOfCare().getSpecialty().getId() != peDo.getSpecialty().getId()))
					{
						// EpisodeOfCare history record
						EpisodeOfCareHistory episHis = new EpisodeOfCareHistory();
						episHis.setEndDate(doCareContext.getEpisodeOfCare().getEndDate());
						episHis.setRelationship(doCareContext.getEpisodeOfCare().getRelationship());
						episHis.setResponsibleHCP(doCareContext.getEpisodeOfCare().getResponsibleHCP());
						episHis.setSpecialty(doCareContext.getEpisodeOfCare().getSpecialty());
						episHis.setStartDate(doCareContext.getEpisodeOfCare().getStartDate());
						if (doCareContext.getEpisodeOfCare().getEpisodeOfCareHistory() == null)
							doCareContext.getEpisodeOfCare().setEpisodeOfCareHistory(new HashSet());
						doCareContext.getEpisodeOfCare().getEpisodeOfCareHistory().add(episHis);
					}
					// WDEV-13901 - CareContext history required on consultant change
					if (doCareContext.getResponsibleHCP() != null && doCareContext.getResponsibleHCP().getId() != peDo.getConsultant().getId())
					{
						CareContextHistory ccHis = new CareContextHistory();
						ccHis.setBedNumber(doCareContext.getBedNumber());
						ccHis.setContext(doCareContext.getContext());
						ccHis.setEndDateTime(doCareContext.getEndDateTime());
						ccHis.setLocationType(doCareContext.getLocationType());
						if (doCareContext.getPasEvent() != null)
							ccHis.setPasEventId(doCareContext.getPasEvent().getPasEventId());
						ccHis.setResponsibleHCP(doCareContext.getResponsibleHCP());
						ccHis.setStartDateTime(doCareContext.getStartDateTime());
						if (doCareContext.getCareContextHistory() == null)
							doCareContext.setCareContextHistory(new HashSet());
						doCareContext.getCareContextHistory().add(ccHis);
					}
							
					

					
					doCareContext.setResponsibleHCP(peDo.getConsultant());
					doCareContext.setEstimatedDischargeDate(ipDo.getEstDischargeDate());
					if (fromWardLoc == null || loc == null || (fromWardLoc != null && loc != null && !fromWardLoc.getId().equals(loc.getId())))
						doCareContext.setBedNumber(null);

					doCareContext.getEpisodeOfCare().setSpecialty(peDo.getSpecialty());
					doCareContext.getEpisodeOfCare().setResponsibleHCP(peDo.getConsultant());
					factory.save(doCareContext);
					
				}
			}
			
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}				
	}

	private ConsultantStay getCurrentConsultantStay(Set consultantStays)
	{
		if(consultantStays == null)
			return null;
		
		Iterator it = consultantStays.iterator();
		
		while(it.hasNext())
		{
			Object cs = it.next();
			
			if(cs instanceof ConsultantStay)
			{
				if(((ConsultantStay) cs).getEndDateTime() == null)
					return (ConsultantStay) cs;
			}
		}
		
		return null;
	}

	private boolean hasWardChanged(Location loc, Location ward)
	{
		if (loc == null)
			throw new CodingRuntimeException("loc cannot be null in method hasWardChanged");
		if (ward == null)
			return true;
		
		if(loc.equals(ward))
			return false;
		
		return true;
	}


	//WDEV-7717 - get the Bed if was populated and update its status to available and unlink it from the inpatient episode
	private void updateBed(DomainFactory factory, PASEvent peDo) throws StaleObjectException
	{	
		BedSpaceState doBedSpaceState = getBedSpaceStateByPasEvent(peDo);
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setPreviousBedStatus(doBedSpaceState.getCurrentBedStatus());
			doBedSpaceState.setCurrentBedStatus(new BedSpaceStateStatus());
			doBedSpaceState.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.AVAILABLE));
			doBedSpaceState.getCurrentBedStatus().setStatusDateTime(new DateTime().getJavaDate());
			doBedSpaceState.setInpatientEpisode(null);
			factory.save(doBedSpaceState);	
		}
		
		// WDEV-12588 If CareContext linked to this pasevent, update the bed number there too
		if (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue())
		{
			CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
			if (doCareContext != null)
			{
				doCareContext.setBedNumber(null);
				factory.save(doCareContext);
			}
		}
	
	}

	public OutPatientAttendanceVo recordOPAttendance(PatientShort patVo, OutPatientAttendanceVo attVo, CareContextInterfaceVo ccVo) throws StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!attVo.isValidated())
		{
			throw new DomainRuntimeException("Attendance VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainRuntimeException("Internal Patient ID must be valued.");
		}
		DomainFactory factory = getDomainFactory();				
		OutpatientAttendance attDo = OutPatientAttendanceVoAssembler.extractOutpatientAttendance(factory, attVo);
		
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue())
		{
			if(ccVo != null)
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, ccVo));
		}
		
		try 
		{
			factory.save(attDo);
			
			// WDEV-13455
			// We may want to record this appointment within the Patient Diary
			if (ConfigFlag.DOM.RECORD_INTO_PATIENT_DIARY.getValue())
			{
				PatientApptDiary diary = createDiaryEntry(attDo,attVo.getApptType(),attVo.getRecordingUser());
				factory.save(diary);
			}
			
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}
		return OutPatientAttendanceVoAssembler.create(attDo);
	}

	/**
	 * WDEV-13455
	 * This method will setup the diary values if recording patient diary events
	 * @param attDo
	 * @return
	 */
	private static final String FIRST="F";
	private static final String SPECIAL_FIRST="S";
	private static final String REPEAT="R";
	private static final String SPECIAL_REPEAT="X";

	private PatientApptDiary createDiaryEntry(OutpatientAttendance attDo, String appointmentType, String recordingUser)
	{
		DomainFactory factory = getDomainFactory();	
		
		// First check if the patient diary exists - check via PasEvent
		List lst = PatientApptDiary.listPatientApptDiaryByPasEvent(factory, attDo.getPasEvent());
		
		PatientApptDiary diary=null;
		if (lst == null || lst.size() == 0)
		{
			diary = new PatientApptDiary();
			diary.setApptType("First");
		}
		else
		{
			diary = (PatientApptDiary)lst.get(0);
		}

		if (appointmentType != null)
		{
			if (appointmentType.equals(FIRST))
				diary.setApptType("First");
			else if (appointmentType.equals(SPECIAL_FIRST))
				diary.setApptType("Special First");
			else if (appointmentType.equals(REPEAT))
				diary.setApptType("Repeat");
			else if (appointmentType.equals(SPECIAL_REPEAT))
				diary.setApptType("Special Repeat");
		}
		
		diary.setPasEvent(attDo.getPasEvent());
		diary.setAppointmentId(attDo.getId());
		diary.setApptDate(attDo.getAppointmentDateTime());
		
		diary.setClinic(attDo.getClinic());
		if (attDo.getClinic() != null)
			diary.setClinicName(attDo.getClinic().getClinicName());
		diary.setBookedBy(recordingUser == null ? "PAS":recordingUser);
		diary.setBookedDate(attDo.getPasEvent().getEventDateTime());
		diary.setStartTime(new Time(attDo.getAppointmentDateTime()).toString());
		diary.setEndTime(diary.getStartTime());  // In Current thick client, End Time always equals Start Time
		diary.setPatient(attDo.getPasEvent().getPatient());
		diary.setPkey(null);
		diary.setStatusDate(new Date());
		
		// WDEV-15543  If the status is CLOSED - we want to record the text as 'Attended'
		if (attDo.getAppointmentStatus().getId() ==  Status_Reason.CLOSED.getID())
			diary.setStatus("Attended");
		else
			diary.setStatus(attDo.getAppointmentStatus().getText());
		diary.setSource("PAS");
		diary.setActive(true);
		

		// WDEV-13603
		// For PAS purposes, we need to retrieve the pkey to store too
		Patient domPatient = diary.getPatient();
		if (domPatient.getIdentifiers() != null && domPatient.getIdentifiers().size() > 0)
		{
			for (int i=0; i<domPatient.getIdentifiers().size(); i++)
			{
				PatientId domId = (PatientId) domPatient.getIdentifiers().get(i);
				if (domId.getType().getId() == PatIdType.PKEY.getID())
				{
					diary.setPkey(Integer.valueOf(domId.getValue()));
					break;
				}
			}
		}
		
		return diary;
	}
	
	public AneAttendanceVo recordAEAttendance(AneAttendanceVo attendance, PatientShort patient, Boolean bCancelDischarge) throws StaleObjectException, ForeignKeyViolationException
	{
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!attendance.isValidated())
		{
			throw new DomainRuntimeException("Attendance VO has not been validated!");
		}
		if(patient.getID_Patient() == null)
		{
			throw new DomainRuntimeException("Internal Patient ID must have a value.");
		}
		DomainFactory factory = getDomainFactory();				

		PasEventVo pasEvent = attendance.getPasEvent();
		PendingEmergencyAdmission PEADomain=null;
		if(pasEvent!=null)
		{
			if (bCancelDischarge)
			{
				//wdev-16657
				//List all PEA's for patient and pasevent.
				PendingEmergencyAdmissionVoCollection voPEAs = listPendingEmergencyAdmissions(factory, patient, pasEvent);
				
				//if there are any iterate thru list and delete them.
				if ( voPEAs != null && voPEAs.size() > 0)
				{
					for (int i = 0 ; i < voPEAs.size() ; i++)
					{
						PendingEmergencyAdmission doPendingEmergency = (PendingEmergencyAdmission)factory.getDomainObject(voPEAs.get(i));
						if(doPendingEmergency != null)
							factory.delete(doPendingEmergency);
					}
				}
				//wdev-16657
			}
			else
			{
				PendingEmergencyAdmissionVo pendingEmergencyAdmissionVo = getPendingEmergencyAdmission(pasEvent);
				if (pendingEmergencyAdmissionVo==null)
				{
					pendingEmergencyAdmissionVo=new PendingEmergencyAdmissionVo();
					pendingEmergencyAdmissionVo.setPasEvent(pasEvent);
				}
				if(pendingEmergencyAdmissionVo.getAdmissionStatus()==null)
					pendingEmergencyAdmissionVo.setAdmissionStatus(EmergencyAdmissionStatus.DTA );
				pendingEmergencyAdmissionVo.setDTADateTime(attendance.getAdmitDateTime());
				pendingEmergencyAdmissionVo.setReasonForAdmission(attendance.getReasonForAdmission());
				PEADomain = PendingEmergencyAdmissionVoAssembler.extractPendingEmergencyAdmission(factory, pendingEmergencyAdmissionVo);
			}
		}
		AEAttendance attDo = AneAttendanceVoAssembler.extractAEAttendance(factory, attendance);
		factory.save(attDo.getPasEvent());

		if ( ! bCancelDischarge)
		{
				PEADomain.setCurrentLocation(attDo.getPasEvent().getLocation());
			if(null!=attendance.getANEconclusionDateTime())
			{
				PEADomain.setConclusionDate(attendance.getANEconclusionDateTime().getJavaDate());
			}
			if(attendance.getBedTypeRequestedIsNotNull())
			{
				PEADomain.setBedTypeRequested(getDomLookup(attendance.getBedTypeRequested()));
			}
			Location loc=null;
			if(attendance.getCurrentLocation()!=null&&attendance.getCurrentLocation().getID_Location()!=null)
			{
				loc = (Location)factory.getDomainObject(Location.class, attendance.getCurrentLocation().getID_Location());
			}
			PEADomain.setCurrentLocation(loc);
			
			PEADomain.setPasEvent(attDo.getPasEvent());
			factory.save(PEADomain);
		}
		factory.save(attDo);
		
		return AneAttendanceVoAssembler.create(attDo);
	}

	public InpatientEpisodeVo getCurrentAdmissionRecord(PatientRefVo patient)
	{
		return InpatientEpisodeVoAssembler.create(getCurrentAdmission(patient));
	}

	public PasEventVo getPasEventByUnqIdx(PatientRefVo voPatientRef, String pasEventId)
	{
		if (voPatientRef == null || voPatientRef.getID_Patient() == null)
			throw new CodingRuntimeException("Mandatory Argument: Patient");

		if (pasEventId == null)
			throw new CodingRuntimeException("Mandatory Argument: Pas Contact No");

		DomainFactory factory = getDomainFactory();
		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatientRef.getID_Patient().intValue());
		PASEvent domPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, pasEventId);
		
		return PasEventVoAssembler.create(domPas);
		
		
	}

	public PasEventVo getPasEvent(PASEventRefVo voPasEventRef) 
	{
		if (voPasEventRef == null)
			throw new CodingRuntimeException("Mandatory Argument: Pas Event");
		
		DomainFactory factory = getDomainFactory();
		PASEvent domPas = (PASEvent) factory.getDomainObject(PASEvent.class, voPasEventRef.getID_PASEvent());
		return PasEventVoAssembler.create(domPas);
		
	}

/**
 * 	Populates as many of the PasEvent fields as it can from the PasContact
 *  CareContext,IsVip,ReferringGP,SourceOfReferral are left as null 
 *  EventDateTime depends on whether we are listing inpatients or outpatients and
 *  is populated external to this method.
 */
	public PasEventVo createPasEvent(DateTime eventDateTime, PatientRefVo voRefPatient, PasContactVo voPasContact) throws StaleObjectException, UniqueKeyViolationException   
	{
		PasEventVo voPasEvent = new PasEventVo();

		voPasEvent.setEventDateTime(eventDateTime);
		
		if (voPasContact.getConsultant() != null)
		{
			MedicWithMappingsLiteVo medLite = new MedicWithMappingsLiteVo(voPasContact.getConsultant().getID_Hcp(), voPasContact.getConsultant().getVersion_Hcp());
			medLite.setMos(voPasContact.getConsultant().getMos());
			voPasEvent.setConsultant(medLite);			
		}
		voPasEvent.setLocation(voPasContact.getLocation());
		voPasEvent.setSpecialty(voPasContact.getSpecialty());
		voPasEvent.setPasEventId(voPasContact.getContactNumber());
		//		voPasEvent.setPatient(voPasContact.getPatient());
		GpLiteToPracticeLiteVo voGpLiteToPracList = synchronizeGPPracticeDetails(voPasContact.getGPCode());
		if (voGpLiteToPracList != null)
		{
			voPasEvent.setReferringGP(voGpLiteToPracList.getGp());
			if (voGpLiteToPracList.getPracticeIsNotNull() && voGpLiteToPracList.getPractice().getSurgeriesIsNotNull() && voGpLiteToPracList.getPractice().getSurgeries().size() > 0)
				voPasEvent.setReferringGpSurgery(voGpLiteToPracList.getPractice().getSurgeries().get(0));
		}
		
		if (voPasContact.getAppointmentDateTimeIsNotNull())
			voPasEvent.setEventType(PasEventType.OUTPATIENT);
		else if (voPasContact.getDischargeDateTimeIsNotNull())
			voPasEvent.setEventType(PasEventType.INPATIENT);

		DomainFactory factory = getDomainFactory();
		PASEvent domPasEvent = PasEventVoAssembler.extractPASEvent(factory, voPasEvent);

		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voRefPatient.getID_Patient().intValue()); 
		domPasEvent.setPatient(domPatient);
		try 
		{
			factory.save(domPasEvent);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException(e.getMessage());
		}
		
		return PasEventVoAssembler.create(domPasEvent);
	}
	
	public GpLiteToPracticeLiteVo synchronizeGPPracticeDetails(String strGPCode)  throws StaleObjectException, UniqueKeyViolationException
	{
		Demographics impl = (Demographics) getDomainImpl(DemographicsImpl.class);
		return impl.synchronizeGPPracticeDetails(strGPCode);
	}
	
	public AneAttendanceVo getAnEAttendance(PasEventVo pasEventVo)
	{
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from AEAttendance o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return AneAttendanceVoAssembler.create((AEAttendance) lst.get(0));
		}
		
		return null;
	}

	@SuppressWarnings("unchecked")
	public PendingEmergencyAdmissionVo getPendingEmergencyAdmission(
			PasEventVo pasEventVo) {
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from PendingEmergencyAdmission o where o.pasEvent.id = :pasEvent";
			List lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return PendingEmergencyAdmissionVoAssembler.create((PendingEmergencyAdmission) lst.get(0));
		}
		
		return null;
	}

	public PendingEmergencyAdmissionVo recordPendingEmergencyAdmission(
			PasEventVo pasEventVo,
			PendingEmergencyAdmissionVo pendingEmergencyAdmission) throws StaleObjectException{
		if (!pasEventVo.isValidated())
		{
			throw new DomainRuntimeException("Pas Event VO has not been validated!");
		}
//		pendingEmergencyAdmission.setAdmissionStatus(EmergencyAdmissionStatus.DTA );
		DomainFactory factory = getDomainFactory();				
		PendingEmergencyAdmission PEADomain = PendingEmergencyAdmissionVoAssembler.extractPendingEmergencyAdmission(factory, pendingEmergencyAdmission);
		PASEvent pasEventDomain=PasEventVoAssembler.extractPASEvent(factory, pasEventVo);
		factory.save(pasEventDomain);
		factory.save(PEADomain);
		return PendingEmergencyAdmissionVoAssembler.create(PEADomain);
	}

	
	public PendingElectiveAdmissionHl7Vo getPendingElectiveAdmission(
			PasEventVo pasEventVo) {
	DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from PendingElectiveAdmission o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return PendingElectiveAdmissionHl7VoAssembler.create((PendingElectiveAdmission) lst.get(0));
		}
		
		return null;
		}

//	public PendingElectiveAdmissionHl7Vo getPendingElectiveAdmission(
//			PasEventVo pasEventVo)
//	{
//		DomainFactory factory = getDomainFactory();
//		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
//		if (domEvent != null)
//		{
//			PendingElectiveAdmission domPending = getDomPendingElectiveAdmission(domEvent);
//			if (domPending!=null)
//			{
//				return PendingElectiveAdmissionHl7VoAssembler.create(domPending);
//			}
//		}
//		return null;
//	}
	
	
	private PendingElectiveAdmission getDomPendingElectiveAdmission(Patient domPatient,
			PASEvent domEvent) 
	{
		if (domPatient==null||null==domEvent||null==domEvent.getPasEventId())
			return null;
		DomainFactory factory = getDomainFactory();
		if (domEvent!=null)
		{
			String hql = " from PendingElectiveAdmission o where o.pasEvent.patient = :pat and o.pasEvent.pasEventId = :pasEvent";
			
			List<?> lst = factory.find(hql, new String[]{"pat","pasEvent"}, new Object[]{domPatient,domEvent.getPasEventId()});
			if (lst != null && lst.size() == 1)
				return (PendingElectiveAdmission) lst.get(0);
		}
		return null;
	}

	public PendingElectiveAdmissionHl7Vo recordPendingElectiveAdmission(
			PasEventVo pasEventVo,
			PendingElectiveAdmissionHl7Vo pendingElectiveAdmissionVo)
			throws StaleObjectException {
		if(!pasEventVo.isValidated())
		{
			throw new DomainRuntimeException("Pas Event VO has not been validated!");
		}
		if (null ==pendingElectiveAdmissionVo)
		{
			throw new DomainRuntimeException("Pending Elective Admission cannot be null");
		}

		if (!pendingElectiveAdmissionVo.isValidated())
		{
			throw new DomainRuntimeException("Pending Elective Admission Admit VO has not been validated!");
		}
		DomainFactory factory = getDomainFactory();
		
		PendingElectiveAdmission peaDomain = PendingElectiveAdmissionHl7VoAssembler.extractPendingElectiveAdmission(factory, pendingElectiveAdmissionVo);
		if(null!=pendingElectiveAdmissionVo.getProcedures())
		{
			for (String procCode : pendingElectiveAdmissionVo.getProcedures()) 
			{
				Procedure proc = getProcedureFromTaxonomyMap(procCode,TaxonomyType.OPCS4);
				if(proc!=null)
					peaDomain.getProcedures().add(proc);
			}
		}
		
		factory.save(peaDomain);
		return PendingElectiveAdmissionHl7VoAssembler.create(peaDomain);
	}

	private Procedure getProcedureFromTaxonomyMap(String procedureCode,TaxonomyType type)
	{
	if(procedureCode==null || type==null)
		return null;
	DomainFactory factory = getDomainFactory();
	String hql = " from Procedure p join p.taxonomyMap t where t.taxonomyCode = :taxCode and t.taxonomyName = :type and p.isActive = TRUE";
	List<?> lst = factory.find(hql,new String[]{"taxCode","type"},new Object[]{procedureCode,getDomLookup(type)});
	if (lst!=null &&lst.size() ==1)
		return (Procedure)lst.get(0);
	else
		return null;
	}

	//WDEV-10231
	public CareContextInterfaceVo getCareContextByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getCareContextByPasEvent");
		
		CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + pasEvent.getID_PASEvent());
		return CareContextInterfaceVoAssembler.create(doCareContext);
	}

	//	WDEV-13307
	public InpatientEpisodeVo readmitPatient(PatientShort patVo, InpatientEpisodeVo episVo) throws StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new CodingRuntimeException("Patient VO has not been validated!");
		}
		if (!episVo.isValidated())
		{
			throw new CodingRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new CodingRuntimeException("Internal Patient ID must be valued.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		ims.core.patient.domain.objects.Patient domPatient =  (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		PASEvent domTCIPas=null;
		if (episVo!=null&&episVo.getPreAdmitNumber()!=null)
			domTCIPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPreAdmitNumber());
		
		PendingElectiveAdmission domPEA =  getDomPendingElectiveAdmission(domPatient,domTCIPas);
		if(null!=domPEA)
		{
			domPEA.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
			factory.save(domPEA);
		}
		
		InpatientEpisode ipDo = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, episVo);
		if (ipDo!=null)
		{
			WardStay ws = new WardStay();
			ws.setTransferDateTime(ipDo.getAdmissionDateTime());
			if (ipDo.getPasEvent()!=null)
				ws.setWard(ipDo.getPasEvent().getLocation());
			ws.setWardType(ipDo.getWardType());
		
			if(ipDo.getPasEvent()!=null&&ipDo.getPasEvent().getConsultant()!=null)
			{
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(ipDo.getPasEvent().getConsultant());
				cs.setTransferDateTime(ipDo.getAdmissionDateTime());
				cs.setSpecialty(ipDo.getPasEvent().getSpecialty());
				
				ipDo.getConsultantStays().add(cs);
			}
			
			ipDo.getWardStays().add(ws);
		}
		factory.save(ipDo);
		
		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(ipDo,episVo, null);
		factory.save(ad);
		
		domPatient.setWard(ipDo.getPasEvent().getLocation());
		// WDEV-17867 - Set Current Responsible Clinician to Patient record
		domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
		factory.save(domPatient);
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}
	
	
	/**
	 * WDEV-16240
	 * createDementiaRecordIfRequired - this method works through the business logic to determine whether a new dementia record is required.
	 * If one is needed, the createDementiaRecord method is called and a new record is created.
	 * for the current patient
	 * @param factory
	 * @param adt
	 * @param dementiaConfig
	 * @return void
	 * @throws StaleObjectException 
	 */
	public void createDementiaRecordIfRequired(DomainFactory factory, AdmissionDetail adt) throws StaleObjectException //WDEV-18742
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;

		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		if (dementiaConfig == null)
			return;

		// If the method of admission is not in the configured list of those required, to not create the record
		if (adt.getMethodOfAdmission() == null || !dementiaConfig.isMethodOfAdmissionListed(adt.getMethodOfAdmission()))
		{
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.INFORMATION, "Method of Admission not supplied or not in the list of configured values (ADM:" + adt.getId() + ")"); 
			return;
		}
		
		boolean newRecordRequired=false;
		boolean withInFAIRPeriod=false;//WDEV-18700
		
		// 1. If patient age below threshold, do not proceed
		int patientAge = calculateAge(adt.getPasEvent().getPatient(), adt.getAdmissionDateTime());
		if (patientAge < dementiaConfig.getAge())
			newRecordRequired= false;
		
		// 2. Does a Dementia record exist for this patient - we will not include 'Excluded', STEP_ONE_FIND_OUTSTANDING or STEP_TWO_ASSESS_INVESTIGATE_OUTSTANDING dementia records
		String hql = " from Dementia d where d.patient = :patient and d.currentWorklistStatus.status.id not in (:excluded, :step1, :step2, :recently_completed, :recently_referred) and (d.isRIE is null or d.isRIE = false) order by d.dischargeDateTime desc";
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(adt.getPasEvent().getPatient());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.EXCLUDED.getID());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.STEP_ONE_FIND_OUTSTANDING.getID());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.STEP_TWO_ASSESS_INVESTIGATE_OUTSTANDING.getID());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_COMPLETED.getID());//WDEV-18700
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_REFERRED.getID());//WDEV-18700
		labels.add("patient");
		labels.add("excluded");
		labels.add("step1");
		labels.add("step2");
		labels.add("recently_completed");//WDEV-18700
		labels.add("recently_referred");//WDEV-18700
		List lst = factory.find(hql, labels, values);
		// If no records exist, we want to create a new one
		if ((lst == null || lst.size() == 0) && patientAge >= dementiaConfig.getAge())
			newRecordRequired= true;   
		
		// Take the first Dementia record returned in the list and use this to determine factors below
		Dementia prevDementia=null;
		if (lst.size() > 0)
		{
			prevDementia = (Dementia) lst.get(0);
		
			// If the difference between the last dischargeDateTime and this admissionDateTime is greater than excludeFairPeriod, we want a new record
			int days=0;
			if (prevDementia.getDischargeDateTime() != null)
				days = Days.daysBetween(new org.joda.time.DateTime(prevDementia.getDischargeDateTime()).toDateMidnight() , new org.joda.time.DateTime(adt.getAdmissionDateTime()).toDateMidnight()).getDays();
			else
			{
				// 	DischargeDateTime is null, so use admission details and log this
				days = Days.daysBetween(new org.joda.time.DateTime(prevDementia.getAdmissionDateTime()).toDateMidnight() , new org.joda.time.DateTime(adt.getAdmissionDateTime()).toDateMidnight()).getDays();
				createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DischargeDateTime is null for the previous dementia record, using AdmissionDateTime to calculate days since last fair process (" + prevDementia.getId() + ")");
			}
			if (days >= dementiaConfig.getExcludeFAIRPeriod())
				newRecordRequired= true;

			// If within the fair period, but the previous record has dementia confirmed or the AMTSThresholdScore is less than configured value
			if ((prevDementia.isDementiaConfirmed() != null && prevDementia.isDementiaConfirmed() == true) || (prevDementia.getAMTSScore() != null && prevDementia.getAMTSScore() < dementiaConfig.getAMTSThresholdScore()))
				newRecordRequired= true;
			
			//WDEV-18700
			if (days <= dementiaConfig.getExcludeFAIRPeriod() && prevDementia!=null &&  !Boolean.TRUE.equals(prevDementia.isDementiaConfirmed()))
			{
				newRecordRequired=true;
				withInFAIRPeriod=true;
			}

		}

		if (newRecordRequired)
			createDementiaRecord(factory, prevDementia, adt, patientAge, dementiaConfig.getStepOnePeriod(),withInFAIRPeriod);//WDEV-18700
		
	}


	private DementiaConfiguration getDementiaConfigRecord(DomainFactory factory) 
	{
		// Get the DementiaConfiguration record
		List cfgLst = factory.find(" from DementiaConfiguration dc where dc.isRIE is null or dc.isRIE = false");
		if (cfgLst == null || cfgLst.size() == 0)
		{
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Dementia Configuration record cannot be found - processing cannot continue");
			return null;
		}
		return (DementiaConfiguration) cfgLst.get(0);
	}
	
	/**
	 * WDEV-16240
	 * Create Dementia Record - creates the Dementia record based on values from AdmissionDetail and the previous dementia record for the patient
	 * @param factory
	 * @param lastDementiaRecord - previous dementia record for the patient
	 * @param adt - Admission Detail record to be associated with this new Dementia record
	 * @param age - Patients age
	 * @param breachHours - the number of hours following AdmissionDateTime in which this task would have breached
	 * @param withInFAIRPeriod 
	 * @throws StaleObjectException 
	 */
	private void createDementiaRecord(DomainFactory factory, Dementia lastDementiaRecord, AdmissionDetail adt, int age, int breachHours, boolean withInFAIRPeriod) throws StaleObjectException //WDEV-18700
	{
		AuthoringInformation auth = new AuthoringInformation();
		auth.setAuthoringDateTime(new Date());

		Dementia domDem = new Dementia();
		DementiaWorklistStatus stat = new DementiaWorklistStatus();
		
		stat.setAuthoringInformation(auth);
		stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.STEP_ONE_FIND_OUTSTANDING));
		
		domDem.setAdmissionDateTime(adt.getAdmissionDateTime());
		domDem.setAdmissionDetail(adt);
		domDem.setAgeOnAdmission(age);
		domDem.setBreachDateTime(calculateBreachDate(adt.getAdmissionDateTime(), breachHours));
		domDem.setPatient(adt.getPasEvent().getPatient());
		domDem.setCurrentWorklistStatus(stat);
		domDem.getHistoricalWorklistStatus().add(stat);
		//wdev-18784
		if( domDem.getPatient() != null )
		{
			domDem.getPatient().setDementiaWorklistStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.STEP_ONE_FIND_OUTSTANDING));
			domDem.getPatient().setDementiaBreachDateTime(domDem.getBreachDateTime());
		}
		//--------

		// If the previous Dementia Record as confirmedDementia, then this status needs to be set to complete
		if (lastDementiaRecord != null && lastDementiaRecord.isDementiaConfirmed()!= null && lastDementiaRecord.isDementiaConfirmed() == true)
		{
			stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.COMPLETED));
			domDem.setDementiaConfirmed(true);
			domDem.setBreachDateTime(null);
			//wdev-18784
			if( domDem.getPatient() != null )
			{
				domDem.getPatient().setDementiaWorklistStatus(null);
				domDem.getPatient().setDementiaBreachDateTime(null);
			}
			//--------
		}
		//WDEV-18700
		else if (lastDementiaRecord != null && !Boolean.TRUE.equals(lastDementiaRecord.isDementiaConfirmed()) && withInFAIRPeriod && lastDementiaRecord.getCurrentWorklistStatus()!=null && ( getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.COMPLETED).equals(lastDementiaRecord.getCurrentWorklistStatus().getStatus()) || getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.FOR_REFERRAL).equals(lastDementiaRecord.getCurrentWorklistStatus().getStatus())))
		{
			stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.COMPLETED).equals(lastDementiaRecord.getCurrentWorklistStatus().getStatus()) ? getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_COMPLETED) : getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_REFERRED) );
			
			domDem.setDementiaConfirmed(lastDementiaRecord.isDementiaConfirmed());
			domDem.setBreachDateTime(null);
			if( domDem.getPatient() != null )
			{
				domDem.getPatient().setDementiaWorklistStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.COMPLETED).equals(lastDementiaRecord.getCurrentWorklistStatus().getStatus()) ? getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_COMPLETED) : getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.RECENTLY_REFERRED) );
				domDem.getPatient().setDementiaBreachDateTime(null);
			}
		}
		
		factory.save(domDem);
	}
	
	/**
	 * WDEV-16240
	 * updateDementiaRecordForDischarge - depending on values in the discharge details, the DementiaRecord may need to be updated
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 * @throws ForeignKeyViolationException 
	 */
	public void updateDementiaRecordForDischarge(DomainFactory factory, AdmissionDetail doAdmissionDetail, DischargedEpisode dischDo) throws StaleObjectException, ForeignKeyViolationException //WDEV-18742
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// If AdmissionDetail is null, try to get it here
		if (doAdmissionDetail == null)
		{
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + dischDo.getPasEvent().getId());
			if(admList != null && admList.size() > 0)
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
		}
		
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission  and d.isRIE is null or d.isRIE = false", labels, values); 
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		// This could be an update message i.e. an A08, if it is we only want to continue if the dischargedatetime has been modified
		if (domDem.getDischargeDateTime() != null && domDem.getDischargeDateTime().equals(dischDo.getDischargeDateTime()))
			return;
		
		domDem.setDischargeDateTime(dischDo.getDischargeDateTime());
				
		// Get the Dementia Configuration record
		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		
		if (dementiaConfig == null)
			return;
		
		// We need to check if this is an early discharge.  If it is, we will set the status of this dementia record to excluded - as long as not already excluded!
		int hours = Hours.hoursBetween(new org.joda.time.DateTime(domDem.getAdmissionDateTime()) , new org.joda.time.DateTime(domDem.getDischargeDateTime())).getHours();
		if (hours < dementiaConfig.getStepOnePeriod() && (domDem.getCurrentWorklistStatus() == null || domDem.getCurrentWorklistStatus().getReasonForExclusion() == null ||
				(domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() != ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())))
		{
			DementiaWorklistStatus stat = new DementiaWorklistStatus();
			AuthoringInformation auth = new AuthoringInformation();
			auth.setAuthoringDateTime(new Date());
			stat.setAuthoringInformation(auth);
			stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.EXCLUDED));
			stat.setReasonForExclusion(getDomLookup(ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE));
			domDem.setCurrentWorklistStatus(stat);
			domDem.setIsExcludedFromWorklist(true);
			domDem.getHistoricalWorklistStatus().add(stat);
		
		}
		
		// If this is an update, and the current status indicates early discharge and now it is no longer an early discharge
		// we need to remove the excluded status from the list and revert back to the original status point
		if (hours >= dementiaConfig.getStepOnePeriod() && domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() == ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())
		{
			DementiaWorklistStatus stat = domDem.getCurrentWorklistStatus();
			domDem.getHistoricalWorklistStatus().remove(domDem.getHistoricalWorklistStatus().size()-1); // Remove the last record
			domDem.setCurrentWorklistStatus((DementiaWorklistStatus) domDem.getHistoricalWorklistStatus().get(domDem.getHistoricalWorklistStatus().size()-1));
			factory.delete(stat);
			domDem.setIsExcludedFromWorklist(false);
		}
		
		factory.save(domDem);

	}
	

	/**
	 * WDEV-16240
	 * updateDementiaRecordForCancelDischarge - As this is a cancel discharge, we have to clear out discharge date and possibly remove excluded status records
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 * @throws ForeignKeyViolationException 
	 */
	private void updateDementiaRecordForCancelDischarge(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException, ForeignKeyViolationException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission and (d.isRIE is null or d.isRIE = false) ", labels, values);
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		domDem.setDischargeDateTime(null);
		// If the current status is excluded, we want to remove this
		if (domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() == ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())
		{
			DementiaWorklistStatus stat = domDem.getCurrentWorklistStatus();
			domDem.getHistoricalWorklistStatus().remove(domDem.getHistoricalWorklistStatus().size()-1); // Remove the last record
			domDem.setCurrentWorklistStatus((DementiaWorklistStatus) domDem.getHistoricalWorklistStatus().get(domDem.getHistoricalWorklistStatus().size()-1));
			factory.delete(stat);
			domDem.setIsExcludedFromWorklist(false);
		}
		
		factory.save(domDem);

	}

	/**
	 * WDEV-16240
	 * updateDementiaRecordForInpatient - update Dementia record if specific inpatient details modified
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 */
	private void updateDementiaRecordForInpatient(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission and (d.isRIE is null or d.isRIE = false) ", labels, values);
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		// We only want to update the Dementia record if the admission datetime has been modified
		if (domDem.getAdmissionDateTime() != null && domDem.getAdmissionDateTime().equals(doAdmissionDetail.getAdmissionDateTime()))
			return;

		// Get the Dementia Configuration record
		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		if (dementiaConfig == null)
			return;
		
		domDem.setAdmissionDateTime(doAdmissionDetail.getAdmissionDateTime());
		domDem.setBreachDateTime(calculateBreachDate(doAdmissionDetail.getAdmissionDateTime(), dementiaConfig.getStepOnePeriod()));
		domDem.setAgeOnAdmission(calculateAge(doAdmissionDetail.getPasEvent().getPatient(), doAdmissionDetail.getAdmissionDateTime()));
		
		//WDEV-22326 
		if (domDem.getCurrentWorklistStatus() != null && domDem.getCurrentWorklistStatus().getAuthoringInformation() != null)
			domDem.getCurrentWorklistStatus().getAuthoringInformation().setAuthoringDateTime(doAdmissionDetail.getAdmissionDateTime());
		
		domDem.getPatient().setDementiaBreachDateTime(calculateBreachDate(doAdmissionDetail.getAdmissionDateTime(), dementiaConfig.getStepOnePeriod()));
		//WDEV-22326  -- end 
		
		factory.save(domDem);
	}

	/**
	 * WDEV-16240 rieDementiaRecords
	 * When we get a cancelAdmission message in, we need to RIE all Dementia records that have been instantiated for this admission
	 * as they are no longer relevant
	 * @param factory
	 * @param peDo
	 * @throws StaleObjectException 
	 */
	private void rieDementiaRecords(DomainFactory factory, PASEvent peDo) throws StaleObjectException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		List demList = factory.find("from Dementia d where (d.isRIE is null or d.isRIE = false) and d.admissionDetail.pasEvent.id = " + peDo.getId());
		if (demList == null || demList.size() == 0)
			return;
		
		Dementia domDementia = (Dementia) demList.get(0);
	
		DementiaFind find = domDementia.getStepOneFind();
		if (find != null)
		{
			factory.markAsRie(DementiaFind.class,find.getId(), null, peDo.getPatient().getId(),null, null, "DementiaFind record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaFind record marked as RIE as Admission record cancelled via HL7 (" + find.getId() + ")");
		}

		DementiaAssessAndInvestigate ass = domDementia.getStepTwoAssess();
		if (ass != null)
		{
			factory.markAsRie(DementiaAssessAndInvestigate.class,ass.getId(), null, peDo.getPatient().getId(),null, null, "DementiaAssessAndInvestigate record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaAssessAndInvestigate record marked as RIE as Admission record cancelled via HL7 (" + ass.getId() + ")");
		}
		
		for (int i=0; i<domDementia.getFollowUpAssessments().size(); i++)
		{
			DementiaAssessAndInvestigate assFollowup = (DementiaAssessAndInvestigate) domDementia.getFollowUpAssessments().get(i);
			factory.markAsRie(DementiaAssessAndInvestigate.class, assFollowup.getId(), null, peDo.getPatient().getId(),null, null, "DementiaAssessAndInvestigateFollowup record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaAssessAndInvestigateFollowup record marked as RIE as Admission record cancelled via HL7 (" + assFollowup.getId() + ")");
		}

		factory.markAsRie(Dementia.class,domDementia.getId(), null, peDo.getPatient().getId(),null, null, "Dementia record marked as RIE as Admission record cancelled via HL7");
		createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Dementia record marked as RIE as Admission record cancelled via HL7 (" + domDementia.getId() + ")");
				
	}
	
	/**
	 * WDEV-16240
	 * calculateBreachDate - add the breachHours to the admissionDateTime to get the breachDateTime
	 * @param admissionDateTime
	 * @param breachHours
	 * @return breachDateTime
	 */
	private Date calculateBreachDate(Date admissionDateTime, int breachHours) 
	{
		if (admissionDateTime == null)
			return null;
		
		 Calendar cal = Calendar.getInstance(); 
		 cal.setTime(admissionDateTime); 
		 cal.add(Calendar.HOUR_OF_DAY, breachHours); 
		 return cal.getTime(); // returns new date object
	}


	public Integer calculateAge(Patient domPatient, Date toDate)
	{
		if (domPatient != null && domPatient.getDob() != null && toDate != null)
		{		
			int patAge = new ims.framework.utils.Age(new PartialDate(domPatient.getDob()), new ims.framework.utils.Date(toDate)).getYears();
			return patAge;
		}
		// Exception null patient or no dob
		super.createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Patient Age cannot be calculated due to null date of birth or Admission DateTime");
		return -1;
	}

// new methods for WDEV-17133
	public ifEDAttendanceVo getEDAttendanceDetails(IHL7OutboundMessageHandler attendanceRef)
	{
		if (attendanceRef instanceof EDAttendanceFeedVo)
		{
			EDAttendanceFeedVo feedVo=(EDAttendanceFeedVo)attendanceRef;
			DomainFactory factory = getDomainFactory();
			String hql = "select queue.attendance from EdAttendanceMessageQueue as queue where queue.id=:id";
			EmergencyAttendance attendance =  (EmergencyAttendance)factory.findFirst(hql,new String[]{"id"},new Object[]{feedVo.getBoId()});
			if (attendance!=null&&attendance.getIsRIE()!=null&&attendance.getIsRIE())
			{
				attendance.setIncludeRecord(true);
			}
		return ifEDAttendanceVoAssembler.create(attendance);
	}
	else 
	{
		return null;
	}
	}


	public PrivateInsuranceCompanyVo getPrivateInsuranceCompany(String extId,TaxonomyType taxonomyType)
	{
		if (extId == null || taxonomyType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from PrivateInsuranceCompany company " +
		" join company.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List<?> companyList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (companyList != null && companyList.size() > 0)
		{
			PrivateInsuranceCompany company = (PrivateInsuranceCompany)companyList.get(0);
			return PrivateInsuranceCompanyVoAssembler.create(company);
		}
		return null;
		}


	//http://jira/browse/WDEV-17135
	public ifInpatientADTVo getPartialAdmissionDetails(InPatientADTMessageQueueRefVo queueItem)
	{
		DomainFactory factory = getDomainFactory();
		InPatientADTMessageQueue queueItemDom = (InPatientADTMessageQueue)factory.getDomainObject(InPatientADTMessageQueue.class,queueItem.getBoId());
		return ifInpatientADTVoAssembler.create(queueItemDom);
	}


	public void cancelPartialAdmission(String partialAdmissionId)throws DomainInterfaceException, StaleObjectException //WDEV-17135
	{
		if (partialAdmissionId==null)
			throw new DomainInterfaceException("Partial Admission ID not found in PV1-50");
		DomainFactory factory = getDomainFactory();
		try
		{
			int id=Integer.parseInt(partialAdmissionId);
			EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
			partialAdmission.setAllocatedWard(null);
			partialAdmission.setAllocatedDateTime(null);
			factory.save(partialAdmission);
			return;
		}
		catch (NumberFormatException e)
		{
			if(partialAdmissionId!=null)
			{
				throw new DomainInterfaceException("Failed to parse Partial Admission ID "+partialAdmissionId);
			}
			else
			{
				throw new DomainInterfaceException("Failed to read Partial Admission ID.");
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			throw new DomainInterfaceException(e.getMessage());
		}
	}


	public ifOutBookingAppointmentVo getBookingAppointmentDetails(AppointmentMessageQueueVo apptQueueItem)
	{
		if(apptQueueItem==null ||apptQueueItem.getAppointment()==null)
			return null;
		Booking_Appointment firstAppt=null;
		ifOutBookingAppointmentVo returnVal = null;
		int taxType = apptQueueItem.getProviderSystem().getCodeSystem().getId();
		String extSystem = apptQueueItem.getProviderSystem().getCodeSystem().getText();
		DomainFactory factory = getDomainFactory();
		
		Sch_Booking sch_Booking = (Sch_Booking)factory.getDomainObject(Sch_Booking.class,apptQueueItem.getAppointment().getBoId());
		
		// http://jira/browse/WDEV-22435
//		if(sch_Booking!=null)
//		{
//			firstAppt = sch_Booking.getFirstAppointment();

		/*
		 * Use AppointmentMessageQueueVo.apptdetail to assemble Booking_Appointment (firstAppt) rather than
		 * AppointmentMessageQueueVo.appointment. This allows for the correct processing of linked appointments.
		 * Still need Sch_Booking (sch_Booking) as this is used to populate UBRN, MaximsApptId and ExternalID
		 * fields in ifOutBookingAppointmentVo (returnVal)
		 */
		
		firstAppt = (Booking_Appointment)factory.getDomainObject(Booking_Appointment.class, apptQueueItem.getApptDetail().getBoId());
		
		if (firstAppt != null) //WDEV-22435
			
		{
			returnVal= ifOutBookingAppointmentVoAssembler.create(firstAppt);

			returnVal.setUBRN(sch_Booking.getUBRN());
			//WDEV-22490
//			returnVal.setMaximsApptId(sch_Booking.getId().toString());
			returnVal.setMaximsApptId(firstAppt.getId().toString()); //WDEV-22490
//			// http://jira/browse/WDEV-20658
			returnVal.setExternalID(sch_Booking.getExternalID()); //WDEV-20658

			
			if(firstAppt!=null)
			{
				returnVal.setApptDate(new ims.framework.utils.Date(firstAppt.getAppointmentDate()));
				returnVal.setApptStart(firstAppt.getApptStartTime());
				returnVal.setApptEnd(firstAppt.getApptEndTime());
				if(firstAppt.getPriority()!=null)
				{
					returnVal.setPriority(getLookupService().getRemoteLookup(firstAppt.getPriority().getId(),extSystem));
				}
				if(firstAppt.getSessionSlot()!=null&&returnVal.getUBRN()!=null)
				{
					returnVal.setUSRN(firstAppt.getSessionSlot().getUSRNfromUBRN(returnVal.getUBRN()));
					DirectoryofService dos = firstAppt.getSessionSlot().getDOSfromUBRN(returnVal.getUBRN());
					returnVal.setDoSName(dos.getDoSName());
					returnVal.setDoSId(dos.getDoSId());
				}
				if(firstAppt.getSessionSlot()!=null //http://jira/browse/WDEV-19563 get from the slot if not in appointment
						&&returnVal.getPriority()==null
						&&firstAppt.getSessionSlot().getPriority()!=null)
				{
					returnVal.setPriority(getLookupService().getRemoteLookup(firstAppt.getSessionSlot().getPriority().getId(),extSystem));
				}
				if(firstAppt.getActivity()!=null)
				{
					returnVal.setActivityCode(firstAppt.getActivity().getExtCode(taxType));
				}
				if(firstAppt.getSession()!=null)
				{
					returnVal.setProfileName(firstAppt.getSession().getName());
					returnVal.setLocationCode(firstAppt.getSession().getSchLocation().getExtCode(taxType));
								
					OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
					returnVal.setFacilityCode(impl.getActiveHospitalCodeForLoc(firstAppt.getSession().getSchLocation(), apptQueueItem.getProviderSystem().getCodeSystem()));
					returnVal.setLocationName(firstAppt.getSession().getSchLocation().getName());
					returnVal.setLocationTypeCode(getLookupService().getRemoteLookup(firstAppt.getSession().getSchLocation().getType().getId(),extSystem));
				}
				
				if(returnVal.getMos()==null)
					returnVal.setMos(new MemberOfStaffShortVoCollection());

				if(firstAppt.getSessionSlot()!=null&&firstAppt.getSessionSlot().getSlotResp()!=null)
				{
					Hcp listOwner= firstAppt.getSessionSlot().getSlotResp().getHcp();
					MemberOfStaffShortVo mos= MemberOfStaffShortVoAssembler.create(listOwner.getMos());
					returnVal.getMos().add(mos);
				}
				if((returnVal.getMos()==null||returnVal.getMos().size()<1)&&firstAppt.getSession()!=null)
				{
					Set<Session_ListOwner> listOwners = firstAppt.getSession().getListOwners();
					for (Session_ListOwner owner : listOwners)
					{
						Hcp hcp=owner.getHcp();
						if(hcp!=null)
						{
							returnVal.getMos().add(MemberOfStaffShortVoAssembler.create(hcp.getMos()));
						}
						
					}
				}
				if(firstAppt.getSession()!=null
						&&firstAppt.getSession().getService()!=null)
				{
					returnVal.setServiceCode(firstAppt.getSession().getService().getExtCode(taxType));
				}
				
			}
			
 		}
		
		
		CatsReferral referral = (CatsReferral)factory.getDomainObject(CatsReferral.class,apptQueueItem.getReferral().getBoId());
		if(referral!=null&&referral.getReferralDetails()!=null)
		{
			Gp gp = referral.getReferralDetails().getGPName();
			returnVal.setGP(GpShortVoAssembler.create(gp));
			
			returnVal.setAhp(referral.getReferralDetails().getAlliedHealthProfName());
			
			if(referral.getReferralDetails().getPractice()!=null)
			{
				Address practiceAddress=referral.getReferralDetails().getPractice().getAddress();
				returnVal.setPracticeAddress(PersonAddressAssembler.create(practiceAddress));
				returnVal.setPracticeCode(referral.getReferralDetails().getPractice().getMappingValueOfType(getDomLookup(TaxonomyType.NAT_LOC_CODE)));
				List<CommunicationChannel> commChannellsDom = referral.getReferralDetails().getPractice().getCommChannels();
				if(commChannellsDom!=null)
				{
					for (CommunicationChannel communicationChannel : commChannellsDom)
					{
						if(communicationChannel.getChannelType().getId()==getDomLookup(ChannelType.WORK_PHONE).getId())
						{
							returnVal.setPracticeWorkNumber(CommChannelVoAssembler.create(communicationChannel));
							break;
						}
					}
				}
				
			}
		}
		
		//WDEV-19704 CatsReferral is used to create ADT^A05 for first appointment
		if(firstAppt != null && referral != null)
		{
			ifCatsReferralVo catsReferral = ifCatsReferralVoAssembler.create(referral);
			
			// urgency
			if(referral.getUrgency() != null)
			{
				Integer lookupId = referral.getUrgency().getId();
				ReferralUrgency referralUrgency = (ReferralUrgency)getLookupService().getLookupInstance(ReferralUrgency.class, lookupId);
				if(referralUrgency != null)
					catsReferral.setUrgency(referralUrgency);
			}
	
			// cancerType
			if(referral.getCancerType() != null)
			{
				Integer lookupId = referral.getCancerType().getId();
				CancerType cancerType = (CancerType)getLookupService().getLookupInstance(CancerType.class, lookupId);
				if(cancerType != null)
					catsReferral.setCancerType(cancerType);
			}
			
			// RTTStatusNationalCode
			if(referral.getCurrentRTTStatus() != null
					&& referral.getCurrentRTTStatus().getRTTStatus() != null
					&& referral.getCurrentRTTStatus().getRTTStatus().getNationalCode() != null)
			{
				catsReferral.setRTTStatusNationalCode(referral.getCurrentRTTStatus().getRTTStatus().getNationalCode().toString());
			}

			// referrerType
			if(referral.getReferralDetails().getReferrerType() != null)
			{
				Integer lookupId = referral.getReferralDetails().getReferrerType().getId();
				SourceOfReferral sourceOfReferral = (SourceOfReferral)getLookupService().getLookupInstance(SourceOfReferral.class, lookupId);
				if(sourceOfReferral != null)
				{
					catsReferral.setReferrerType(sourceOfReferral);
				}				
			}

			// referringPracticeCCGCode
			if(referral.getReferralDetails() != null
					&& referral.getReferralDetails().getPractice() != null
					&& referral.getReferralDetails().getPractice().getPctCode() != null)
			{
				catsReferral.setReferringPracticeCCGCode(referral.getReferralDetails().getPractice().getPctCode());
			}

			if(catsReferral != null)
			{
				returnVal.setCatsReferral(catsReferral);
			}

			//WDEV-20069
			//responsibleHCP
			if(firstAppt.getSession() != null
					&& firstAppt.getSession().getResponsibleHCP() != null
					&& firstAppt.getSession().getResponsibleHCP().getMos() != null)
			{
				MemberOfStaff consultingDoctorDom = ((Booking_Appointment) firstAppt).getSession().getResponsibleHCP().getMos();
				MemberOfStaffShortVo consultingDoctorVo = MemberOfStaffShortVoAssembler.create(consultingDoctorDom);
				if(consultingDoctorVo != null)
					returnVal.setResponsibleHCP(consultingDoctorVo);
			}

			//slotResponsibility
			if(firstAppt.getSessionSlot() != null
					&& firstAppt.getSessionSlot().getSlotResp() != null
					&& firstAppt.getSessionSlot().getSlotResp().getHcp() != null
					&& firstAppt.getSessionSlot().getSlotResp().getHcp().getMos() != null)
			{
				MemberOfStaff attendingDoctorDom = ((Booking_Appointment) firstAppt).getSessionSlot().getSlotResp().getHcp().getMos();
				MemberOfStaffShortVo attendingDoctorVo = MemberOfStaffShortVoAssembler.create(attendingDoctorDom);
				if(attendingDoctorVo != null)
					returnVal.setSlotResponsibility(attendingDoctorVo);			
			} //WDEV-20069

			//WDEV-21244 
			if (firstAppt != null
					&& firstAppt.getSession() != null
					&& firstAppt.getSession().getListOwners() != null)
			{
				returnVal.setListOwners(ifSessionListOwnerVoAssembler.createifSessionListOwnerVoCollectionFromSession_ListOwner(firstAppt.getSession().getListOwners()));
			} //WDEV-21244
		}
		

		return returnVal;
	}


	//WDEV-19160 - RadioTherapy messages (SIU)
	public ifApptDetailsVo getRadiotherapyApptDetails(RadioTherapySchedQueueVo queueItem)
	{


		if(queueItem==null || queueItem.getAppointment()==null)
			return null;
		
		Appointment apptHeader = null;
		AppointmentDetail apptDetail = null;
		Profile apptProfile = null;
		ActivityGroup activityGroup = null;
		ifApptDetailsVo returnVal = null;
		InternalLocation internalLocation = null;

				
		DomainFactory factory = getDomainFactory();
		
		apptHeader = (Appointment) factory.getDomainObject(Appointment.class, queueItem.getAppointment().getBoId());		
		apptDetail = (AppointmentDetail) apptHeader.getApptDetail().get(queueItem.getAppointmentIDX());
		
		if (apptHeader != null && apptDetail != null)
		{

			returnVal= ifApptDetailsVoAssembler.create(apptDetail);

			if(apptDetail.getSession().getProfile_id()!=null)
			{
				apptProfile = (Profile)factory.getDomainObject(Profile.class, apptDetail.getSession().getProfile_id());
				//WDEV-19522
				//if(apptProfile.getName()!=null)
				if(apptProfile.getName()!=null && apptProfile.getLocation().getName()!=null)
				{
						returnVal.setProfileName(apptProfile.getName());
						returnVal.setLocationName(apptProfile.getLocation().getName());
				}
			}
			
			if(apptDetail.getSession().getActivityId()!=null && apptDetail.getSession().getGroup_id()!=null)
			{

				Integer groupIDValue = apptDetail.getSession().getGroup_id();
				Integer activityIDValue = apptDetail.getSession().getActivityId();
				
				String hql = "FROM SchedActivity AS sa WHERE sa.group.id = :groupID AND sa.activityId = :actID";
				SchedActivity schedAct = (SchedActivity)factory.findFirst(hql, 
						new String[]{"groupID","actID"}, 
						new Object[]{groupIDValue, activityIDValue});

				if(schedAct.getName()!=null)
				{
					returnVal.setActivityName(schedAct.getName());
				}

				activityGroup = (ActivityGroup)factory.getDomainObject(ActivityGroup.class, apptDetail.getSession().getGroup_id());
				if(activityGroup.getActivityGroupName()!=null)
				{	
					returnVal.setActivityGroupName(activityGroup.getActivityGroupName());
				}

			}
	
				
			// Need to recurse up Location.Parent to highest parent to obtain facilityName
			if(apptProfile.getLocation().getParent()!=null)
			{
				internalLocation = apptProfile.getLocation().getParent();

				while (internalLocation.getParent()!=null)
				{
					if(internalLocation.getName()!=null)
					{
						returnVal.setFacilityName(internalLocation.getName());
					}
					internalLocation = internalLocation.getParent();
				}
			}
			

			if(apptHeader.getTreatPlanActionId()!=null)
			{
				String hql = "SELECT t_ptp FROM PatTreatmentPlan AS t_ptp LEFT JOIN t_ptp.actions AS t_a WHERE (t_a.id = :ID)";
				PatTreatmentPlan patTreatmentPlan = (PatTreatmentPlan)factory.findFirst(hql,new String[]{"ID"},new Object[]{apptHeader.getTreatPlanActionId()});
				if(patTreatmentPlan!=null)
				{
					MemberOfStaff consultantMOSDom=((PatTreatmentPlan) patTreatmentPlan).getConsultant().getMos();
					MemberOfStaffShortVo consultantMos = MemberOfStaffShortVoAssembler.create(consultantMOSDom);
					if(consultantMos!=null)
						returnVal.setConsultantMos(consultantMos);
				}

			}
			
			
			if(apptDetail.getApptDate()!=null)
			{
				returnVal.setApptDate(new ims.framework.utils.Date(apptDetail.getApptDate()));
			}
			
			
			if(apptDetail.getStartTime()!=null)
			{
				returnVal.setApptStart(apptDetail.getStartTime());
				returnVal.setStartTime(new ims.framework.utils.Time(apptDetail.getStartTime()));
			}
			
			
			if(apptDetail.getEndTime()!=null)
			{
				returnVal.setApptEnd(apptDetail.getEndTime());
				returnVal.setEndTime(new ims.framework.utils.Time(apptDetail.getEndTime()));
			}
			
			
			if(apptDetail.getPriority()!=null)
			{
				 Priority priority = (Priority)getLookupService().getLookupInstance(Priority.class, apptDetail.getPriority());
				 if(priority!=null)
					 returnVal.setPriority(priority);
			}

			
			if(apptHeader.getHcpBooking()!=null)
			{
				MemberOfStaffShortVo mos= MemberOfStaffShortVoAssembler.create(apptHeader.getHcpBooking());
				if(mos!=null)
					returnVal.setMos(mos);
			}
			
			
			//WDEV-19522
//			if(apptDetail.getMachine().getName()!=null)
			if(apptDetail.getMachine()!=null && apptDetail.getMachine().getName()!=null)
			{
				returnVal.setMachineName(apptDetail.getMachine().getName());
			}
			
			
			if(apptDetail.getApptStatus()!=null)
			{
				Integer apptStatusId =  apptDetail.getApptStatus();
				AppointmentStatus appointmentStatus = (AppointmentStatus)getLookupService().getLookupInstance(AppointmentStatus.class, apptStatusId);
				if(appointmentStatus!=null)				 
					returnVal.setApptStatus(appointmentStatus); 
			}


			// Check if value of First Appointment ID (in header) differs from Appointment IDX in detail.
			// If it does, then this is not the first appointment
			if(apptHeader.getFirstApptId()!=null)
			{
				if(queueItem.getAppointmentIDX().equals(apptHeader.getFirstApptId()))
					returnVal.setFirstApptIndicator(ims.core.vo.lookups.YesNo.YES);				
			}
			
			if(apptHeader.getPatStat()!=null)
			{
				Integer lookupId =apptHeader.getPatStat();
				Status status = (Status)getLookupService().getLookupInstance(Status.class, lookupId);
				if(status!=null)
				{
					returnVal.setPatientStatus(status);
				}
			}
		
		
//		return returnVal;

		}
		
		return returnVal;
		
	}
	
	//WDEV-19481 Inpatient Episode
	public ifInpatientEpisodeVo getInpatientEpisodeDetails(InpatientEpisodeQueueVo queueItem)
	{
		
		if(queueItem==null)
			return null;

		ifInpatientEpisodeVo returnVal = null;
		
		PASEvent pasEvent = null;
		PendingElectiveAdmission pendingElectiveAdmission = null;
		AdmissionDetail admissionDetail = null;
		InpatientEpisode inpatientEpisode = null;
		WardStay currentWardStay = null;
		ConsultantStay currentConsultantStay = null;
		DischargedEpisode dischargedEpisode = null;
		PatientElectiveList patientElectiveList = null;
		
		DomainFactory factory = getDomainFactory();

		pasEvent = (PASEvent)factory.getDomainObject(PASEvent.class, queueItem.getPasEvent().getBoId());
		
		if(pasEvent!=null)
		{
			
			returnVal = ifInpatientEpisodeVoAssembler.create(pasEvent);

			admissionDetail = getCurrentAdmissionDetail(pasEvent);
			pendingElectiveAdmission = getPendingElectiveAdmission(pasEvent);

			//WDEV-22966
//			patientElectiveList = getPatientElectiveList(pasEvent.getPatient());
			if (admissionDetail != null)
			{
				try
				{
					patientElectiveList = getPatientElectiveListForAdmission(factory, admissionDetail);
				}
				catch (StaleObjectException e)
				{
					// TODO Auto-generated catch block
					//e.printStackTrace();
				}	
			} //WDEV-22966

			inpatientEpisode = getInpatientEpisode(pasEvent);
			if(inpatientEpisode != null) //No inpatient episode if patient has been discharged
			{
				currentWardStay = getCurrentWardStay(inpatientEpisode);
				currentConsultantStay = getCurrentConsultantStay(inpatientEpisode);
				
				//WDEV-22918
				if (inpatientEpisode.getSystemInformation().getLastUpdateDateTime() != null)
				{
					DateTime admissionEventDateTime = new DateTime(inpatientEpisode.getSystemInformation().getLastUpdateDateTime());
					returnVal.setAdmissionEventDateTime(admissionEventDateTime);
				} 
				else if (inpatientEpisode.getSystemInformation().getCreationDateTime() != null)
				{
					DateTime admissionEventDateTime = new DateTime(inpatientEpisode.getSystemInformation().getCreationDateTime());
					returnVal.setAdmissionEventDateTime(admissionEventDateTime);
				}//WDEV-22918
			}

			dischargedEpisode = getDischargedEpisode(pasEvent);
			if(dischargedEpisode != null)
			{
				currentWardStay = getCurrentWardStay(dischargedEpisode);
				currentConsultantStay = getCurrentConsultantStay(dischargedEpisode);
				
				//WDEV-22918
				if (dischargedEpisode.getSystemInformation().getLastUpdateDateTime() != null)
				{
					DateTime dischargeAdmissionDateTime = new DateTime(dischargedEpisode.getSystemInformation().getLastUpdateDateTime());
					returnVal.setDischargeEventDateTime(dischargeAdmissionDateTime);
				} 
				else if (dischargedEpisode.getSystemInformation().getCreationDateTime() != null)
				{
					DateTime dischargeAdmissionDateTime = new DateTime(dischargedEpisode.getSystemInformation().getCreationDateTime());
					returnVal.setDischargeEventDateTime(dischargeAdmissionDateTime);
				}//WDEV-22918
				
			}
			
			//WDEV-22918
			/*
			 * If there is no inpatientEpisode or dischargedEpisode, then assume that admission has been cancelled
			 * OR
			 * if the message type is A08
			 * Need to populate returnVal.setAdmissionEventDateTime with InpatientEpisodeADTMessageQueue SystemInformation
			 * This value is needed for:
			 *  - the A11 message (Cancel Admission)
			 *  - the A08 message (Update Admission)
			 */
			if ((inpatientEpisode == null && dischargedEpisode == null) 
					|| (MsgEventType.A08.equals(queueItem.getMsgType())))
			{
				if (queueItem.getSysInfo() != null)
				{
					if (queueItem.getSysInfo().getLastupdateDateTime() != null)
					{
						DateTime admissionEventDateTime = new DateTime(queueItem.getSysInfo().getLastupdateDateTime());
						returnVal.setAdmissionEventDateTime(admissionEventDateTime);
					} else if (queueItem.getSysInfo().getCreationDateTime() != null)
					{
						DateTime admissionEventDateTime = new DateTime(queueItem.getSysInfo().getCreationDateTime());
						returnVal.setAdmissionEventDateTime(admissionEventDateTime);
					}
				}
			} //WDEV-22918
			
			// PASEventId
			if(pasEvent.getPasEventId() != null 
					&& pasEvent.getPasEventId().length() > 0)
			{
				returnVal.setPasEventId(pasEvent.getPasEventId());
			}
			
			// Admitting Consultant? (Current Consultant?)
			if(pasEvent.getConsultant() != null)
			{				
				Medic consultantMOSDom=((PASEvent) pasEvent).getConsultant();
				MedicWithMappingsLiteVo consultantMos = MedicWithMappingsLiteVoAssembler.create(consultantMOSDom);
				if(consultantMos != null)
				{
					returnVal.setConsultant(consultantMos);
				}
			}

			// Specialty
			if(pasEvent.getSpecialty() != null)
			{
				Integer lookupId = pasEvent.getSpecialty().getId();
				Specialty specialty = (Specialty)getLookupService().getLookupInstance(Specialty.class, lookupId);
				if(specialty != null)
				{
					returnVal.setSpecialty(specialty);
				}
			}
			
			// sourceOfReferral
			if(pasEvent.getSourceOfReferral() != null)
			{
				Integer lookupId = pasEvent.getSourceOfReferral().getId();
				SourceOfReferral sourceOfReferral = (SourceOfReferral)getLookupService().getLookupInstance(SourceOfReferral.class, lookupId);
				if(sourceOfReferral != null)
				{
					returnVal.setSourceOfReferral(sourceOfReferral);
				}
			}
				
			// isVip
			if(pasEvent.isIsVip() != null)
			{
				returnVal.setIsVip(pasEvent.isIsVip());
			}
			
			// referringGP
			if(pasEvent.getReferringGP() != null)
			{
				Gp referringGPDom = ((PASEvent) pasEvent).getReferringGP();
				GpLiteVo referringGPMos = GpLiteVoAssembler.create(referringGPDom);
				if(referringGPMos!=null)
				{
					returnVal.setReferringGP(referringGPMos);
				}
			}
			
			// EventType
			returnVal.setEventType(PasEventType.INPATIENT);
			
			// pasEpisodeId
			
			// EpisodeFinancialClass
			if(pasEvent.getEpisodeFinancialClass() != null)
			{
				Integer lookupId = pasEvent.getEpisodeFinancialClass().getId();
				OrderCategory episodeFinancialClass = (OrderCategory)getLookupService().getLookupInstance(OrderCategory.class, lookupId);
				if(episodeFinancialClass != null)
				{
					returnVal.setEpisodeFinancialClass(episodeFinancialClass);
				}
			}
			
			// AttendingHCP
			if(pasEvent.getAttendingHCP() != null)
			{
				ims.core.vo.Hcp hcpVo = HcpAssembler.create(pasEvent.getAttendingHCP());
				if(hcpVo != null)
				{
					returnVal.setAttendingHCP(hcpVo);
				}
			}
			
			//pointOfCare
			
			//locationDescription
			// WDEV-20458
//			if(currentWardStay.getWard() != null
//					&& currentWardStay.getWard().getName() != null)
			if(currentWardStay != null
					&& currentWardStay.getWard() != null
					&& currentWardStay.getWard().getName() != null) //WDEV-20458
			{
				returnVal.setLocationDescription(currentWardStay.getWard().getName());
			}
					
			// bedNo
			if(inpatientEpisode != null
					&& inpatientEpisode.getBed() != null
					&& inpatientEpisode.getBed().getBedSpace() != null
					&& inpatientEpisode.getBed().getBedSpace().getBedNumber() != null)
			{
				returnVal.setBedNo(inpatientEpisode.getBed().getBedSpace().getBedNumber());	
			}
			
			// hospitalService - being handled by returnVal.setSpecialty
//			if(pasEvent.getSpecialty() != null)
//			{
//				Integer lookupId = pasEvent.getSpecialty().getId();
//				Specialty specialty = (Specialty)getLookupService().getLookupInstance(Specialty.class, lookupId);
//				if(specialty != null)
//				{
//					returnVal.setHospitalService(specialty.toString());
//				}
//			}

			// admitSource
			if(admissionDetail != null
					&& admissionDetail.getSourceOfAdmission() != null)
			{
				Integer lookupId = admissionDetail.getSourceOfAdmission().getId();
				SourceOfAdmission sourceOfAdmission = (SourceOfAdmission)getLookupService().getLookupInstance(SourceOfAdmission.class, lookupId);
				if(sourceOfAdmission != null)
				{
					returnVal.setAdmitSource(sourceOfAdmission);
				}
			}
			
			// patientType
			if(admissionDetail != null
					&& admissionDetail.getPatientStatus() != null)
			{
				Integer lookupId = admissionDetail.getPatientStatus().getId();
				PatientStatus patientStatus = (PatientStatus)getLookupService().getLookupInstance(PatientStatus.class, lookupId);
				if(patientStatus != null)
				{
					returnVal.setPatientType(patientStatus);
				}
			}
			//WDEV-20436
			if(currentWardStay != null 
					&& currentWardStay.getPatientStatus() != null)
			{
				Integer lookupId = currentWardStay.getPatientStatus().getId();
				PatientStatus patientStatus = (PatientStatus)getLookupService().getLookupInstance(PatientStatus.class, lookupId);
				if(patientStatus != null)
				{
					returnVal.setPatientType(patientStatus);
				}
			} //WDEV-20436
			
			// isChaplainRequired
			if(admissionDetail != null
					&& admissionDetail.isIsChaplainRequired() != null)
			{
				returnVal.setIsChaplainRequired(admissionDetail.isIsChaplainRequired());
			}

			
			// TCIType
			if(pendingElectiveAdmission != null
					&& pendingElectiveAdmission.getTCIType() != null)
			{
					Integer lookupId = pendingElectiveAdmission.getTCIType().getId();
					TCIType tciType = (TCIType)getLookupService().getLookupInstance(TCIType.class, lookupId);
					if(tciType != null)
					{
						returnVal.setTCIType(tciType);
					}
			}

			// admissionDateTime
			if(admissionDetail != null
					&& admissionDetail.getAdmissionDateTime() != null)
			{
				returnVal.setAdmissionDateTime(new ims.framework.utils.DateTime(admissionDetail.getAdmissionDateTime()));
			}

			// wardType
			if(currentWardStay != null
					&& currentWardStay.getWardType() != null)
			{
				Integer lookupId = currentWardStay.getWardType().getId();
				WardType wardType = (WardType)getLookupService().getLookupInstance(WardType.class, lookupId);
				if(wardType != null)
				{
					returnVal.setWardType(wardType);
				}
			}
			
			// admissionReason
			if(admissionDetail != null
					&& admissionDetail.getReasonForAdmission() != null)
			{
				returnVal.setAdmissionReason(admissionDetail.getReasonForAdmission());
			}
			
			// dischargeDisposition
			// dischargeDestination
			// dischargeDateTime
			// Following only relate to DISCHARGES!
			// ====================================
			if(dischargedEpisode != null)
			{

				// dischargeDisposition
				//http://jira/browse/WDEV-22260
//				if(dischargedEpisode.getExtendedDetails() != null 
//						&& dischargedEpisode.getExtendedDetails().getDischargeReason() != null)
//				{
//					Integer lookupId = dischargedEpisode.getExtendedDetails().getDischargeReason().getId();
//					DischargeReason dischargeReason = (DischargeReason)getLookupService().getLookupInstance(DischargeReason.class, lookupId);
//					if(dischargeReason != null)
//					{
//						returnVal.setDischargeDisposition(dischargeReason);
//					}
//				}
				if (dischargedEpisode.getMethodOfDischarge() != null)
				{
					Integer lookupId = dischargedEpisode.getMethodOfDischarge().getId();
					MethodOfDischarge methodOfDischarge = (MethodOfDischarge) getLookupService().getLookupInstance(MethodOfDischarge.class, lookupId);
					if (methodOfDischarge != null)
					{
						returnVal.setMethodOfDischarge(methodOfDischarge);
					}
						
				} //WDEV-22260
				
				// dischargeDestination
				if(dischargedEpisode.getDischargeDestination() != null)
				{
					Integer lookupId = (dischargedEpisode.getDischargeDestination().getId());
					DischargeDestination dischargeDestination = (DischargeDestination)getLookupService().getLookupInstance(DischargeDestination.class, lookupId);
					if(dischargeDestination != null)
					{
						returnVal.setDischargeDestination(dischargeDestination);
					}
				}
								
				// dischargeDateTime
				if(dischargedEpisode.getDischargeDateTime()!=null)
				{
					returnVal.setDischargeDateTime(new ims.framework.utils.DateTime(dischargedEpisode.getDischargeDateTime()));
				}
			
			}
			
			// expectedLOAReturnDateTime
			// dateTimeOnHomeLeave
			// Following only relates to LOA (Leave Of Absence)
			// ===============================================

			// Iterate through HomeLeaves until final one is obtained
			if(inpatientEpisode != null 
					&& inpatientEpisode.isIsOnHomeLeave() != null)
			{
				if(inpatientEpisode.getDateOnHomeLeave() != null 
						&& inpatientEpisode.getTimeOnHomeLeave() != null)
				{
					if(inpatientEpisode.isIsOnHomeLeave() 
							&& inpatientEpisode.getHomeLeaves() != null)
					{
						List <HomeLeave> homeLeaves = inpatientEpisode.getHomeLeaves();
						for (Iterator iter = homeLeaves.iterator(); iter.hasNext();)
						{
							HomeLeave thisHomeLeave = (HomeLeave) iter.next();
							//WDEV-20405
//							if(thisHomeLeave.getDateOnHomeLeave() != null 
//									&& thisHomeLeave.getTimeOnHomeLeave() != null)
							if(thisHomeLeave != null 
									&& thisHomeLeave.getDateOnHomeLeave() != null 
									&& thisHomeLeave.getTimeOnHomeLeave() != null) //WDEV-20405
							{
//								String myDate = thisHomeLeave.getDateOnHomeLeave().toString() + thisHomeLeave.getTimeOnHomeLeave().toString();
								String myDate = thisHomeLeave.getDateOnHomeLeave().toString() + " " + thisHomeLeave.getTimeOnHomeLeave().toString();
								SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm");
								Date utilDate = new Date();
								try
								{
									utilDate = sdf.parse(myDate);
								}
								catch (java.text.ParseException e)
								{
									e.printStackTrace();
									returnVal.setExpectedLOAReturnDateTime(null);
								}
								DateTime loaDateTime = new DateTime(utilDate);
								returnVal.setDateTimeOnHomeLeave(loaDateTime);
							}
							//WDEV-20405
//							if(thisHomeLeave.getExpectedDateOfReturn() != null							
//								&& thisHomeLeave.getExpectedTimeOfReturn() != null)
							if(thisHomeLeave != null
									&& thisHomeLeave.getExpectedDateOfReturn() != null 
									&& thisHomeLeave.getExpectedTimeOfReturn() != null) //WDEV-20405
							{
								//String myDate = thisHomeLeave.getExpectedDateOfReturn().toString() + thisHomeLeave.getExpectedTimeOfReturn().toString();
								String myDate = thisHomeLeave.getExpectedDateOfReturn().toString() + " " + thisHomeLeave.getExpectedTimeOfReturn().toString();
								SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm");
								Date utilDate = new Date();
								try
								{
									utilDate = sdf.parse(myDate);
								}
								catch (java.text.ParseException e)
								{
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								DateTime loaDateTime = new DateTime(utilDate);
								returnVal.setExpectedLOAReturnDateTime(loaDateTime);
								
								//WDEV-22918
								/*
								 * if the message type is:
								 *  A21 (PATIENT GOES ON A LEAVE OF ABSENCE) 
								 *  A22 (PATIENT RETURNS FROM A LEAVE OF ABSENCE)
								 *  A52 (CANCEL LEAVE OF ABSENCE FOR A PATIENT)
								 * Need to populate returnVal.setAdmissionEventDateTime with InpatientEpisodeADTMessageQueue SystemInformation
								 */
								if (MsgEventType.A21.equals(queueItem.getMsgType())
										|| MsgEventType.A22.equals(queueItem.getMsgType())
										|| MsgEventType.A52.equals(queueItem.getMsgType()))
								{
									if (queueItem.getSysInfo() != null)
									{
										if (queueItem.getSysInfo().getLastupdateDateTime() != null)
										{
											DateTime admissionEventDateTime = new DateTime(queueItem.getSysInfo().getLastupdateDateTime());
											returnVal.setAdmissionEventDateTime(admissionEventDateTime);
										} 
										else if (queueItem.getSysInfo().getCreationDateTime() != null)
										{
											DateTime admissionEventDateTime = new DateTime(queueItem.getSysInfo().getCreationDateTime());
											returnVal.setAdmissionEventDateTime(admissionEventDateTime);
										}
									}
								} //WDEV-22918

							}
						}
					}
				}
			}
			
			// preadmissionNumber
			if(patientElectiveList != null
					&& patientElectiveList.getId() != null
					&& patientElectiveList.getId() > 0)
			{
				returnVal.setPreadmissionNumber(patientElectiveList.getId().toString());	
			}
			
			// methodOfAdmission
			if(admissionDetail != null
					&& admissionDetail.getMethodOfAdmission() != null)
			{
				Integer lookupId = admissionDetail.getMethodOfAdmission().getId();
				MethodOfAdmission methodOfAdmission = (MethodOfAdmission)getLookupService().getLookupInstance(MethodOfAdmission.class, lookupId);
				if(methodOfAdmission != null)
				{
					returnVal.setMethodOfAdmission(methodOfAdmission);
				}
			}
			
			// wardLocation [CURRENT]
			if(currentWardStay != null
					&& currentWardStay.getWard()!=null)
			{
				LocMostVo ward = LocMostVoAssembler.create(currentWardStay.getWard());
				if(ward != null)
				{
					returnVal.setWardLocation(ward);
				}
			}
			//WDEV-23891
			else
			{
				if (pasEvent.getLocation() != null)
				{
					LocMostVo ward = LocMostVoAssembler.create(pasEvent.getLocation());
					if (ward != null)
					{
						returnVal.setWardLocation(ward);
					}
				}
			} //WDEV-23891
			
			// facility
			// Need to recurse up Location.Parent to highest parent to obtain current facility (hospital)
			if(currentWardStay != null
					&& currentWardStay.getWard() != null
					&& currentWardStay.getWard().getParentLocation() != null)
			{
				Location internalLocation = currentWardStay.getWard().getParentLocation();

				//WDEV-20370 Coding error - while clause recoded
				while (internalLocation != null)
				{
					if(internalLocation.getType() != null
						&& internalLocation.getType().equals(getDomLookup(LocationType.HOSP))
						&& internalLocation.getCodeMappings() != null)
					{
						LocMostVo facilityLoc = LocMostVoAssembler.create(internalLocation);
						//WDEV-20269
						TaxonomyMap map = facilityLoc.getTaxonomyMap(queueItem.getProviderSystem().getCodeSystem());	
						if (map != null)
						{
							returnVal.setFacility(map.getTaxonomyCode());
							break;
						}
					}
					internalLocation = internalLocation.getParentLocation();
				}
				//WDEV20440 internalLocation = internalLocation.getParentLocation(); //WDEV-20440 
				//WDEV-20370
			}
			//WDEV-23891
			else
			{
				if (pasEvent.getLocation() != null
						&& pasEvent.getLocation().getParentLocation() != null)
				{
					Location internalLocation = pasEvent.getLocation().getParentLocation();
					while (internalLocation != null)
					{
						if (internalLocation.getType() != null
							&& internalLocation.getType().equals(getDomLookup(LocationType.HOSP))
							&& internalLocation.getCodeMappings() != null)
						{
							LocMostVo facilityLoc = LocMostVoAssembler.create(internalLocation);
							TaxonomyMap map = facilityLoc.getTaxonomyMap(queueItem.getProviderSystem().getCodeSystem());	
							if (map != null)
							{
								returnVal.setFacility(map.getTaxonomyCode());
								break;
							}
						}
						internalLocation = internalLocation.getParentLocation();
					}
				}
			} //WDEV-23891

			
			// priorWardLocation
			// priotFacilty
			// priorLocationDescription
			// Following only relates to TRANSFERS
			// ===================================
			if(admissionDetail != null
					&& admissionDetail.getTransferHistory() != null)
			{
				List <TransferHistory> transferHistory = admissionDetail.getTransferHistory();			
				if(transferHistory.size() > 0)
				{
					if(transferHistory.get(transferHistory.size()-1).getTransferringFromWard() != null)
					{
						LocMostVo ward = LocMostVoAssembler.create(transferHistory.get(transferHistory.size()-1).getTransferringFromWard());
						if(ward != null)
						{
							returnVal.setPriorWardLocation(ward);
							if(ward.getName() != null)
							{
								returnVal.setPriorLocationDescription(ward.getName());
							}

							//Get the prior facility for this ward (hospital)
							Location internalLocation = transferHistory.get(transferHistory.size()-1).getTransferringFromWard().getParentLocation();

							//WDEV-20370 - coding error - while clause recoded
							while (internalLocation != null)
							{
								if(internalLocation.getType() != null
										&& internalLocation.getType().equals(getDomLookup(LocationType.HOSP))
										&& internalLocation.getCodeMappings() != null)
								{
									LocMostVo facilityLoc = LocMostVoAssembler.create(internalLocation);
									//WDEV-20269
									TaxonomyMap map = facilityLoc.getTaxonomyMap(queueItem.getProviderSystem().getCodeSystem());	
									if (map != null)
									{
										returnVal.setPriorFacilty(map.getTaxonomyCode());
										break;
									}
								}
								internalLocation = internalLocation.getParentLocation();
							}
							//WDEV-2440 internalLocation = internalLocation.getParentLocation(); //WDEV-20440
							//WDEV-20370
							
							//WDEV-22673
							if (transferHistory.get(transferHistory.size()-1).getTransferReason() != null)
							{
								Integer lookupId = transferHistory.get(transferHistory.size()-1).getTransferReason().getId();
								TransferReason transferReason = (TransferReason) getLookupService().getLookupInstance(TransferReason.class, lookupId);
								returnVal.setPriorTransferReason(transferReason);
								
								//WDEV-22918
								if (transferHistory.get(transferHistory.size()-1) != null)
								{
									TransferHistory transHistory = transferHistory.get(transferHistory.size()-1);
									if (transHistory.getSystemInformation().getLastUpdateDateTime() != null)
									{
										DateTime transferEventDateTime = new DateTime(transHistory.getSystemInformation().getLastUpdateDateTime());
										returnVal.setTransferEventDateTime(transferEventDateTime);
									}
									else if (transHistory.getSystemInformation().getCreationDateTime()!= null)
									{
										DateTime transferEventDateTime = new DateTime(transHistory.getSystemInformation().getCreationDateTime());
										returnVal.setTransferEventDateTime(transferEventDateTime);
									}
								} //WDEV-22918
									
								
							} //WDEV-22673
						}
					}
				}
			}



			// electiveAdmissionType
			if(patientElectiveList != null
					&& patientElectiveList.getElectiveAdmissionType() != null)
			{
				Integer lookupId = patientElectiveList.getElectiveAdmissionType().getId();
				ElectiveAdmissionType electiveAdmissionType = (ElectiveAdmissionType)getLookupService().getLookupInstance(ElectiveAdmissionType.class, lookupId);
				if (electiveAdmissionType != null)
				{
					returnVal.setElectiveAdmissionType(electiveAdmissionType);
				}
			}
			
			//WDEV-19974 Pending Transfer - only available for undischarged patient
			if(inpatientEpisode != null 
					&& inpatientEpisode.getId() != null)
			{
				ifPendingTransferVo pendingTransfer = ifPendingTransferVoAssembler.create(PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, inpatientEpisode.getId()));
				if(pendingTransfer != null)
				{
					returnVal.setPendingTransfer(pendingTransfer);
					//WDEV-20436
					if(pendingTransfer.getPatientStatus() != null)
					{
						Integer lookupId = pendingTransfer.getPatientStatus().getId();
						PatientStatus patientStatus = (PatientStatus)getLookupService().getLookupInstance(PatientStatus.class, lookupId);
						if(patientStatus != null)
						{
							returnVal.setPatientType(patientStatus);
						}
					} //WDEV-20436
					
					//WDEV-22918
					if (pendingTransfer.getSysInfo() != null)
					{
						if (pendingTransfer.getSysInfo().getLastupdateDateTime() != null)
						{
							DateTime transferEventDateTime = new DateTime(pendingTransfer.getSysInfo().getLastupdateDateTime());
							returnVal.setTransferEventDateTime(transferEventDateTime);
						}
						else if (pendingTransfer.getSysInfo().getCreationDateTime()!= null)
						{
							DateTime transferEventDateTime = new DateTime(pendingTransfer.getSysInfo().getCreationDateTime());
							returnVal.setTransferEventDateTime(transferEventDateTime);
						}
					} //WDEV-22918
				}
			}
			
			//WDEV-20451 Expected discharge date/time
			if(inpatientEpisode != null
					&& inpatientEpisode.getEstDischargeDate() != null)
			{
				returnVal.setExpectedDischargeDateTime(new ims.framework.utils.DateTime(inpatientEpisode.getEstDischargeDate()));
				//WDEV-22918
				if (inpatientEpisode.getSystemInformation() != null)
				{
					if (inpatientEpisode.getSystemInformation().getLastUpdateDateTime() != null)
					{
						DateTime admissionEventDateTime = new DateTime(inpatientEpisode.getSystemInformation().getLastUpdateDateTime());
						returnVal.setAdmissionEventDateTime(admissionEventDateTime);
					}
					else if (inpatientEpisode.getSystemInformation().getCreationDateTime() != null)
					{
						DateTime admissionEventDateTime = new DateTime(inpatientEpisode.getSystemInformation().getCreationDateTime());
						returnVal.setAdmissionEventDateTime(admissionEventDateTime);						
					}
				} //WDEV-22918
			}
			
			//WDEV-20445 If confirmed expected date of discharge is set, use this value to set Discharge Date Time
			// This is ONLY used for the A16 message (Pending Discharge)
			if(inpatientEpisode != null
					&& inpatientEpisode.getConfirmedDischargeDateTime() != null
					&& dischargedEpisode == null)
			{
				returnVal.setDischargeDateTime(new ims.framework.utils.DateTime(inpatientEpisode.getConfirmedDischargeDateTime()));
			}
			
			//WDEV-20018 Estimated length of stay
			if(inpatientEpisode != null
					&& inpatientEpisode.getAdmissionDateTime() != null
					&& inpatientEpisode.getEstDischargeDate() != null)
			{
				Calendar startCal=new GregorianCalendar();
				Calendar endCal=new GregorianCalendar();

				startCal.setTime(inpatientEpisode.getAdmissionDateTime());
				endCal.setTime(inpatientEpisode.getEstDischargeDate());

				endCal.add(Calendar.YEAR,-startCal.get(Calendar.YEAR));
				endCal.add(Calendar.MONTH,-startCal.get(Calendar.MONTH));
				endCal.add(Calendar.DATE,-startCal.get(Calendar.DATE));
	
				int stayDays = endCal.get(Calendar.DAY_OF_YEAR);
				
				if(stayDays != 0)
				{
					returnVal.setEstLengthOfStay(stayDays);
				}
			} //WDEV-20018
					
			//WDEV-20204
			//bedSpaceStateBay
			if(inpatientEpisode != null
					&& inpatientEpisode.getBed() != null
					&& inpatientEpisode.getBed().getBay() != null)
			{
				LocShortMappingsVo bay = LocShortMappingsVoAssembler.create(inpatientEpisode.getBed().getBay());
				if(bay != null)
				{
					returnVal.setBedSpaceStateBay(bay);
				}
			} //WDEV-20204
			
			//WDEV-22479 
			//currentWardStayAdmissionDateTime
			if (currentWardStay != null 
				&& currentWardStay.getTransferDateTime() != null)
			{
				returnVal.setCurrentWardStayAdmissionDateTime(new ims.framework.utils.DateTime(currentWardStay.getTransferDateTime()));
			} //WDEV-22479
			
			//WDEV-22983
			if (admissionDetail != null
					&& admissionDetail.getSourceOfEmergencyReferral() != null)
			{
				Integer lookupId = admissionDetail.getSourceOfEmergencyReferral().getId();
				SourceOfEmergencyReferral sourceOfEmergencyReferral = (SourceOfEmergencyReferral)getLookupService().getLookupInstance(SourceOfEmergencyReferral.class, lookupId);
				if (sourceOfEmergencyReferral != null)
				{
					returnVal.setSourceOfEmergencyReferral(sourceOfEmergencyReferral);
				}
			} //WDEV-22983
			
		}
		
		return returnVal;
				
	}

	

	//WDEV-19481
	private PatientElectiveList getPatientElectiveList(Patient patient)
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from PatientElectiveList pel where pel.patient=:patient";
		List<?> l = factory.find(hql,new String[]{"patient"},new Object[]{patient});
		if (l != null && l.size() > 0)
		{
			return (PatientElectiveList)l.get(0);
		}
		return null;
	}
	

	//WDEV-19481
	private ConsultantStay getCurrentConsultantStay(InpatientEpisode inpatientEpisode)
	{
		ConsultantStay currentConsultantStay = null;
		
		Set<ConsultantStay> consultantStays = inpatientEpisode.getConsultantStays();
		
		if(consultantStays.iterator().hasNext())
		{
			currentConsultantStay = (ConsultantStay) consultantStays.iterator().next();
			for (Iterator iter = consultantStays.iterator(); iter.hasNext();)
			{
				ConsultantStay consultantStay = (ConsultantStay) iter.next();
				if(consultantStay.getTransferDateTime() != null 
						&& currentConsultantStay.getTransferDateTime() != null
						&& consultantStay.getTransferDateTime() .after(currentConsultantStay.getTransferDateTime()))
				{
					currentConsultantStay = consultantStay;
				}			
			}
		}
		return currentConsultantStay;
	}


	//WDEV-19481
	private WardStay getCurrentWardStay(InpatientEpisode inpatientEpisode)
	{
		WardStay currentWardStay = null;
		
		Set<WardStay> wardStays = inpatientEpisode.getWardStays();
		
		if(wardStays.iterator().hasNext())
		{
			currentWardStay = (WardStay) wardStays.iterator().next();
			for (Iterator iter = wardStays.iterator(); iter.hasNext();)
			{
				WardStay wardStay = (WardStay) iter.next();
				if(wardStay.getTransferDateTime() != null 
						&& currentWardStay.getTransferDateTime() != null
						&& wardStay.getTransferDateTime() .after(currentWardStay.getTransferDateTime()))
				{
					currentWardStay = wardStay;
				}			
			}
		}
		return currentWardStay;
	}


	//WDEV-19481
	private ConsultantStay getCurrentConsultantStay(DischargedEpisode dischargedEpisode)
	{
		ConsultantStay currentConsultantStay = null;
		
		Set<ConsultantStay> consultantStays = dischargedEpisode.getConsultantStays();
		
		if(consultantStays.iterator().hasNext())
		{
			currentConsultantStay = (ConsultantStay) consultantStays.iterator().next();
			for (Iterator iter = consultantStays.iterator(); iter.hasNext();)
			{
				ConsultantStay consultantStay = (ConsultantStay) iter.next();
				if(consultantStay.getTransferDateTime() != null 
						&& currentConsultantStay.getTransferDateTime() != null
						&& consultantStay.getTransferDateTime() .after(currentConsultantStay.getTransferDateTime()))
				{
					currentConsultantStay = consultantStay;
				}			
			}
		}
		return currentConsultantStay;
	}


	//WDEV-19481
	private WardStay getCurrentWardStay(DischargedEpisode dischargedEpisode)
	{
		WardStay currentWardStay = null;
		
		Set<WardStay> wardStays = dischargedEpisode.getWardStays();
		
		if(wardStays.iterator().hasNext())
		{
			currentWardStay = (WardStay) wardStays.iterator().next();
			for (Iterator iter = wardStays.iterator(); iter.hasNext();)
			{
				WardStay wardStay = (WardStay) iter.next();
				if(wardStay.getTransferDateTime() != null 
						&& currentWardStay.getTransferDateTime() != null
						&& wardStay.getTransferDateTime().after(currentWardStay.getTransferDateTime()))
				{
					currentWardStay = wardStay;
				}			
			}
		}
		return currentWardStay;
	}


	//WDEV-19481
	private DischargedEpisode getDischargedEpisode(PASEvent pasEvent)
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from DischargedEpisode ie where ie.pasEvent=:pasEvent";
		List<?> l = factory.find(hql,new String[]{"pasEvent"},new Object[]{pasEvent});
		if (l != null && l.size() > 0)
		{
			return (DischargedEpisode)l.get(0);
		}
		return null;
	}


	//WDEV-19481
	private InpatientEpisode getInpatientEpisode(PASEvent pasEvent)
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from InpatientEpisode ie where ie.pasEvent=:pasEvent";
		List<?> l = factory.find(hql,new String[]{"pasEvent"},new Object[]{pasEvent});
		if (l != null && l.size() > 0)
		{
			return (InpatientEpisode)l.get(0);
		}
		return null;
	}


	//WDEV-19481
	private PendingElectiveAdmission getPendingElectiveAdmission(PASEvent pasEvent)
	{
			DomainFactory factory = getDomainFactory();
			String hql = "from PendingElectiveAdmission pea where pea.pasEvent=:pasEvent";
			List<?> l = factory.find(hql,new String[]{"pasEvent"},new Object[]{pasEvent});
			if (l != null && l.size() > 0)
			{
				return (PendingElectiveAdmission)l.get(0);
			}
			return null;
	}


	//WDEV-19481
	public void triggerAdmissionEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A01);	
	}

	//http://jira/browse/WDEV-20919
	private void triggerAdmissionEvent(PASEvent pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A01);		
	}

	public void triggerTransferEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A02);	
	}


	public void triggerDischargeEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A03);	
	}


	public void triggerCancelAdmissionEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A11);	
	}


	public void triggerCancelTransferEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A12);	
	}


	public void triggerCancelDischargeEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A13);	
	}


	public void triggerUpdateAdmissionEvent(PASEventRefVo pasEvent,MsgUpdateType type) throws StaleObjectException //http://jira/browse/WDEV-22831
	{
		triggerADTEvent(pasEvent, MsgEventType.A08,type);	
	}


	public void triggerLeaveOfAbsenceEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A21);	
	}


	public void triggerReturnFromLeaveOfAbsenceEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A22);	
	}


	public void triggerCancelLeaveOfAbsenceEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A52);	
	}


	public void triggerCancelReturnFromLeaveOfAbsenceEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A53);	
	}

	
	//WDEV-19974 Pending transfer
	public void triggerPendingTransferEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A15);	
	}

	//WDEV-19974 Cancel Pending transfer
	public void triggerCancelPendingTransferEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A26);	
	}

	//WDEV-20445 Pending Discharge
	public void triggerPendingDischargeEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		triggerADTEvent(pasEvent, MsgEventType.A16);	
	}

	//WDEV-20445 Cancel Pending Discharge
	public void triggerCancelPendingDischargeEvent(PASEventRefVo pasEvent) throws StaleObjectException
	{
		// A25 message generation temporarily commented out. see WDEV-20506
//		triggerADTEvent(pasEvent,MsgEventType.A25);	
	}
	
	//http://jira/browse/WDEV-22831
	private void triggerADTEvent(PASEventRefVo pasEvent, MsgEventType a08,MsgUpdateType type)  throws StaleObjectException
	{
		if(pasEvent!=null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.INPATIENTEPISODE.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				InpatientEpisodeQueue event = new InpatientEpisodeQueue();
				event.setPasEvent((PASEvent)factory.getDomainObject(pasEvent));
				event.setProviderSystem(providerSystem);
				event.setWasProcessed(Boolean.FALSE);
				event.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				event.setMsgType(getDomLookup(a08));
				event.setQueueType(getDomLookup(QueueType.INPATIENTEPISODE));
				event.setUpdateType(getDomLookup(type));
				factory.save(event);
			}
		}
	}
	
	
	private void triggerADTEvent(PASEventRefVo pasEvent, LookupInstVo type)  throws StaleObjectException
	{
		if(pasEvent!=null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.INPATIENTEPISODE.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				InpatientEpisodeQueue event = new InpatientEpisodeQueue();
				event.setPasEvent((PASEvent)factory.getDomainObject(pasEvent));
				event.setProviderSystem(providerSystem);
				event.setWasProcessed(Boolean.FALSE);
				event.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				event.setMsgType(getDomLookup(type));
				event.setQueueType(getDomLookup(QueueType.INPATIENTEPISODE));
				factory.save(event);
			}
		}
	}
	

	// http://jira/browse/WDEV-20919
	private void triggerADTEvent(PASEvent pasEvent, LookupInstVo type)  throws StaleObjectException
	{
		if(pasEvent!=null)
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
					+ " where(i.id = "+QueueType.INPATIENTEPISODE.getId()+")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				InpatientEpisodeQueue event = new InpatientEpisodeQueue();
				event.setPasEvent(pasEvent);
				event.setProviderSystem(providerSystem);
				event.setWasProcessed(Boolean.FALSE);
				event.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				event.setMsgType(getDomLookup(type));
				event.setQueueType(getDomLookup(QueueType.INPATIENTEPISODE));
				factory.save(event);
			}
		}
	}

	//WDEV-19576 MFNM05 HL7 message processing for Ward Master File event
	public void triggerWardMasterFileEvent(LocationRefVo location, LookupInstVo type) throws StaleObjectException
	{
//		if(location!=null)
//		{
//			DomainFactory factory = getDomainFactory();
//			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
//					+ " where(i.id = "+QueueType.WARDMASTERFILE.getId()+")";
//
//			java.util.List<ProviderSystem> list = factory.find(hqlString);
//			for (ProviderSystem providerSystem : list)
//			{
//				WardMessageQueue messageQueue = new WardMessageQueue();
//				messageQueue.setWard((Location)factory.getDomainObject(location));
//				messageQueue.setProviderSystem(providerSystem);
//				messageQueue.setWasProcessed(Boolean.FALSE);
//				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
//				messageQueue.setMsgType(getDomLookup(type));
//				messageQueue.setQueueType(getDomLookup(QueueType.WARDMASTERFILE));
//				factory.save(messageQueue);
//			}
//			
//		}
	}


	//WDEV-19576 MFNM05 HL7 processing for GP Practice master file event
	public void triggerGPPracticeMasterFileEvent(OrganisationRefVo gPPractice, LookupInstVo type) throws StaleObjectException
	{
//		if(gPPractice!=null)
//		{
//			DomainFactory factory = getDomainFactory();
//			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
//					+ " where(i.id = "+QueueType.GPPRACTICEMASTERFILE.getId()+")";
//
//			java.util.List<ProviderSystem> list = factory.find(hqlString);
//			for (ProviderSystem providerSystem : list)
//			{
//				GPPracticeMessageQueue messageQueue = new GPPracticeMessageQueue();
//				messageQueue.setPractice((Organisation)factory.getDomainObject(gPPractice));
//				messageQueue.setProviderSystem(providerSystem);
//				messageQueue.setWasProcessed(Boolean.FALSE);
//				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
//				messageQueue.setMsgType(getDomLookup(type));
//				messageQueue.setQueueType(getDomLookup(QueueType.GPPRACTICEMASTERFILE));
//				factory.save(messageQueue);
//			}
//			
//		}
	}

	
	//WDEV-19576 MFNM02 HL7 message processing for GP master file event
	public void triggerGPMasterFileEvent(GpRefVo gP, LookupInstVo type) throws StaleObjectException
	{
//		if(gP!=null)
//		{
//			DomainFactory factory = getDomainFactory();
//			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
//					+ " where(i.id = "+QueueType.GPMASTERFILE.getId()+")";
//
//			java.util.List<ProviderSystem> list = factory.find(hqlString);
//			for (ProviderSystem providerSystem : list)
//			{
//				GPMessageQueue messageQueue = new GPMessageQueue();
//				messageQueue.setGP((Gp)factory.getDomainObject(gP));
//				messageQueue.setProviderSystem(providerSystem);
//				messageQueue.setWasProcessed(Boolean.FALSE);
//				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
//				messageQueue.setMsgType(getDomLookup(type));
//				messageQueue.setQueueType(getDomLookup(QueueType.GPMASTERFILE));
//				factory.save(messageQueue);
//			}
//			
//		}
	}


	//WDEV-19576 MFNM02 HL7 consultant master file event
	public void triggerMOSMasterFileEvent(MemberOfStaffRefVo mos, LookupInstVo type) throws StaleObjectException
	{
//		if(mos!=null)
//		{
//			DomainFactory factory = getDomainFactory();
//			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
//					+ " where(i.id = "+QueueType.MOSMASTERFILE.getId()+")";
//
//			java.util.List<ProviderSystem> list = factory.find(hqlString);
//			for (ProviderSystem providerSystem : list)
//			{
//				MOSMessageQueue messageQueue = new MOSMessageQueue();
//				messageQueue.setMOS((MemberOfStaff)factory.getDomainObject(mos));
//				messageQueue.setProviderSystem(providerSystem);
//				messageQueue.setWasProcessed(Boolean.FALSE);
//				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
//				messageQueue.setMsgType(getDomLookup(type));
//				messageQueue.setQueueType(getDomLookup(QueueType.MOSMASTERFILE));
//				factory.save(messageQueue);
//			}
//			
//		}
	}


	
	//WDEV-19576
	public ifWardMessageQueueVo getWardMessageQueueDetails(WardMessageQueueVo queueItem)
	{
		if(queueItem==null)
			return null;

		ifWardMessageQueueVo returnVal = null;	
		DomainFactory factory = getDomainFactory();
		Location wardLocation = null;
		Location parentLocation = null; //WDEV-20096
		wardLocation = (Location)factory.getDomainObject(Location.class, queueItem.getWard().getBoId());		
		if(wardLocation!=null)
		{
			returnVal = ifWardMessageQueueVoAssembler.create(wardLocation);
			
			//WDEV-20096
			if(wardLocation.getParentLocation() != null)
			{
				parentLocation = wardLocation.getParentLocation();
//				LocShortMappingsVo parentLocVo = LocShortMappingsVoAssembler.create(parentLocation.getParentLocation());
				LocShortMappingsVo parentLocVo = LocShortMappingsVoAssembler.create(parentLocation);
				returnVal.setParentLocation(parentLocVo);
				while (parentLocation.getParentLocation() != null)
				{
					LocShortMappingsVo pLocVo = LocShortMappingsVoAssembler.create(parentLocation.getParentLocation());
					returnVal.setParentLocation(pLocVo);
					parentLocation = parentLocation.getParentLocation();
				}
			} //WDEV-20096

		}
		return returnVal;			
	}

	//WDEV-19576
	public ifMOSMessageQueueVo getMOSMessageQueueDetails(MOSMessageQueueVo queueItem)
	{		
		if(queueItem==null)
			return null;

		ifMOSMessageQueueVo returnVal = null;
		DomainFactory factory = getDomainFactory();
		MemberOfStaff mos = null;
		mos = (MemberOfStaff)factory.getDomainObject(MemberOfStaff.class, queueItem.getMOS().getBoId());
		if(mos!=null)
			returnVal = ifMOSMessageQueueVoAssembler.create(mos);
		if(mos!=null&&mos.getHcp()!=null&&mos.getHcp().getHcpType()!=null)
		{
			HcpDisType hcpDisType = (HcpDisType)getLookupService().getLookupInstance(HcpDisType.class, mos.getHcp().getHcpType().getId());
			returnVal.setHcpType(hcpDisType);
		}
		return returnVal;
	}

	//WDEV-19576
	public ifGPMessageQueueVo getGPMessageQueueDetails(GPMessageQueueVo queueItem)
	{
		if(queueItem==null)
			return null;

		ifGPMessageQueueVo returnVal = null;
		DomainFactory factory = getDomainFactory();
		Gp gp = null;
		gp = (Gp)factory.getDomainObject(Gp.class, queueItem.getGP().getBoId());
		if(gp!=null)
			returnVal = ifGPMessageQueueVoAssembler.create(gp);
		return returnVal;
	}

	//WDEV-19576
	public ifGPPracticeMessageQueueVo getGPPracticeMessageQueueDetails(GPPracticeMessageQueueVo queueItem)
	{
		if(queueItem==null)
			return null;

		ifGPPracticeMessageQueueVo returnVal = null;
		DomainFactory factory = getDomainFactory();
		Organisation gPPractice = null;
		gPPractice= (Organisation)factory.getDomainObject(Organisation.class, queueItem.getPractice().getBoId());
		if(gPPractice!=null)
			returnVal = ifGPPracticeMessageQueueVoAssembler.create(gPPractice);
		return returnVal;
	}
	
	
	//http://jira/browse/WDEV-19680
	//START
	private List<VTEAssessmentExclusions> getVTEExclusions()
	{
		DomainFactory factory = getDomainFactory();
		 List<VTEAssessmentExclusions> list =  (List<VTEAssessmentExclusions>)factory.find("from VTEAssessmentExclusions");
		 return list;
	}
	
	private VTEAssessmentConfig getVTEAssessmentConfig()
	{
		DomainFactory factory = getDomainFactory();
		return (VTEAssessmentConfig)factory.findFirst("from VTEAssessmentConfig");
	}
	
	private PatientSummaryRecord getSummaryRecord(Patient patient)
	{
		DomainFactory factory = getDomainFactory();
		return(PatientSummaryRecord)factory.findFirst("from PatientSummaryRecord where patient=:patient",new String[]{"patient"},new Object[]{patient});
	}
	
	boolean isExcluded(Location ward,LookupInstance specialty, VTEAssessmentConfig config)
	{
		if (config == null) //WDEV-19743
			return false;
		
		List<VTEAssessmentExclusions> wardExclusions = config.getExcludedWards();
		
		if(wardExclusions!=null)
		{
			for (VTEAssessmentExclusions vteAssessmentExclusions : wardExclusions)
			{
				if(vteAssessmentExclusions.getWard()!=null
						&& vteAssessmentExclusions.getWard().equals(ward))
				{
					return true;// Excluded based on ward
				}
			}
		}
		List<VTEAssessmentExclusions> specialityExclusions = config.getExcludedSpecialties();
		if(specialityExclusions!=null)
		{
			for (VTEAssessmentExclusions vteAssessmentExclusions : specialityExclusions)
			{
				if(vteAssessmentExclusions.getSpecialty()!=null
					&&vteAssessmentExclusions.getSpecialty().equals(specialty))
				{
					return true; // Excluded based on speciality
				}
			}
		}
		
		List<VTEAssessmentExclusions> comboExclusions = config.getExcludedCombination();
		if(comboExclusions!=null)
		{
			for (VTEAssessmentExclusions vteAssessmentExclusions : comboExclusions)
			{
				if(vteAssessmentExclusions.getSpecialty()!=null
					&&vteAssessmentExclusions.getWard()!=null
					&&vteAssessmentExclusions.getSpecialty().equals(specialty)
					&&vteAssessmentExclusions.getWard().equals(ward))
					{
						return true; // Excluded based on combo
					}
			}
		}
		return false;
	}
	
	
	boolean isValidCompletedDate(Date admissionDate,Date completedDate,VTEAssessmentConfig config)
	{
		try
		{
		if( config!=null
			&& config.getPreOpAssessmentValidPeriod()!=null
			&& admissionDate!=null
			&& completedDate!=null
			&& config.getPreOpAssessmentValidPeriod()
				>=Days.daysBetween(new org.joda.time.DateTime(completedDate) ,new org.joda.time.DateTime(admissionDate)).getDays())
			
		{
			return true;
		}
		
	}
	catch (Exception e)
	{
		LOG.warn("Exception checking completed date is valid",e);
	}
		return false;
	}
	
	boolean newIpVTEAssessmentExists(PatientSummaryRecord patientSummaryRecord,Date admissionDate)
	{
		try
		{
			if(patientSummaryRecord!=null
				&&admissionDate!=null
				&&patientSummaryRecord.getInpatientVTEAssessment()!=null
				&&patientSummaryRecord.getInpatientVTEAssessment().getRecordingInformation()!=null
				&&VTEAssessmentContextType.INPATIENT.getId()==(patientSummaryRecord.getInpatientVTEAssessment().getContextType().getId()))
			{
				int hours = Hours.hoursBetween(new org.joda.time.DateTime(patientSummaryRecord.getInpatientVTEAssessment().getRecordingInformation().getRecordingDateTime()),
						new org.joda.time.DateTime(admissionDate)).getHours();
				if (Math.abs(hours)<24)
					return true;
			}
		} catch (Exception e)
		{
			LOG.error("Exception calculating if Inpatient VTE Assessment is not stale",e);
		}
		return false;
	}
	
	void copyInpatientVTEtoEpisode(PatientSummaryRecord patientSummaryRecord,InpatientEpisode episode)
	{
		if(episode!=null
			&&patientSummaryRecord!=null)
		{
			episode.setVTERiskAssessment(patientSummaryRecord.getInpatientVTEAssessment());
			episode.setVTEAssessmentStatus(getDomLookup( VTEAsessmentStatus.COMPLETED));
		}
	}

	
	void copyPreOpVTEtoEpisode(PatientSummaryRecord patientSummaryRecord,InpatientEpisode episode)
	{
		episode.setVTERiskAssessment(patientSummaryRecord.getPreOpVTEAssessment());
		episode.setVTEAssessmentStatus(getDomLookup( VTEAsessmentStatus.COMPLETED));
	}
	
	void RestorePreOpVTEAssessmentToSummaryRecord(PatientSummaryRecord patientSummaryRecord,InpatientEpisode episode)
	{
		if(episode!=null
				&&episode.getVTERiskAssessment()!=null
				&&episode.getVTERiskAssessment().getContextType().equals(getDomLookup(VTEAssessmentContextType.PREOP)))
		{
			patientSummaryRecord.setPreOpVTEAssessment(episode.getVTERiskAssessment());
			patientSummaryRecord.getPreOpVTEAssessment().setValidatedInformation(null);
			if(patientSummaryRecord.getPreOpVTEAssessment().getVTEAssessmentStatus().equals(getDomLookup(VTEAsessmentStatus.VALIDATED)))
			{
				patientSummaryRecord.getPreOpVTEAssessment().setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.COMPLETED));
			}
			patientSummaryRecord.setPreOpVTEValidationDate(null);
			if(patientSummaryRecord.getPreOpVTEAssessment().getRecordingInformation()!=null)
			{
				patientSummaryRecord.setPreOpVTECompletedDate(patientSummaryRecord.getPreOpVTEAssessment().getRecordingInformation().getRecordingDateTime());
			}
		}
	}
	
	public void vteOnAdmission(ims.core.admin.pas.domain.objects.InpatientEpisode ipDo,
			ims.core.patient.domain.objects.Patient domPatient,
			Boolean isElective) 
	{
		if (ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue())
		{
			VTEAssessmentConfig config = getVTEAssessmentConfig();

			if (isExcluded(ipDo.getPasEvent().getLocation(), ipDo.getPasEvent().getSpecialty(), config))
			{
				ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.COMPLETED));
				ipDo.setVTEAssessmentStatusReason(getDomLookup(VTEAssessmentStatusReason.EXCLUDED));
			}
			else
			{
				PatientSummaryRecord patientSummaryRecord = getSummaryRecord(domPatient);

				if (Boolean.TRUE.equals(isElective))
				{
					//check the PreOp VTE is within the configured max period
					if (patientSummaryRecord != null && patientSummaryRecord.getPreOpVTEAssessment() != null && isValidCompletedDate(ipDo.getAdmissionDateTime(), patientSummaryRecord.getPreOpVTECompletedDate(), config))
					{

						if (patientSummaryRecord.getPreOpVTEValidationDate() == null)
						{
							copyPreOpVTEtoEpisode(patientSummaryRecord, ipDo);
							ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.VALIDATION_REQUIRED));
							ipDo.setVTEAssessmentStatusReason(null);
						}
						else if (patientSummaryRecord.getPreOpVTEValidationDate() != null)
						{
							copyPreOpVTEtoEpisode(patientSummaryRecord, ipDo);
							ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.VALIDATED));
							ipDo.setVTEAssessmentStatusReason(null);
						}
					} 
					//check if there is an Inpatient VTE Assessment to link
					else if (newIpVTEAssessmentExists(patientSummaryRecord, ipDo.getAdmissionDateTime()))
					{
						copyInpatientVTEtoEpisode(patientSummaryRecord, ipDo);
					} 
					// no PreOp or Inpatient VTE Assessments found
					else
					{
						ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
						ipDo.setVTEAssessmentStatusReason(null);
					}
				} 
				//if there is an Emergency Admission, only check for the Inpatient VTE Assessment
				else if (newIpVTEAssessmentExists(patientSummaryRecord, ipDo.getAdmissionDateTime()))
				{
					copyInpatientVTEtoEpisode(patientSummaryRecord, ipDo);
				}
				else
				{
					ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
					ipDo.setVTEAssessmentStatusReason(null);
				}
			}
		}
	}

	
	private boolean isElective(PendingElectiveAdmission domPEA)
	{
	if(domPEA!=null)
		return true;
	else
		return false;
	}

	public void vteOnCancelAdmission(ims.core.admin.pas.domain.objects.InpatientEpisode ipDo,ims.core.patient.domain.objects.Patient domPatient) throws StaleObjectException
	{
		if( ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue())
		{
			PatientSummaryRecord patientSummaryRecord = getSummaryRecord(domPatient);
			DomainFactory factory = getDomainFactory();
			if (patientSummaryRecord != null) //WDEV-20249
			{	
				RestorePreOpVTEAssessmentToSummaryRecord(patientSummaryRecord, ipDo);
				factory.save(patientSummaryRecord);
			}
		}
	}

	
	public void vteOnDischarge(ims.core.patient.domain.objects.Patient domPatient,ims.core.admin.pas.domain.objects.DischargedEpisode disDo, ims.core.admin.pas.domain.objects.InpatientEpisode ipDo) throws StaleObjectException
	{
		if( ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue())
		{
			DomainFactory factory= getDomainFactory();
			if(disDo.isWasTreatmentDeferred()!=null
					&&disDo.isWasTreatmentDeferred()
					&&ipDo.getVTERiskAssessment()!=null
					&&ipDo.getVTERiskAssessment().getContextType()!=null
					&&ipDo.getVTERiskAssessment().getContextType().equals(getDomLookup( VTEAssessmentContextType.PREOP)))
			{
				vteOnCancelAdmission(ipDo, domPatient);
			}
			else
			{
				disDo.setVTEAssessmentStatus(ipDo.getVTEAssessmentStatus());
				disDo.setVTERiskAssessment(ipDo.getVTERiskAssessment());
				disDo.setVTEAssessmentStatusReason(ipDo.getVTEAssessmentStatusReason());
				PatientSummaryRecord patientSummaryRecord = getSummaryRecord(domPatient);

				//WDEV-20611 if we have a Pending Elective Admission for the current pas event clear the patient summary record
				PendingElectiveAdmission pendingElectiveAdmission = getPendingElectiveAdmission(ipDo.getPasEvent());   
				
				if (patientSummaryRecord != null && disDo.getVTERiskAssessment()!= null && pendingElectiveAdmission != null)
				{
					patientSummaryRecord.setInpatientVTEAssessment(null);
					patientSummaryRecord.setPreOpVTEAssessment(null);
					patientSummaryRecord.setPreOpVTECompletedDate(null);
					patientSummaryRecord.setPreOpVTEValidationDate(null);
					factory.save(patientSummaryRecord);
				}
			}
		}
	}
	//http://jira/browse/WDEV-19680
	//END	
	
	
	//WDEV-19704
	public ifElectiveListMessageQueueVo getElectiveListMessageQueueDetails(ElectiveListMessageQueueVo queueItem)
	{
		if(queueItem == null)
			return null;

		ifElectiveListMessageQueueVo returnVal = null;
		DomainFactory factory = getDomainFactory();
		PatientElectiveList patientElectiveList = null;
		patientElectiveList = (PatientElectiveList)factory.getDomainObject(PatientElectiveList.class, queueItem.getPatientElectiveList().getBoId());
		if (patientElectiveList != null)
		{

			returnVal = ifElectiveListMessageQueueVoAssembler.create(patientElectiveList);

			// dateOfReferral [Date]
			if(patientElectiveList.getDateOnList() != null)
				returnVal.setDateOnList(new ims.framework.utils.Date(patientElectiveList.getDateOnList()));
			
			// patientStatus [CatsReferralCategory lookup]
			if (patientElectiveList.getPatientStatus() != null)
			{
				Integer lookupId = patientElectiveList.getPatientStatus().getId();
				//WDEV-23110
//				CatsReferralCategory patientStatus = (CatsReferralCategory)getLookupService().getLookupInstance(PatientStatus.class, lookupId);
				CatsReferralCategory patientStatus = (CatsReferralCategory)getLookupService().getLookupInstance(CatsReferralCategory.class, lookupId); //WDEV-23110
				if(patientStatus != null)
					returnVal.setPatientStatus(patientStatus);
			}
			
			// electiveAdmissionType [ElectiveAdmissionType lookup]
			if (patientElectiveList.getElectiveAdmissionType() != null)
			{
				Integer lookupId = patientElectiveList.getElectiveAdmissionType().getId();
				ElectiveAdmissionType admissionType = (ElectiveAdmissionType)getLookupService().getLookupInstance(ElectiveAdmissionType.class, lookupId);
				if(admissionType != null)
					returnVal.setElectiveAdmissionType(admissionType);
			}

			// intendedManagement [ManagementIntention lookup]
			if (patientElectiveList.getIntendedManagement() != null)
			{
				Integer lookupId = patientElectiveList.getIntendedManagement().getId();
				ManagementIntention intendedManagement = (ManagementIntention)getLookupService().getLookupInstance(ManagementIntention.class, lookupId);
				if(intendedManagement != null)
					returnVal.setIntendedManagement(intendedManagement);
			}

			// anticipatedStay [integer]
			if (patientElectiveList.getAnticipatedStay() != null)
				returnVal.setAnticipatedStay(patientElectiveList.getAnticipatedStay());
			
			// referringGP [GpLiteVo]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getGPName() != null)
			{
				Gp referringGpDom=((PatientElectiveList) patientElectiveList).getReferral().getReferralDetails().getGPName();
				GpLiteVo referringGp = GpLiteVoAssembler.create(referringGpDom); 
				if(referringGp != null)
					returnVal.setReferringGP(referringGp);
			}

			// referringConsultant [MemberOfStaffShortVo]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getReferringConsultant() != null
					&& patientElectiveList.getReferral().getReferralDetails().getReferringConsultant().getMos() != null)
			{
				MemberOfStaff referringConsultantDom = ((PatientElectiveList) patientElectiveList).getReferral().getReferralDetails().getReferringConsultant().getMos();
				MemberOfStaffShortVo referringConsultant = MemberOfStaffShortVoAssembler.create(referringConsultantDom);
				if(referringConsultant != null)
					returnVal.setReferringConsultant(referringConsultant);
			}

			// consultingDoctor [MemberOfStaffShortVo]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCIConsultant() != null
					&& patientElectiveList.getTCIDetails().getTCIConsultant().getMos() != null)
			{
				MemberOfStaff consultingDoctorDom = ((PatientElectiveList) patientElectiveList).getTCIDetails().getTCIConsultant().getMos();
				MemberOfStaffShortVo consultingDoctor = MemberOfStaffShortVoAssembler.create(consultingDoctorDom);
				if(consultingDoctor != null)
					returnVal.setConsultingDoctor(consultingDoctor);				
			}
			//WDEV-21717 Populate PV1-7 and PV1-9 in A05 messages with Elective List consultant when no TCI detail's consultant is defined
			else
			{
				if (patientElectiveList.getConsultant() != null
						&& patientElectiveList.getConsultant().getMos() != null)
				{
					MemberOfStaff consultingDoctorDom = patientElectiveList.getConsultant().getMos();
					MemberOfStaffShortVo consultingDoctor = MemberOfStaffShortVoAssembler.create(consultingDoctorDom);
					if (consultingDoctor != null)
						returnVal.setConsultingDoctor(consultingDoctor);																	
				}
			} //WDEV-21717
			
			// specialty [Specialty lookup]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getService() != null
					&& patientElectiveList.getReferral().getReferralDetails().getService().getSpecialty() != null)
			{
				Integer lookupId = patientElectiveList.getReferral().getReferralDetails().getService().getSpecialty().getId();
				Specialty specialty = (Specialty)getLookupService().getLookupInstance(Specialty.class, lookupId);
				if (specialty != null)
					returnVal.setSpecialty(specialty);
			}
			
			// TCIWard [LocSiteShortVo]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCIWard() != null)
			{
				Location tciWardDom = patientElectiveList.getTCIDetails().getTCIWard();
				LocMostVo tciward = LocMostVoAssembler.create(tciWardDom);
				if (tciward != null)
					returnVal.setTCIWard(tciward);
			}

			// TCIDate [Date]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCIDate() != null)
			{
				returnVal.setTCIDate(new ims.framework.utils.Date(patientElectiveList.getTCIDetails().getTCIDate()));
			}

			// TCITime [String]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCITime() != null)
			{
				returnVal.setTCITime(new ims.framework.utils.Time(patientElectiveList.getTCIDetails().getTCITime()));
			}
			
			// alliedHealthProfessional [String]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getAlliedHealthProfName() != null)
			{
				returnVal.setAlliedHealthProfessional(patientElectiveList.getReferral().getReferralDetails().getAlliedHealthProfName());
			}
			
			// referringPractice [OrgShortVo]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getPractice() != null)
			{
				Organisation referringPracticeDom = ((PatientElectiveList) patientElectiveList).getReferral().getReferralDetails().getPractice();
				OrgShortVo referringPractice = OrgShortVoAssembler.create(referringPracticeDom);
				if (referringPractice != null)
					returnVal.setReferringPractice(referringPractice);
			}
			
			// attendingDoctor [MemberOfStaffShortVo]
//			if(patientElectiveList.???????????????)
//			{
//				MemberOfStaff attendingDoctorDom = ((PatientElectiveList) patientElectiveList).getTCIDetails().getTCIConsultant().getMos();
//				MemberOfStaffShortVo attendongDoctor = MemberOfStaffShortVoAssembler.create(attendingDoctorDom);
//				if(attendingDoctor!=null)
//					returnVal.setAttendingDoctor(attendingDoctor);				
//
//			}
			
			// TCIHospital [LocSiteShortVo]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCIHospital() != null)
			{
				Location tciHospitalDom = patientElectiveList.getTCIDetails().getTCIHospital();
				LocMostVo tciHospital = LocMostVoAssembler.create(tciHospitalDom);
				if (tciHospital != null)
					returnVal.setTCIHospital(tciHospital);
			}
			
			// TCIBed [String]
			if (patientElectiveList.getTCIDetails() != null
					&& patientElectiveList.getTCIDetails().getTCIBed() != null)
			{
				returnVal.setTCIBed(patientElectiveList.getTCIDetails().getTCIBed());
			}
		
			// preadmissionNumber [String]
			if (patientElectiveList.getId() != null)
			{
				returnVal.setPreadmissionNumber(patientElectiveList.getId().toString());
			}
			
			// referrerType [SourceOfReferral lookup]
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getReferrerType() != null)
			{
				Integer lookupId = patientElectiveList.getReferral().getReferralDetails().getReferrerType().getId();
				SourceOfReferral sourceOfReferral = (SourceOfReferral)getLookupService().getLookupInstance(SourceOfReferral.class, lookupId);
				if (sourceOfReferral != null)
					returnVal.setReferrerType(sourceOfReferral);
			}
			
			// patientSuspensionStatus
			if (patientElectiveList.getSuspensions() != null)
			{
				List<SuspensionDetailsForPatientElectiveList> suspensionDetailsDo = patientElectiveList.getSuspensions();
				if (suspensionDetailsDo != null)
				{
					for (SuspensionDetailsForPatientElectiveList suspensionDetail : suspensionDetailsDo)
					{
						if (suspensionDetail.getEndDate() == null)
						{
							returnVal.setPatientSuspensionStatus("S");
							break;
						}
					}
				}
			}

			// cancerType
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getCancerType() != null)
			{
				Integer lookupId = patientElectiveList.getReferral().getCancerType().getId();
				CancerType cancerType = (CancerType)getLookupService().getLookupInstance(CancerType.class, lookupId);
				if (cancerType != null)
					returnVal.setCancerType(cancerType);
			}
			
			// referralUrgency
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getUrgency() != null)
			{
				Integer lookupId = patientElectiveList.getReferral().getUrgency().getId();
				ReferralUrgency referralUrgency = (ReferralUrgency)getLookupService().getLookupInstance(ReferralUrgency.class, lookupId);
				if (referralUrgency != null)
					returnVal.setReferralUrgency(referralUrgency);
			}
			
			// dateReferralReceived
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getDateReferralReceived() != null)
			{
				returnVal.setDateReferralReceived(new ims.framework.utils.Date(patientElectiveList.getReferral().getReferralDetails().getDateReferralReceived()));
			}
			
			//RTTStatusNationalCode
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getCurrentRTTStatus() != null
					&& patientElectiveList.getReferral().getCurrentRTTStatus().getRTTStatus() != null
					&& patientElectiveList.getReferral().getCurrentRTTStatus().getRTTStatus().getNationalCode() != null)
			{
				returnVal.setRTTStatusNationalCode(patientElectiveList.getReferral().getCurrentRTTStatus().getRTTStatus().getNationalCode().toString());
			}
			
			
			if (patientElectiveList.getReferral() != null
					&& patientElectiveList.getReferral().getReferralDetails() != null
					&& patientElectiveList.getReferral().getReferralDetails().getPractice() != null
					&& patientElectiveList.getReferral().getReferralDetails().getPractice().getPctCode() != null)
			{
				returnVal.setReferringPracticeCCGCode(patientElectiveList.getReferral().getReferralDetails().getPractice().getPctCode());
			}
			
			//WDEV-20680
			//If MsgType is A38, need to process TCI History and set any unprocessed TCI Details rows to processed
			if (MsgEventType.A38.equals(queueItem.getMsgType()))
			{
				if (patientElectiveList.getTCIHistory() != null)
				{
					java.util.List<TCIForPatientElectiveList> histPatElectListTCI = patientElectiveList.getTCIHistory();
					if (histPatElectListTCI != null)
					{
						for (TCIForPatientElectiveList tciDetail : histPatElectListTCI)
						{
							if (tciDetail.isCancelMsgProcessed() == null || tciDetail.isCancelMsgProcessed()  == Boolean.FALSE)
							{
								tciDetail.setCancelMsgProcessed(Boolean.TRUE);
								try
								{
									factory.save(patientElectiveList);
								}
								catch (StaleObjectException e)
								{
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
							}
						}
					}
				}
			}//WDEV-20680
				
		}
		
		return returnVal;
	}


	//WDEV-22490
//	public Booking_AppointmentVo getBookingAppointment(Integer sch_bookingId)
	public Booking_AppointmentVo getBookingAppointment(Integer appointmentId) //WDEV-22490
	{
		DomainFactory factory = getDomainFactory();
		//WDEV-22490
//		Booking_Appointment appt = (Booking_Appointment) factory.findFirst("select s1_1.firstAppointment from Sch_Booking as s1_1 left join s1_1.firstAppointment as b1_1 where s1_1.id =:schBookingId", new String[] {"schBookingId"}, new Object[] {sch_bookingId});
		Booking_Appointment appt = (Booking_Appointment) factory.findFirst("from Booking_Appointment as b1_1 where (b1_1.id = :apptId)", new String[] {"apptId"}, new Object[] {appointmentId}); //WDEV-22490
		return  Booking_AppointmentVoAssembler.create(appt);
	}
	
	// http://jira/browse/WDEV-20658 Taunton Add external id for appointments to support data migration
	public Booking_AppointmentVo getBookingAppointmentWithExternalId(String externalId)
	{
		DomainFactory factory = getDomainFactory();
		Booking_Appointment appt = (Booking_Appointment) factory.findFirst("select s1_1.firstAppointment from Sch_Booking as s1_1 " +
				"left join s1_1.firstAppointment as b1_1 " +
				"where s1_1.externalID =:externalId", new String[] {"externalId"}, new Object[] {externalId});
		return  Booking_AppointmentVoAssembler.create(appt);
	} //WDEV-20658


//	@Override
//	public void triggerUpdateAdmissionEvent(PASEventRefVo pasEvent,
//			MsgUpdateType type) throws StaleObjectException {
//		// TODO Auto-generated method stub
//		
//	}

}




