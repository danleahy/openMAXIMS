//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Florin Blindu using IMS Development Environment (version 1.80 build 5465.13953)
// Copyright (C) 1995-2015 IMS MAXIMS. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ServiceFunctionLiteVoCollection;
import ims.domain.DomainFactory;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.scheduling.domain.Profiles;
import ims.scheduling.domain.base.impl.BaseProfileMaintenanceImpl;
import ims.scheduling.domain.objects.ProfileRipple;
import ims.scheduling.domain.objects.Sch_Profile;
import ims.scheduling.vo.ProfileForProfileRippleVo;
import ims.scheduling.vo.ProfileRippleVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.domain.ProfileForProfileRippleVoAssembler;
import ims.scheduling.vo.domain.ProfileRippleVoAssembler;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.lookups.SchProfileType;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;

public class ProfileMaintenanceImpl extends BaseProfileMaintenanceImpl
{

	private static final long serialVersionUID = 1L;

	/**
	* Lists all profiles
	*/
	public ProfileShortVoCollection listProfiles(String name, ims.core.vo.ServiceShortVo service, ims.core.resource.place.vo.LocationRefVo hosp, ims.vo.interfaces.IMos listOwner, Boolean activeOnly, Boolean isOutpatient)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = " select distinct profile from Sch_Session as session join session.sch_Profile as profile "; //WDEV-23063
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " where ";
		StringBuffer condStr = new StringBuffer();
		
		String joinListOwner = "";
		
		condStr.append(andStr + " session.sessionDate > :TodayDate ");
		markers.add("TodayDate");
		Date todayDate = (new ims.framework.utils.Date()).getDate();
		values.add(todayDate);
		andStr = " and ";
		
		if(name != null)
		{
			condStr.append(andStr + " profile.name like :name ");
			markers.add("name");
			if (name.length() > 255)
			{
				values.add(name.substring(0, 255));
			}
			else
			{
				values.add("%" + name + "%");
			} 
			andStr = " and ";
		}
		
		if(service != null)
		{
			condStr.append(andStr + " profile.service.id = :serviceId");
			markers.add("serviceId");
			values.add(service.getID_Service());	
			andStr = " and ";
		}
		
		if(hosp != null)
		{
			String ids = getLocationsIdsForHospital(hosp);
			condStr.append(andStr + " profile.schLocation.id in ( " + ids + " ) ");
			andStr = " and ";
		}
		
		if(listOwner != null)
		{
			joinListOwner = " left join profile.listOwners as lo ";
			condStr.append(andStr + "lo.hCP.id = :idHcp");
			markers.add("idHcp");
			values.add(listOwner.getIMosHcpId());	
			andStr = " and ";
		}

		if(Boolean.TRUE.equals(activeOnly))
		{
			condStr.append(andStr + " profile.isActive = :activeOnly");
			markers.add("activeOnly");
			values.add(activeOnly);	
			andStr = " and ";
		}
	
		if(isOutpatient)
		{
			condStr.append(andStr + " profile.profileType.id = :OUTPATIENT_PROFILE ");
			markers.add("OUTPATIENT_PROFILE");
			values.add(SchProfileType.OUTPATIENT.getID());
			andStr = " and ";
		}
				
		hql += joinListOwner + condStr.toString();	
		
		//WDEV-23063
		ProfileShortVoCollection coll = ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(factory.find(hql, markers, values));
		coll.sort(SortOrder.ASCENDING);
		return coll;
	}

	private String getLocationsIdsForHospital(LocationRefVo hospital)
	{
		DomainFactory factory = getDomainFactory();
		Location doLocation = (Location) factory.getDomainObject(Location.class, hospital.getID_Location());

		ArrayList<Location> locations = new ArrayList<Location>();
		buildLocationsList(doLocation, locations);
		
		String ids = "";
		
		for (int i = 0; i < locations.size(); i++)
		{

			if (locations.get(i) == null || locations.get(i).getId() == null)
				continue;

			if (ids == "")
				ids += locations.get(i).getId().toString();
			else
				ids += ", " + locations.get(i).getId().toString();

		}	
		
		return ids;
	}
	
	private void buildLocationsList(Location location, ArrayList<Location> listItems)
	{
		if (Boolean.TRUE.equals(location.isIsActive()) && Boolean.FALSE.equals(location.isIsVirtual()))
		{
			listItems.add(location);
		}
		
		Iterator it = location.getLocations().iterator();
		
		while (it.hasNext())
		{
			Location doLocation = (Location) it.next();
			buildLocationsList(doLocation, listItems);
		}
	}
	
	public ims.core.vo.ServiceVoCollection listServices()
	{
		Profiles impl = (Profiles) getDomainImpl(ProfilesImpl.class);
		return impl.listServices();
	}

	public ims.core.vo.LocationLiteVoCollection listActiveHospitalsLite()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public ProfileRippleVo saveProfileRipple(ProfileRippleVo profileRippleToSave) throws StaleObjectException
	{
		if (profileRippleToSave == null)
			throw new CodingRuntimeException("Cannot save null record.");
		
		if (!profileRippleToSave.isValidated())
			throw new CodingRuntimeException("Record not validated.");
		
		DomainFactory domainFactory = getDomainFactory();
		
		ProfileRipple domProfileRipple = ProfileRippleVoAssembler.extractProfileRipple(domainFactory, profileRippleToSave);
		
		domainFactory.save(domProfileRipple);	
		return ProfileRippleVoAssembler.create(domProfileRipple);
	}

	public ProfileForProfileRippleVo getProfileForProfileRipple(Sch_ProfileRefVo profileRef)
	{
		if (profileRef == null || profileRef.getID_Sch_Profile() == null)
			throw new CodingRuntimeException("Cannot get ProfileForProfileRippleVo on null Id ");
		
		DomainFactory factory = getDomainFactory();
		
		Sch_Profile domProfile = (Sch_Profile)factory.getDomainObject(Sch_Profile.class, profileRef.getID_Sch_Profile());
		ProfileForProfileRippleVo voProfile = ProfileForProfileRippleVoAssembler.create(domProfile);
		
		return voProfile;
	}

	public ServiceFunctionLiteVoCollection listServiceFunctionByService(ServiceRefVo serviceRef)
	{
		Profiles impl = (Profiles) getDomainImpl(ProfilesImpl.class);
		return impl.listServiceFunctionByService(serviceRef);
	}

}
