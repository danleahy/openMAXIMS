//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.80 build 4198.17562)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.vo.BookTheatreSearchCriteriaVo;
import ims.clinical.vo.lookups.AnaestheticType;
import ims.core.clinical.domain.objects.Service;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Color;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.scheduling.domain.SortTheatreAppointments;
import ims.scheduling.domain.base.impl.BaseMoveAppointmentDialogImpl;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Sch_Session_Appointment_Order;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.TheatreBooking;
import ims.scheduling.helper.SlotGenerationUtils;
import ims.scheduling.vo.BookingAppointmentTheatreLiteVo;
import ims.scheduling.vo.BookingAppointmentTheatreVoCollection;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.MoveAppointmentDataVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.Sch_Session_Appointment_OrderVo;
import ims.scheduling.vo.SessionParentChildSlotRefVo;
import ims.scheduling.vo.SessionParentChildSlotRefVoCollection;
import ims.scheduling.vo.SessionParentChildSlotVo;
import ims.scheduling.vo.SessionSearchCriteriaVo;
import ims.scheduling.vo.SessionTheatreVo;
import ims.scheduling.vo.SessionTheatreVoCollection;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.domain.Sch_Session_Appointment_OrderVoAssembler;
import ims.scheduling.vo.domain.SessionParentChildSlotVoAssembler;
import ims.scheduling.vo.domain.SessionTheatreVoAssembler;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.scheduling.vo.lookups.TheatreType;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class MoveAppointmentDialogImpl extends BaseMoveAppointmentDialogImpl
{
	private static final int INCREMENT = 1;
	private static final int DECREMENT = 2;

	private static final long serialVersionUID = 1L;

	/**
	* list sessions for scheduling
	*/
	public ims.scheduling.vo.SessionTheatreVoCollection listSession(BookTheatreSearchCriteriaVo searchCriteria)
	{
		// all params must be set
		if (searchCriteria == null || searchCriteria.getFromDate() == null || searchCriteria.getToDate() == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listSession");

		String andStr = " ";
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		String procedureJoin = "";
		String listOwnerJoin = "";
		String anaesTypeJoin = "";
		String procedureCriteria = "";
		String listOwnerCriteria = "";
		String serviceCriteria = "";
		String locationCriteria = "";
		String theatreCriteria = "";
		String theatreTypeCriteria = "";
		String anaesTypeCriteria = "";
		String timeRequiredCriteria = "";
		
		if (searchCriteria.getPrimaryProcedure() != null && searchCriteria.getAdditionalProcedure() != null && !Boolean.TRUE.equals(searchCriteria.getMultiServiceCase()))
		{
			procedureCriteria += andStr + "(" + searchCriteria.getPrimaryProcedure().getIGenericItemInfoID() +" in (select proc.id from Sch_Session as sess left join sess.sch_Profile as profile left join profile.theatreDetails as theatreDet left join theatreDet.procedure as proc where (sess.id = session.id and proc.isActive = 1) )) ";
			procedureCriteria +=  "and (" + searchCriteria.getAdditionalProcedure().getIGenericItemInfoID() +" in (select proc.id from Sch_Session as sess left join sess.sch_Profile as profile left join profile.theatreDetails as theatreDet left join theatreDet.procedure as proc where (sess.id = session.id and proc.isActive = 1) )) ";
			andStr = " and ";
		}
		else if(searchCriteria.getPrimaryProcedure() != null)
		{
			procedureJoin = " left join session.sch_Profile as profile left join profile.theatreDetails as theatreDet left join theatreDet.procedure as proc ";
			procedureCriteria += andStr + " ( proc.id = :procId and proc.isActive = 1) ";
			markers.add("procId");
			values.add(searchCriteria.getPrimaryProcedure().getIGenericItemInfoID());
			andStr = " and ";
		}
		
		// WDEV-9946
		if (searchCriteria.getConsultant() != null && searchCriteria.getConsultant().getIMosHcpId() != null)
		{
			listOwnerJoin = " left join session.listOwners as listOwn ";
			listOwnerCriteria += andStr + " (listOwn.hcp.id = :hcpId) ";
			markers.add("hcpId");
			values.add(searchCriteria.getConsultant().getIMosHcpId());
			andStr = " and ";
		}
		
		if (searchCriteria.getService() != null)
		{
			markers.add("idService");
			values.add(searchCriteria.getService().getID_Service());
			serviceCriteria += andStr + " session.service.id = :idService";
			andStr = " and ";
		}
		
		if (searchCriteria.getTheatreIsNotNull())
		{
			markers.add("idTheatre");
			values.add(searchCriteria.getTheatre().getID_Location());
			serviceCriteria += andStr + " session.schLocation.id = :idTheatre";
			andStr = " and ";
		}
		else if (searchCriteria.getHospital() != null)
		{
			String ids = getLocationsIdsForHospital(searchCriteria.getHospital());
			locationCriteria += andStr + " session.schLocation.id in ( " + ids + " )";
			andStr = " and ";
			
		}
		
		if (searchCriteria.getListType() != null)
		{
			markers.add("listType");
			values.add(getDomLookup(searchCriteria.getListType()));
			theatreTypeCriteria += andStr + " session.listType = :listType ";
			andStr = " and ";
		}
		
		if (searchCriteria.getTheatreType() != null)
		{
			String selectiveCriteria = "";
			
			markers.add("theatType");
			values.add(getDomLookup(searchCriteria.getTheatreType()));
			selectiveCriteria = andStr + " session.theatreType = :theatType ";
			andStr = " and ";
			
			theatreTypeCriteria += selectiveCriteria;
		}
		
		// WDEV-9539
		// only do filtering on time remaining if we are not overbooking
		if (!Boolean.TRUE.equals(searchCriteria.getAllowOverBook()))
		{
			if (searchCriteria.getTimeRequired() != null)
			{
				procedureJoin += " left join session.theatreProceduresRemaining as theatreProcRemaining ";
				markers.add("timeRequired");
				values.add(searchCriteria.getTimeRequired());
				timeRequiredCriteria += andStr + " theatreProcRemaining.remainingTimeInMins >= :timeRequired ";
				andStr = " and ";
			}
		}
	

		markers.add("openId");
		values.add(Status_Reason.SLOTOPENED.getID());
		
		if (searchCriteria.getAnaestheticType() != null)
		{
			anaesTypeJoin = " left join session.anaestheticType as anaes ";
			anaesTypeCriteria += andStr + " anaes.instance = :anaesType ";
			markers.add("anaesType");
			values.add(getDomLookup(searchCriteria.getAnaestheticType()));	
			andStr = " and ";
		}
		else if (Boolean.TRUE.equals(searchCriteria.getNoGASessions()))
		{
			anaesTypeJoin = " left join session.anaestheticType as anaes ";
			anaesTypeCriteria += andStr + " anaes.instance <> :anaesType ";
			markers.add("anaesType");
			values.add(getDomLookup(AnaestheticType.GA));	
			andStr = " and ";
		}
		
		// mandatory fields
		markers.add("open");
		markers.add("startDate");
		markers.add("endDate");

		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		values.add(searchCriteria.getFromDate().getDate());
		values.add(searchCriteria.getToDate().getDate());
		
		DomainFactory factory = getDomainFactory();
		SessionTheatreVoCollection voCollSessionShort = new SessionTheatreVoCollection();

		markers.add("THEATRE_SESSION");
		values.add(SchProfileType.THEATRE.getID());
		List sessions = factory.find(" Select distinct session from Sch_Session as session " + procedureJoin + "left join session.theatreSlots as tSlot " + listOwnerJoin + anaesTypeJoin + " where " + procedureCriteria + listOwnerCriteria + serviceCriteria + locationCriteria  + theatreTypeCriteria + timeRequiredCriteria + anaesTypeCriteria + andStr + " session.sessionStatus = :open and session.sessionDate >= :startDate and session.sessionDate <= :endDate and session.sessionProfileType.id = :THEATRE_SESSION and (tSlot.status.id = :openId or tSlot is null) ", markers, values, 1000);// wdev-11777

		voCollSessionShort = SessionTheatreVoAssembler.createSessionTheatreVoCollectionFromSch_Session(sessions);

		return voCollSessionShort.sort();		
	}
	
	private String getLocationsIdsForHospital(LocationRefVo hospital)
	{
		//http://jira/browse/WDEV-21222 
		OrganisationAndLocation impl =(OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation(hospital.getBoId(), null, Boolean.TRUE,Boolean.FALSE,null,Boolean.TRUE);
	}
	
	/**
	 * method searches all available similar sessions that can be booked into when moving the appointment
	 */
	public SessionSearchCriteriaVo getSessionSearchCriteriaByAppointment(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			throw new CodingRuntimeException("appointment cannot be null in method getSessionSearchCriteriaByAppointment");
		
		SessionSearchCriteriaVo voSearchCriteria = new SessionSearchCriteriaVo();
		String hql = "select sess.service, sess.schLocation, sess.sessionDate, sess.theatreType, theatreBook from Booking_Appointment as appt left join appt.session as sess left join appt.theatreBooking as theatreBook where  appt.id = " + appointment.getID_Booking_Appointment();
		List item = getDomainFactory().find(hql);
		if(item != null && item.size() > 0)
		{
			Object[] arrObj = (Object[]) item.get(0);
			if(arrObj.length == 5)
			{
				if(arrObj[0] != null && arrObj[0] instanceof Service)
					voSearchCriteria.setSessionService(ServiceLiteVoAssembler.create((Service)arrObj[0]));
				if(arrObj[1] != null && arrObj[1] instanceof Location)
					voSearchCriteria.setSessionLocation(LocationLiteVoAssembler.create((Location)arrObj[1]));
				if(arrObj[2] != null && arrObj[2] instanceof java.util.Date)
					voSearchCriteria.setSessionDate(new Date((java.util.Date)arrObj[2]));
				if(arrObj[3] != null && arrObj[3] instanceof LookupInstance)
					voSearchCriteria.setSessionTheatreType(getTheatreTypeVoLookup((LookupInstance) arrObj[3]));
				if(arrObj[4] != null && arrObj[4] instanceof TheatreBooking);
				{
					TheatreBooking doBooking = (TheatreBooking) arrObj[4];
					if(doBooking.getProcedure() != null)
						voSearchCriteria.setSessionProcedure(ProcedureLiteVoAssembler.create(doBooking.getProcedure()));
					if(doBooking.getConsultant() != null)
						voSearchCriteria.setSessionConsultant(HcpLiteVoAssembler.create(doBooking.getConsultant()));
					if(doBooking.getAnaestheticType() != null)
						voSearchCriteria.setSessionAnaestheticType(getAnaesTypeVoLookup(doBooking.getAnaestheticType()));
				}				
			}
		}
		
		return voSearchCriteria;
	}

	private TheatreType getTheatreTypeVoLookup(LookupInstance theatreType)
	{
		if ( theatreType != null ) 
		{
			ims.scheduling.vo.lookups.TheatreType voLookup = new ims.scheduling.vo.lookups.TheatreType(theatreType.getId(),theatreType.getText(), theatreType.isActive(), null, null, Color.Default);
			ims.scheduling.vo.lookups.TheatreType parentVoLookup = voLookup;
			ims.domain.lookups.LookupInstance parent = theatreType.getParent();
			while (parent != null)
			{
				parentVoLookup.setParent(new ims.scheduling.vo.lookups.TheatreType(parent.getId(),parent.getText(), parent.isActive(), null, null, Color.Default));
				parentVoLookup = parentVoLookup.getParent();
				parent = parent.getParent();
			}			
			return voLookup;
		}
		return null;
	}
	
	private AnaestheticType getAnaesTypeVoLookup(LookupInstance anaesType)
	{
		if ( anaesType != null ) 
		{
			ims.clinical.vo.lookups.AnaestheticType voLookup = new ims.clinical.vo.lookups.AnaestheticType(anaesType.getId(),anaesType.getText(), anaesType.isActive(), null, null, Color.Default);
			ims.clinical.vo.lookups.AnaestheticType parentVoLookup = voLookup;
			ims.domain.lookups.LookupInstance parent = anaesType.getParent();
			while (parent != null)
			{
				parentVoLookup.setParent(new ims.clinical.vo.lookups.AnaestheticType(parent.getId(),parent.getText(), parent.isActive(), null, null, Color.Default));
				parentVoLookup = parentVoLookup.getParent();
				parent = parent.getParent();
			}			
			return voLookup;
		}
		return null;
	}

	/**
	 * moveAppointment - move an appointment from one SessionParentChildSlot to another 
	 * updating the status's and comments - also updating the Session,TheatreProcedures and SessionAppointmentOrder bo's
	 */
	public void moveAppointment(SessionParentChildSlotVo fromSlot, SessionParentChildSlotVo toSlot) throws StaleObjectException
	{
		if (fromSlot == null || fromSlot.getID_SessionParentChildSlot() == null)
			throw new CodingRuntimeException("fromSlot is null or id not provided in method moveAppointment");
		if (toSlot == null || toSlot.getID_SessionParentChildSlot() == null)
			throw new CodingRuntimeException("toSlot is null or id not provided in method moveAppointment");
		
		SessionParentChildSlot doFromSlot = (SessionParentChildSlot) getDomainFactory().getDomainObject(fromSlot);
		SessionParentChildSlot doToSlot = (SessionParentChildSlot) getDomainFactory().getDomainObject(toSlot);

		// WDEV-13222
		// Check if slots version or session slots have been modified and throw
		// a StaleObject exception if they have been modified
		if (fromSlot.getVersion_SessionParentChildSlot() < doFromSlot.getVersion())
			throw new StaleObjectException(doFromSlot);
		
		if (fromSlot.getSession().getVersion_Sch_Session() < doFromSlot.getSession().getVersion())
			throw new StaleObjectException(doFromSlot.getSession());
		
		if (toSlot.getVersion_SessionParentChildSlot() < doToSlot.getVersion())
			throw new StaleObjectException(doToSlot);
		
		if (toSlot.getSession().getVersion_Sch_Session() < doToSlot.getSession().getVersion())
			throw new StaleObjectException(doToSlot.getSession());

		
		
		Booking_Appointment doAppointmentToMove = doFromSlot.getAppointment();
		
		//////////////////////////////////////////////////////////////////////
		//update fromSlot
		Sch_Session doFromSession = doFromSlot.getSession();
		LookupInstance slotStatusToSet = getDomLookup(getAppropiateSessionSlotStatus(doFromSession)); //WDEV-18940
		
		doFromSlot.setAppointment(null);
		doFromSlot.setStatus(slotStatusToSet); //WDEV-18940 now checks session status before opening slot
		doFromSlot.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
		
		//release child slots
		if(doFromSession != null)
		{
			if(doFromSession.getParentChildSlots() != null)
			{
				java.util.Iterator it = doFromSession.getParentChildSlots().iterator();
				while(it.hasNext())
				{
					SessionParentChildSlot doSlot = (SessionParentChildSlot) it.next();
					if(doSlot.getParentSlot() != null && doSlot.getParentSlot().equals(doFromSlot))
					{
						doSlot.setParentSlot(null);
						doSlot.setStatus(slotStatusToSet); //WDEV-18940 now checks session status before opening slot
						doSlot.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
					}
				}	
			}
			//Increment Theatre Procedures Remaining
			modifyTheatreProceduresRemaining(doAppointmentToMove, doFromSession, INCREMENT);
			
			//update Session_Ap_Order bo
			if(fromSlot.getSessionIsNotNull())
			{
				SortTheatreAppointments impl = (SortTheatreAppointments) getDomainImpl(SortTheatreAppointmentsImpl.class);
				Sch_Session_Appointment_OrderVo voSessApptOrder = impl.getSessionApptOrderBySession(fromSlot.getSession());
				if(fromSlot.getAppointmentIsNotNull())
				{
					voSessApptOrder.getAppointments().remove(getItemIndex(voSessApptOrder, fromSlot.getAppointment()));
					//save Sch_Session_Appointment_Order
					getDomainFactory().save(Sch_Session_Appointment_OrderVoAssembler.extractSch_Session_Appointment_Order(getDomainFactory(), voSessApptOrder));
				}
			}
		}
		//end update fromSlot
		//////////////////////////////////////////////////////////////////////
		
		//////////////////////////////////////////////////////////////////////
		//update toSlot
		
		doToSlot.setAppointment(doAppointmentToMove);
		doToSlot.setStatus(getDomLookup(Status_Reason.APPOINTMENT_BOOKED));
		doToSlot.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
		
		//recalculate TCITime (calculated by duration b4 slot that has been moved from)
		if (doAppointmentToMove.getAppointmentTCITime() != null)
		{
			int duration = SlotGenerationUtils.calculateDuration(doAppointmentToMove.getApptStartTime(), doAppointmentToMove.getAppointmentTCITime());
			Time newTCITime = toSlot.getStartTime().copy();
			newTCITime.addMinutes(duration);
			doAppointmentToMove.setAppointmentTCITime(newTCITime.toString());
		}
				
		//appointment
		doAppointmentToMove.setAppointmentDate(doToSlot.getSessDateTime());
		doAppointmentToMove.setApptStartTime(doToSlot.getStartTime());
		if(doToSlot.getStartTime() != null && doAppointmentToMove.getCustomProcedureDuration() != null)
		{
			Time endTime = Booking_AppointmentVo.calculateEndTime( new Time(doToSlot.getStartTime()),doAppointmentToMove.getCustomProcedureDuration().intValue());
			if(endTime != null)
				doAppointmentToMove.setApptEndTime(endTime.toString());
		}
		
		// WDEV-13239
		// Update session slot in appointment
		doAppointmentToMove.setSession(doToSlot.getSession());
			
		//status
		Appointment_Status newStatus = new Appointment_Status();
		newStatus.setApptDate(doToSlot.getSessDateTime());
		newStatus.setApptTime(doToSlot.getStartTime());
		newStatus.setComment("Appointment Moved");
		newStatus.setStatus(getDomLookup(Status_Reason.BOOKED));
		newStatus.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
		newStatus.setStatusChangeDateTime(new DateTime().getJavaDate());
		//WDEV-23185
		if (doAppointmentToMove.getSession() != null)
		{
			newStatus.setSession(doAppointmentToMove.getSession());
		} //WDEV-23185
		
		doAppointmentToMove.getApptStatusHistory().add(newStatus);
		
		doAppointmentToMove.setCurrentStatusRecord(newStatus);
		
		doAppointmentToMove.setApptStatus(getDomLookup(Status_Reason.BOOKED));
		doAppointmentToMove.setApptStatusReas(getDomLookup(Status_Reason.APPOINTMENTMOVED));
		
			
		//Decrement Theatre Procedures Remaining
		Sch_Session doToSession = doToSlot.getSession();
		if(doToSession != null)
		{
			modifyTheatreProceduresRemaining(doAppointmentToMove, doToSession, DECREMENT);
			
			//update Session_Ap_Order
			if(toSlot.getSessionIsNotNull())
			{
				SortTheatreAppointments impl = (SortTheatreAppointments) getDomainImpl(SortTheatreAppointmentsImpl.class);
				Sch_Session_Appointment_OrderVo voSessApptOrder = impl.getSessionApptOrderBySession(toSlot.getSession());
				if(fromSlot.getAppointmentIsNotNull())
				{
					if(voSessApptOrder == null)
						voSessApptOrder = new Sch_Session_Appointment_OrderVo();
					if(voSessApptOrder.getAppointments() == null)
						voSessApptOrder.setAppointments(new BookingAppointmentTheatreVoCollection());
					
					voSessApptOrder.getAppointments().add(BookingAppointmentTheatreVoAssembler.create(doToSlot.getAppointment()));
					//save Sch_Session_Appointment_Order
					Sch_Session_Appointment_Order doSessApOrder = Sch_Session_Appointment_OrderVoAssembler.extractSch_Session_Appointment_Order(getDomainFactory(), voSessApptOrder);
					doSessApOrder.setSession(doToSession);

					getDomainFactory().save(doSessApOrder);
				}
			}
			
			//book childslots - calculate the child slots and then set the parent for each one to be the slot we are booking into
			SessionTheatreVo voSessionTheatre = SessionTheatreVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(toSlot.getSession()));
			SessionParentChildSlotRefVoCollection voCollChildSlots = voSessionTheatre.calculateChildSlots(toSlot, doAppointmentToMove.getCustomProcedureDuration(), fromSlot.getAppointment());
			
			if (voCollChildSlots != null)
			{
				for (SessionParentChildSlotRefVo voSlot : voCollChildSlots)
				{
					SessionParentChildSlot doSlot = (SessionParentChildSlot) getDomainFactory().getDomainObject(voSlot);
					doSlot.setParentSlot(doToSlot);
					doSlot.setStatus(getDomLookup(Status_Reason.BOOKED));
					doSlot.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
					//save slots
					getDomainFactory().save(doSlot);
				}
			}
		}
		//end update toSlot		
		//////////////////////////////////////////////////////////////////////
		
		//save everything at the top level
		getDomainFactory().save(doFromSession);
		getDomainFactory().save(doToSession);
	}

	/**
	 * @param doAppointmentToMove
	 * @param doToSession
	 */
	private void modifyTheatreProceduresRemaining(Booking_Appointment doAppointmentToMove, Sch_Session doToSession, int action)
	{
		if(doToSession != null)
		{
			if(doToSession.getTheatreProceduresRemaining() != null)
			{
				int newRemainingTime = doToSession.getTheatreProceduresRemaining().getRemainingTimeInMins();
				if(action == DECREMENT)
					newRemainingTime -= doAppointmentToMove.getCustomProcedureDuration();
				else if (action == INCREMENT)
					newRemainingTime += doAppointmentToMove.getCustomProcedureDuration();
				
				doToSession.getTheatreProceduresRemaining().setRemainingTimeInMins(newRemainingTime);
				
				/* WDEV-22949
				if(doToSession.getTheatreProceduresRemaining().getProcedureDetails() != null)
				{
					Iterator itProc = doToSession.getTheatreProceduresRemaining().getProcedureDetails().iterator();
					while(itProc.hasNext())
					{
						//increment/decrement number of procedures left
						TheatreProcedure doTProc =  (TheatreProcedure) itProc.next();
						if(doTProc.getProcedure() != null && doAppointmentToMove.getTheatreBooking() != null && doAppointmentToMove.getTheatreBooking().getProcedure() != null)
						{
							// WDEV-13239
							// Compare after ID - otherwise the evaluation will always fail 
							if(doTProc.getProcedure().getId().equals(doAppointmentToMove.getTheatreBooking().getProcedure().getId()))
							{
								if(doTProc.isIsLimited() != null && doTProc.isIsLimited())
								{
									if(action == DECREMENT)
										doTProc.setNumberOfProceduresLeft(doTProc.getNumberOfProceduresLeft() - 1);
									else if (action == INCREMENT)
										doTProc.setNumberOfProceduresLeft(doTProc.getNumberOfProceduresLeft() + 1);
								}
									
							}	
						}
					}
				}
				*/
			}
		}
	}
	
	/**
	 * @param voSessApptOrder 
	 * @param voSlot
	 * @return
	 */
	private int getItemIndex(Sch_Session_Appointment_OrderVo voSessApptOrder, BookingAppointmentTheatreLiteVo voTheatre)
	{
		for(int i=0;i<voSessApptOrder.getAppointments().size();i++)
		{
			if(voSessApptOrder.getAppointments().get(i).equals(voTheatre))
				return i;
		}
		
		throw new IndexOutOfBoundsException("When accessing Appointments");
	}
	
	private Status_Reason getAppropiateSessionSlotStatus(Sch_Session apptSessionDO) //WDEV-18940 
	{
		if (getDomLookup(Session_Status_and_Reason.BLOCKED).equals(apptSessionDO.getSessionStatus()))
			return Status_Reason.BLOCKED;
		else if (getDomLookup(Session_Status_and_Reason.CANCELLED).equals(apptSessionDO.getSessionStatus()))
			return Status_Reason.CANCELLED;
		else if (isSessionFinalised(apptSessionDO))
			return Status_Reason.CLOSED;
		
		return Status_Reason.SLOTOPENED;
	}
	
	private boolean isSessionFinalised(Sch_Session session)
	{
		Long sessionIsFinalised = getDomainFactory().countWithHQL("select count(sessOrder.id) from Sch_Session_Appointment_Order as sessOrder left join sessOrder.session as sess where sess.id = :sessionID and sessOrder.finalisedBy is not null and sessOrder.finalisedDateTime is not null ) ", new String[] {"sessionID"}, new Object[] {session.getId()});
		
		if (sessionIsFinalised != null && sessionIsFinalised > 0)
			return true;
		
		return false;
	}

	public MoveAppointmentDataVo getMoveAppointmentDialogData(SessionParentChildSlotRefVo fromSlot, SessionParentChildSlotRefVo toSlot)
	{
		if (fromSlot == null)
			throw new CodingRuntimeException("fromSlot cannot be null in method getMoveAppointmentDialogData");
		
		MoveAppointmentDataVo voData = new MoveAppointmentDataVo();
		
		voData.setFromSlot(SessionParentChildSlotVoAssembler.create((SessionParentChildSlot) getDomainFactory().getDomainObject(fromSlot)));
		if(toSlot != null)
			voData.setToSlot(SessionParentChildSlotVoAssembler.create((SessionParentChildSlot) getDomainFactory().getDomainObject(toSlot)));
	
		return voData;
	}

	public SessionTheatreVo getSession(Sch_SessionRefVo session)
	{
		if (session == null || !session.getID_Sch_SessionIsNotNull())
			return null;
		
		return SessionTheatreVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(Sch_Session.class, session.getID_Sch_Session()));
	}

	public SessionTheatreVo getSessionForAppointment(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;
		
		String query = "select sess from Booking_Appointment as appt left join appt.session as sess where appt.id = :apptID ";

		List list = getDomainFactory().find(query, new String[] { "apptID" }, new Object[] { appointment.getID_Booking_Appointment()});
		
		if (list == null || list.isEmpty())
			return null;
		
		return SessionTheatreVoAssembler.createSessionTheatreVoCollectionFromSch_Session(list).get(0);
		
	}
}
