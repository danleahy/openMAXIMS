//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.30 build 2012.21169)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.helper.ISessionGenerationHelper;
import ims.RefMan.domain.objects.CatsReferral;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.ClassConfig;
import ims.configuration.Configuration;
import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.domain.DomainFactory;
import ims.domain.DomainFactory.ORDERMODE;
import ims.domain.DomainSession;
import ims.domain.SessionData;
import ims.domain.Transaction;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.DomainImpl;
import ims.framework.SessionConstants;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.Time;
import ims.scheduling.domain.DateSelectionEditDialog;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.ExclusionDates;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.DirectoryOfServiceSessionSlot;
import ims.scheduling.domain.objects.ProfileParentChildSlot;
import ims.scheduling.domain.objects.ProfileRipple;
import ims.scheduling.domain.objects.ProfileTheatreTCISlot;
import ims.scheduling.domain.objects.Profile_Exc_Date;
import ims.scheduling.domain.objects.Profile_ListOwner;
import ims.scheduling.domain.objects.Profile_Slot;
import ims.scheduling.domain.objects.Sch_Profile;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionTheatreProceduresRemanining;
import ims.scheduling.domain.objects.SessionTheatreTCISlot;
import ims.scheduling.domain.objects.Session_Exc_Time;
import ims.scheduling.domain.objects.Session_ListOwner;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.helper.CABRequests;
import ims.scheduling.helper.SlotGenerationUtils;
import ims.scheduling.vo.DirectoryOfServiceVo;
import ims.scheduling.vo.ExclusionDatesVo;
import ims.scheduling.vo.ProfileShortVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.SessionForSlotsPreviewVo;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.domain.SessionForSlotsPreviewVoAssembler;
import ims.scheduling.vo.lookups.BookingSource;
import ims.scheduling.vo.lookups.Profile_Interval_Type;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Sched_Profile_Type;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.SlotType;
import ims.scheduling.vo.lookups.Status_Reason;
import imsmaxims.common.ImsDate;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class GenerateSessionsImpl extends DomainImpl implements ims.scheduling.domain.GenerateSessions, ISessionGenerationHelper, DateSelectionEditDialog, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;

	public ims.scheduling.vo.DirectoryOfServiceVoCollection listDos()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		DirectoryOfServiceVo voDosFilter = new DirectoryOfServiceVo();
		voDosFilter.setIsActive(Boolean.TRUE);
		return impl.listDirectoryOfService(voDosFilter);
	}

	public ims.scheduling.vo.ProfileShortVoCollection listProfile(ims.scheduling.vo.DirectoryOfServiceVo directoryOfService, ims.core.vo.ServiceFunctionVo function)
	{
		DomainFactory factory = getDomainFactory();

		List<?> profiles = null;

		if (directoryOfService != null && function != null)
		{
			String hql = " Select profile from Sch_Profile profile" + " join profile.directoryOfServices as dos" + " join profile.functions as servfunc" + " where dos.id = :idDos" + " and servfunc.id = :idServFunc";

			profiles = factory.find(hql, new String[]{"idDos", "idServFunc"}, new Object[]{directoryOfService.getID_DirectoryofService(), function.getID_ServiceFunction()});
		}
		else
		{
			profiles = factory.find("from Sch_Profile", 1000);
		}
		return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles).sort();
	}
	//WDEV-20052 overloaded the method for generation. This method is called by the System job
	public Integer generateSessions(ProfileShortVo profile, Date fromDate, Date toDate, DomainSession session) throws DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		
		if (session != null)
		{
			try
			{
				factory.setDomainSession(session);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		Sch_Profile doProfile = (Sch_Profile) factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());		
		int noSessions = 0;
		try
		{
			noSessions = generateProfileSlots(factory, doProfile, fromDate, toDate, BookingSource.INTERNAL);
			
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("An error occurred while generating session slots " + e.getMessage(), e);
		}
		return new Integer(noSessions);
	}
	//WDEV-20052 --- ends here
	public Integer generateSessions(ProfileShortVo profile, Date fromDate, Date toDate) throws DomainInterfaceException
	{
		return generateSessions(profile, fromDate, toDate, null);
	}

	/**
	 * <p>
	 * generateSessionSlots This method will generate session slots for the
	 * given profile for the directory of service specified for the given date
	 * range
	 * 
	 * @param DOSServiceId -
	 *            The service the slots are required for
	 * @param fromDate -
	 *            The start date to generate slots from
	 * @param toDate -
	 *            The date up to which available slots are to be generated
	 *            </p>
	 * @throws Exception
	 * 
	 */
	public Integer generateSessionSlots(String dosServiceId, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws DomainInterfaceException
	{
		Transaction tran = null;
		try
		{

			DomainFactory factory = getDomainFactory();

			// wdev-4687 For every profile, check if we need to generate sessions
			List profileList = factory.find(" Select p from Sch_Profile p join p.profileSlots as slots join slots.directoryOfServices as sDos where sDos.directoryOfService.doSId = :dos and slots.isActive = :active ", new String[]{"dos", "active"}, new Object[]{dosServiceId, Boolean.TRUE});
			if (profileList == null || profileList.size() == 0)
				return (new Integer(0));

			// Check to see if we need to generate some more slots
			boolean generateRequired;
			int numGenerated=0;
			tran = factory.beginTransaction();

			for (int i=0; i<profileList.size(); i++)
			{
				ims.framework.utils.Date fromDT = new ims.framework.utils.Date(fromDate);
				
				Sch_Profile prof = (Sch_Profile) profileList.get(i);
				
				generateRequired=false;
				
				List lastDateList = factory.find(" Select max(s.sessionDate) from Sch_Session s join s.sessionSlots as slots join slots.directoryOfServices as slotDos where slotDos.directoryOfService.doSId = :dos and slots.isActive = :active and s.sch_Profile = :profile", new String[]{"dos", "active", "profile"}, new Object[]{dosServiceId, Boolean.TRUE, prof});
				if (lastDateList == null || lastDateList.size() == 0)
					generateRequired = true;
				if (lastDateList.size() == 1)
				{
					java.util.Date latestDate = (java.util.Date) lastDateList.get(0);
					if (latestDate == null || latestDate.before(new ims.framework.utils.Date(toDate).getDate()))
					{
						generateRequired = true;
					// 	If latestDate > fromDate, increase fromDate to this value
						if (latestDate != null && latestDate.after(new ims.framework.utils.Date(fromDate).getDate()))
						{
							fromDT = new ims.framework.utils.Date(latestDate);
						}
					}
				}

				if (generateRequired)
				{
					// 	As this method is called from the web service, we are going
					// 	to start a transation
					numGenerated+=generateProfileSlots(factory, prof, fromDT, toDate, BookingSource.CABGW);
				}
			}
			tran.commit();
			factory.setTransaction(null); // This will prevent DomainImplProxyHandler attempting to commit again

			return new Integer(numGenerated);


		}
		catch (Exception e)
		{
			if (tran != null)
				tran.rollback();
			throw new DomainInterfaceException("Exception occurred generating session slots " + e.getMessage(), e);
		}
	}

	public int generateSlots(DomainFactory factory, String dosServiceId, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws DomainException
	{
		int noRecordsGenerated = 0;
		List profileList = factory.find(" Select p from Sch_Profile p join p.profileSlots as slots join slots.directoryOfServices as sDos where sDos.doSId = :dos and slots.isActive = :active ", new String[]{"dos", "active"}, new Object[]{dosServiceId, Boolean.TRUE});

		for (int i = 0; i < profileList.size(); i++)
		{
			Sch_Profile profile = (Sch_Profile) profileList.get(i);

			noRecordsGenerated += generateProfileSlots(factory, profile, fromDate, toDate, BookingSource.CABGW);
		}

		return noRecordsGenerated;
	}

	/**
	 * createSession
	 * <p>
	 * Create a session from the profile for the given date
	 * 
	 * @param profile
	 * @param dt
	 *            </p>
	 * @param source
	 * @throws DomainException
	 */
	private Sch_Session createSession(DomainFactory factory, Sch_Profile profile, String dt, BookingSource source, Boolean checkAlreadyGeneratedSessions) throws DomainException  //WDEV-21137
	{

		try
		{
			// If there is already a session generated for that day for the profile we return
			if (checkAlreadyGeneratedSessions)
			{
				long result = factory.countWithHQL("select count(s.id) from Sch_Session s where s.isActive = :active and s.sch_Profile.id = :profile and s.sessionDate = :sessDate", new String[] { "active", "profile", "sessDate" }, new Object[] { Boolean.TRUE, profile.getId(), new ims.framework.utils.Date(dt, DateFormat.ISO).getDate()});
				
				if (result > 0)
					return null;
			}

			Sch_Session session = new Sch_Session();

			session.setName(profile.getName());
			//WDEV-18369
			session.setConsMediaType(profile.getConsMediaType());
			session.setDescription(profile.getDescription());
			session.setSessionDate(new ims.framework.utils.Date(dt, DateFormat.ISO).getDate());
			session.setStartTm(profile.getStartTm());
			session.setEndTm(profile.getEndTm());
			session.setService(profile.getService());
			session.setSessionStatus(factory.getLookupInstance(Session_Status_and_Reason.TYPE_ID, Session_Status_and_Reason.OPEN.getID()));
			session.setIsFixed(profile.isIsFixed());
			session.setDuration(SlotGenerationUtils.calculateDuration(profile.getStartTm(), profile.getEndTm()));
			session.setSch_Profile(profile);
			session.setSchLocation(profile.getSchLocation());
			//WDEV-19518 
			session.setCaseNoteFolderNotRequired(profile.isCaseNoteFolderNotRequired());
			session.setCaseNoteFolderLocation(profile.getCaseNoteFolderLocation() != null && Boolean.TRUE.equals(profile.getCaseNoteFolderLocation().isCaseNoteFolderLocation()) ? profile.getCaseNoteFolderLocation() : null); //WDEV-19631
			//WDEV-19518 -------end
			session.setSessionType(factory.getLookupInstance(Sched_Profile_Type.TYPE_ID, Sched_Profile_Type.SINGLE.getID()));
			session.setMinInt(profile.getMinInt());
			session.setRoundAttTime(profile.getRoundAttTime());
			session.setLastAppInterval(profile.getLastAppInterval());
			session.setMaxNoAppts(profile.getMaxNoAppts());
			//wdev-19419
			session.setListType(profile.getListType());
			session.setResponsibleHCP(profile.getResponsibleHCP());
			//--------
			session.setListOwners(SlotGenerationUtils.copyListOwners(profile.getListOwners()));
			session.setExclusionTimes(SlotGenerationUtils.copyExclusionTimes(profile.getExclusionTimes()));
			
			session.setSessionProfileType(profile.getProfileType());
			
			//WDEV-12918
			session.setSlotType(profile.getSlotType()); 
			//standard copy produced shared reference 
			session.setAnaestheticType(new ArrayList()); 
			for (Object lkp : profile.getAnaestheticType())
				session.getAnaestheticType().add(lkp);
			
			//WDEV-7323
			if (getDomLookup(SchProfileType.THEATRE).equals(profile.getProfileType()))
			{
				//WDEV-11777
				//WDEV-12918
				if(session.getSlotType() != null)
				{
					if(session.getSlotType().equals(getDomLookup(SlotType.THEATRETCITIME)))
						session.setTheatreSlots(generateTheatreSlots(profile.getProfileTheatreSlots(), dt, session));
					else if(session.getSlotType().equals(getDomLookup(SlotType.SLOTS)))
						session.setParentChildSlots(generateParentChildSlots(profile.getParentChildSlots(), dt, session));
				}
				
				session.setTheatreProceduresRemaining(generateTheatreDetails(profile.getTheatreDetails(), dt, session));
				session.setTheatreType(profile.getTheatreType());
				session.setTotalSlots(0);
				session.setRemainingSlots(0);	
			}	
			else
			{
				if(!profile.isIsFixed())
				{
					session.setSessionActivities(SlotGenerationUtils.copyActivities(profile.getProfileActivities()));
					session.setTotalSlots(0);
					session.setRemainingSlots(0);	
					
					if (ConfigFlag.DOM.PROFILE_FLEXIBLE_TYPE.getValue().equals("WITHOUT_SLOTS"))
					{

						// WDEV-8793
						// 1)Calculate Time Remaining on Generate Sessions for Flexible Slots
						session.setRemainingTime(SlotGenerationUtils.calculateDuration(session.getStartTm(), session.getEndTm()));

						// WDEV-11569 for flexible sessions reduce the time remaining by the exclusion time
						if (session.getExclusionTimes() != null)
						{
							int exclusionDuration = 0;
							Iterator it = session.getExclusionTimes().iterator();
							while (it.hasNext())
							{
								Session_Exc_Time doExclTime = (Session_Exc_Time) it.next();
								exclusionDuration += SlotGenerationUtils.calculateDuration(doExclTime.getStartTime(), doExclTime.getEndTime());
							}
							session.setRemainingTime(session.getRemainingTime() - exclusionDuration);
						}

						// WDEV-11731
						session.setMaxContinuousAvailableMins(session.getRemainingTime());
					}
					//WDEV-19497
					else if (ConfigFlag.DOM.PROFILE_FLEXIBLE_TYPE.getValue().equals("WITH_SLOTS"))
					{
						session.setParentChildSlots(generateParentChildSlotsForOutpatientFlexible(profile.getParentChildSlots(), dt, session));
					}
				}
				else
				{
					session.setDirectoryofServices(SlotGenerationUtils.copyDirectoryOfServices(profile.getDirectoryOfServices()));
					session.setSessionSlots(createSlots(profile.getProfileSlots(), dt, source, session));
					session.setTotalSlots(new Integer(session.getSessionSlots().size()));
					session.setRemainingSlots(new Integer(session.getSessionSlots().size()));
				}
			}

			
			session.setIsModified(Boolean.FALSE);
			session.setIsAdHocSession(Boolean.FALSE);
			session.setIsActive(Boolean.TRUE);
			session.setPASClinic(profile.getPASClinic());
			return session;
		}
		catch (ParseException e)
		{
			throw new DomainException("ParseException occurred parsing date - " + e.getMessage(), e);
		}
	}
	
	private Set generateParentChildSlotsForOutpatientFlexible(Set parentChildSlots, String dt, Sch_Session session) throws ParseException
	{
		
		Set parentChildSessionSlots = new HashSet();
		Iterator it = parentChildSlots.iterator();
		
		while (it.hasNext())
		{
			ProfileParentChildSlot profSlot = (ProfileParentChildSlot) it.next();
			
			if (Boolean.TRUE.equals(profSlot.isIsActive()))
			{
				for (int i = 0; i < profSlot.getNumberSlotsReq().intValue(); i++)
				{
					
					int startTime = new Integer(profSlot.getStartTime().replaceAll(":", "")).intValue();
					String newStartTime = String.valueOf(startTime);
					
					if (newStartTime.length() == 3)
						newStartTime = "0" + newStartTime;
					if (i > 0)
						newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, profSlot.getDuration().intValue(), i);
					else
						newStartTime = profSlot.getStartTime();
					
					if(isSlotTimeWithinExclusionTimes(newStartTime, session.getExclusionTimes(), profSlot.getDuration()))
						continue;
					
					for (int j = 0; j < profSlot.getNoOfInstances().intValue(); j++)
					{
						SessionParentChildSlot doSessSlot = new SessionParentChildSlot();
						
						doSessSlot.setIsActive(Boolean.TRUE);
						doSessSlot.setProfileSlot(profSlot);
						
						ims.framework.utils.Date sessDate = new ims.framework.utils.Date(dt, DateFormat.ISO);
						doSessSlot.setSessDateTime(sessDate.getDate());
						
						doSessSlot.setSession(session);
						doSessSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						doSessSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
						doSessSlot.setStartTime(newStartTime);
						doSessSlot.setDuration(profSlot.getDuration());
						doSessSlot.setPriority(profSlot.getPriority());
						
						// Get the responsible list owner from the session
						doSessSlot.setSlotResp(SlotGenerationUtils.getSessionListOwner(session, profSlot.getSlotResp()));
						
						parentChildSessionSlots.add(doSessSlot);
					}
				}
			}
		}
		
		return parentChildSessionSlots;
	}

	private Set generateParentChildSlots(Set parentChildSlots, String dt, Sch_Session session) throws ParseException
	{
		Set parentChildSessionSlots = new  HashSet();
		
		Iterator it = parentChildSlots.iterator();
		while (it.hasNext())
		{
			ProfileParentChildSlot doProfTSlot = (ProfileParentChildSlot) it.next();
			int count = 0;
			if(doProfTSlot.getNoOfInstances() != null)
				count = doProfTSlot.getNoOfInstances();
			
			for(int i=0; i<count; i++)
			{
				if(doProfTSlot.isIsActive())
				{
					int startTime = new Integer(doProfTSlot.getStartTime().replaceAll(":", "")).intValue();
					String newStartTime = String.valueOf(startTime);
					if (newStartTime.length() == 3)
						newStartTime = "0" + newStartTime;
					if (i > 0)
						newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, doProfTSlot.getDuration().intValue(), i);
					else
						newStartTime = doProfTSlot.getStartTime();
					
					//WDEV-12918
					if(isSlotTimeWithinExclusionTimes(newStartTime, session.getExclusionTimes(), doProfTSlot.getDuration()))
						continue;
					
					SessionParentChildSlot doSessTSlot = new SessionParentChildSlot();
					
					doSessTSlot.setIsActive(doProfTSlot.isIsActive());
					doSessTSlot.setProfileSlot(doProfTSlot);
					
					ims.framework.utils.Date sessDate = new ims.framework.utils.Date(dt, DateFormat.ISO);
					doSessTSlot.setSessDateTime(sessDate.getDate());
					
					doSessTSlot.setSession(session);
					doSessTSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStartTime(newStartTime);
					doSessTSlot.setDuration(doProfTSlot.getDuration());
			
					parentChildSessionSlots.add(doSessTSlot);
				}
			}
		}
		return parentChildSessionSlots;
	}

	private Set generateTheatreSlots(Set profileTheatreSlots, String dt, Sch_Session session) throws ParseException
	{
		Set theatreSessionSlots = new  HashSet();

		Iterator it = profileTheatreSlots.iterator();
		while (it.hasNext())
		{
			ProfileTheatreTCISlot doProfTCISlot = (ProfileTheatreTCISlot) it.next();
			
			int count = 1;
			if(doProfTCISlot.getNoOfInstances() != null)
				count = doProfTCISlot.getNoOfInstances();
			
			for(int i=0; i<count; i++)
			{
				if(doProfTCISlot.isIsActive())
				{						
					SessionTheatreTCISlot doSessTSlot = new SessionTheatreTCISlot();
					
					doSessTSlot.setIsActive(doProfTCISlot.isIsActive());
					doSessTSlot.setProfileSlot(doProfTCISlot);
					
					ims.framework.utils.Date sessDate = new ims.framework.utils.Date(dt, DateFormat.ISO);
					doSessTSlot.setSessDateTime(sessDate.getDate());
					
					doSessTSlot.setSession(session);
					doSessTSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setToComeInTime(doProfTCISlot.getToComeInTime());
			
					theatreSessionSlots.add(doSessTSlot);
				}
			}
		}
		return theatreSessionSlots;
	}

	private int calculateDuration(Time startTime, Time endTime)
	{
		if (startTime == null || endTime == null)
			throw new CodingRuntimeException("startTime or endTime is null in method calculateDuration");
	
		int mins = endTime.getTotalMinutes() - startTime.getTotalMinutes();
		if(endTime.isLessThan(startTime))	
		{
			Time midNight = new Time(23,59);
			mins = midNight.getTotalMinutes() + 1 - startTime.getTotalMinutes() + endTime.getTotalMinutes(); 
		}
			
		return mins;
	}

	private SessionTheatreProceduresRemanining generateTheatreDetails(Set theatreDetails, String dt, Sch_Session session)
	{
		SessionTheatreProceduresRemanining doTheatreProcsRemaining = new SessionTheatreProceduresRemanining();
		//remaining time		
		doTheatreProcsRemaining.setRemainingTimeInMins(SlotGenerationUtils.calculateDuration(session.getStartTm(), session.getEndTm()));
		
		return doTheatreProcsRemaining;
	}

	/**
	 * @param source
	 * @param profile
	 * @return
	 * @throws ParseException
	 */
	private Set createSlots(Set profileSlots, String sessionDate, BookingSource source, Sch_Session session) throws ParseException
	{
		Set sessSlots = new HashSet();
		Iterator it = profileSlots.iterator();
		while (it.hasNext())
		{
			Profile_Slot profSlot = (Profile_Slot) it.next();
			if (Boolean.TRUE.equals(profSlot.isIsActive()))
			{
				for (int i = 0; i < profSlot.getNumberSlotsReq().intValue(); i++)
				{

					int startTime = new Integer(profSlot.getStartTm().replaceAll(":", "")).intValue();
					String newStartTime = String.valueOf(startTime);
					if (newStartTime.length() == 3)
						newStartTime = "0" + newStartTime;
					if (i > 0)
						newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, profSlot.getDuration().intValue(), i);
					else
						newStartTime = profSlot.getStartTm();
					for (int j = 0; j < profSlot.getNoOfInstances().intValue(); j++)
					{
						if(isSlotTimeWithinExclusionTimes(newStartTime, session.getExclusionTimes(), profSlot.getDuration()))
							continue;

						Session_Slot sessSlot = new Session_Slot();

						sessSlot.setIsActive(Boolean.TRUE);
						sessSlot.setActivity(profSlot.getActivity());
						sessSlot.setStartTm(newStartTime);
						// Dealloc date should be set to session date - no of
						// dealloc days
						ims.framework.utils.Date sessDate = new ims.framework.utils.Date(sessionDate, DateFormat.ISO);
						if (profSlot.getDeallocNoOfDays() != null)
						{
							ims.framework.utils.Date deallocDate = new ims.framework.utils.Date(sessDate);
							sessSlot.setDeallocDate(deallocDate.addDay(-profSlot.getDeallocNoOfDays().intValue()).getDate());
						}
						sessSlot.setDirectoryOfServices(SlotGenerationUtils.copySlotDirectoryOfServices(profSlot.getDirectoryOfServices(), sessSlot));
						sessSlot.setFunctions(SlotGenerationUtils.copyFunctions(profSlot.getFunctions()));
						sessSlot.setDuration(profSlot.getDuration());
						sessSlot.setPriority(profSlot.getPriority());
						sessSlot.setProfileSlot(profSlot);
						sessSlot.setInstanceNo(new Integer(sessSlots.size() + 1));
						sessSlot.setSessDateTime(sessDate.getDate());
						sessSlot.setBookingSource(getDomLookup(source));
						sessSlot.setDirectAccessSlot(profSlot.getDirectAccessSlot());
						sessSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						sessSlot.setSession(session);

						// Get the responsible list owner from the session
						sessSlot.setSlotResp(SlotGenerationUtils.getSessionListOwner(session, profSlot.getSlotResp()));
						sessSlots.add(sessSlot);
					}
				}

			}
		}
		return sessSlots;
	}

	private boolean isSlotTimeWithinExclusionTimes(String newStartTime, Set exclusionTimes, Integer duration)
	{
		Time proposedSlotTime = new Time(newStartTime);
		Iterator it = exclusionTimes.iterator();
		while(it.hasNext())
		{
			Session_Exc_Time exTime = (Session_Exc_Time) it.next();
			Time exStartTime = new Time(exTime.getStartTime());
			Time exEndTime = new Time(exTime.getEndTime());
			
			Time proposedSlotEndTime = (Time) proposedSlotTime.clone();
			proposedSlotEndTime.addMinutes(duration);
			
			if((proposedSlotTime.isGreaterOrEqualThan(exStartTime) || proposedSlotEndTime.isGreaterThan(exStartTime)) && proposedSlotTime.isLessThan(exEndTime) )
				return true;
		}
		
		return false;
	}

	/**
	 * removeExclusions
	 * <p>
	 * This method will check the exclusion dates for the profiles, and exclude
	 * those from the list generated in the linked list.
	 * 
	 * @param profile
	 * @param generatedDays
	 *            </p>
	 * @throws DomainException
	 */
	private void removeExclusions(Sch_Profile profile, LinkedList generatedDays) throws DomainException
	{
		try
		{
			Iterator it = profile.getExclusionDates().iterator();
			while (it.hasNext())
			{
				Profile_Exc_Date exclDates = (Profile_Exc_Date) it.next();
				ImsDate startDt = new ImsDate(exclDates.getStartDate().toString());
				ImsDate endDt = new ImsDate(exclDates.getEndDate().toString());
				startDt.removeSpecifiedDates(generatedDays, startDt, endDt);
			}
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred removing exclusion dates - " + e.getMessage(), e);
		}

	}

	/**
	 * Generate the list of days for this profile
	 * 
	 * @param profile -
	 *            profile Details
	 * @param fromDate -
	 *            Generate days from this date
	 * @param toDate -
	 *            Generate days up to this date
	 * @param generatedDays -
	 *            LinkedList to add days to
	 * @throws DomainException
	 * 
	 */
	private void generateDaysList(Sch_Profile profile, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate, LinkedList generatedDays) throws DomainException
	{
		try
		{

			if (!toDate.getDate().after(fromDate.getDate()))
				throw new DomainException("ToDate MUST be after FromDate");

			ImsDate fromDt = new ImsDate(fromDate.toString(DateFormat.ISO));
			ImsDate toDt = new ImsDate(toDate.toString(DateFormat.ISO));

			if (profile.getIntervalType().getId() == Profile_Interval_Type.WEEKLY.getId() && profile.getIntervalSize() != null)
			{
				// Call listWeeklyDates
				// Loop trough all day flag attributes and call listMonthlyDates
				// when set to true
				if (profile.isIsSchSun().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 1, profile.getIntervalSize().intValue()));
				if (profile.isIsSchMon().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 2, profile.getIntervalSize().intValue()));
				if (profile.isIsSchTue().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 3, profile.getIntervalSize().intValue()));
				if (profile.isIsSchWed().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 4, profile.getIntervalSize().intValue()));
				if (profile.isIsSchThur().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 5, profile.getIntervalSize().intValue()));
				if (profile.isIsSchFri().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 6, profile.getIntervalSize().intValue()));
				if (profile.isIsSchSat().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 7, profile.getIntervalSize().intValue()));
			}
			else if (profile.getIntervalType().getId() == Profile_Interval_Type.MONTHLY.getId())
			{
				// For Monthly Intervals, we need to check if valid for the
				// first
				// week, and if so, which days for the first week
				if (profile.isIsFirstInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 1, fromDt, toDt));
				if (profile.isIsSecondInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 2, fromDt, toDt));
				if (profile.isIsThirdInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 3, fromDt, toDt));
				if (profile.isIsFourthInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 4, fromDt, toDt));
				if (profile.isIsFifthInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 5, fromDt, toDt));

			}
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred generating days list - " + e.getMessage(), e);
		}

	}

	private LinkedList checkMonthly(Sch_Profile profile, int instance, ImsDate fromDt, ImsDate toDt) throws Exception
	{
		LinkedList daysList = new LinkedList();

		if (profile.isIsSchSun().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 1, profile.getIntervalSize().intValue()));
		if (profile.isIsSchMon().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 2, profile.getIntervalSize().intValue()));
		if (profile.isIsSchTue().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 3, profile.getIntervalSize().intValue()));
		if (profile.isIsSchWed().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 4, profile.getIntervalSize().intValue()));
		if (profile.isIsSchThur().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 5, profile.getIntervalSize().intValue()));
		if (profile.isIsSchFri().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 6, profile.getIntervalSize().intValue()));
		if (profile.isIsSchSat().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 7, profile.getIntervalSize().intValue()));

		return daysList;
	}

	/**
	 * @param sess
	 * @param profile
	 * @param source
	 * @param fromDate
	 * @param toDate
	 * @return
	 * @throws DomainException
	 */
	public int generateProfileSlots(DomainFactory factory, Sch_Profile profile, ims.framework.utils.Date fromDt, ims.framework.utils.Date toDt, BookingSource source) throws DomainException
	{
		//WDEV-8531
		if(profile.isIsActive() != null && !profile.isIsActive())
			return 0;
		
		// WDEV-20625 - only generate when the profile is marked as ready for generation
		if (profile.isReadyToGenerate() == null || profile.isReadyToGenerate().booleanValue() == false)
			return 0;
		
		// WDEV-20625 - classes removed from audit to be stored in a list for reference later
		ArrayList<String> auditItemsRemoved = pauseSessionAuditing();
		Transaction transaction = null; //WDEV-22989 - performance updates
		try
		{
			
			// wdev-5651 - hold onto the first day of the week for this profile
			// we will need it later when  calculating the lastActualGenDate
			// this will store the last date a session was generated from
			// starting with the first day of the profile
			int firstDay=0;
			if (profile.isIsSchSun())
				firstDay=Calendar.SUNDAY;
			else if (profile.isIsSchMon())
				firstDay=Calendar.MONDAY;
			else if (profile.isIsSchTue())
				firstDay=Calendar.TUESDAY;
			else if (profile.isIsSchWed())
				firstDay=Calendar.WEDNESDAY;
			else if (profile.isIsSchThur())
				firstDay=Calendar.THURSDAY;
			else if (profile.isIsSchFri())
				firstDay=Calendar.FRIDAY;
			else if (profile.isIsSchSat())
				firstDay=Calendar.SATURDAY;
			
			Date modifiedFromDt = new ims.framework.utils.Date(profile.getEffFrm());
			
			// wdev-5925 If the toDate is later than the effective To date of the profile, we need
			// to update the toDate to the earlier value
			if(profile.getEffTo() != null)
			{
				if (toDt.getDate().after(profile.getEffTo()))
					toDt = new Date(profile.getEffTo());
			}

			// wdev-5651 we need to set the modified From Date to the last actual gen date
			// so that the date are calculated correctly - especially for those profiles with > 1 weekly intervals
			if (profile.getLastActualGenDate() != null && /* WDEV-6918 */ profile.getLastActualGenDate().after(modifiedFromDt.getDate()))
				modifiedFromDt = new Date(profile.getLastActualGenDate());

			// The fromDate should be set to the firstDay of the week to ensure correct generation
			// so if fromDate is Thursday, and first day is Tuesday, move back the from Date by 2 days
			ImsDate imsFromDt = new ImsDate(modifiedFromDt.toString(DateFormat.ISO));
			int fromDayOfWeek = imsFromDt.getDayOfWeek();
			if (fromDayOfWeek > firstDay)
			{
				imsFromDt.addValue(ImsDate.DAYS, (-1*(fromDayOfWeek - firstDay)));
				modifiedFromDt = new Date(imsFromDt.toString(true), DateFormat.ISO);
			}
			
			if (modifiedFromDt.getDate().after(toDt.getDate()))
				return 0;
			
			// Generate the list of days to generate for
			LinkedList generatedDays = new LinkedList();
						
			//WDEV-7237
			if(toDt != null && modifiedFromDt != null && toDt.isGreaterThan(modifiedFromDt))			
				generateDaysList(profile, modifiedFromDt, toDt, generatedDays);
						
			ImsDate lastActualDate=null;
			int countGeneratedSessions = 0;
			if (generatedDays.size() > 0)
			{
				//WDEV-5171
				removeGlobalExclusions(factory, generatedDays);				
				
				// Remove any exclusion dates for the profiles
				removeExclusions(profile, generatedDays);				
				
				// populateSessionDetails for each day in the generatedDays list
				for (int j = 0; j < generatedDays.size(); j++)
				{
					ImsDate dt = (ImsDate) generatedDays.get(j);
					
					if (dt.before(fromDt.getDate()))  // wdev-5651
					{
						if (dt.getDayOfWeek() == Calendar.SUNDAY)	//wdev-11339
							lastActualDate = dt;
						continue;
					}
					
					// wdev-10444 as the date values seem to include time, the after doesn't work well 
					// when it's the actual last day.  Only exclude if the ISO format 'YYYYMMDD' text values
					// also don't equal i.e. it's not the same day
					if (dt.after(toDt.getDate()) && !dt.toString(true).equals(toDt.toString(DateFormat.ISO)))  // WDEV-10444 (extra check)
						continue;
					
					
					if (dt.getDayOfWeek() == Calendar.SUNDAY)	//wdev-11339
						lastActualDate = dt;
					if (BookingSource.INTERNAL.equals(source))
						transaction = factory.beginTransaction();
					Sch_Session session = createSession(factory, profile, dt.toString(true), source, true);
					
										
					// null will be returned if there is already a session for
					// this date
					if (session != null)
					{
						countGeneratedSessions++;
						factory.saveNoFlush(session);	//WDEV-22989 flushing at commit will reduce times rather than flushing after each save					
					}
					//WDEV-22989
					if (BookingSource.INTERNAL.equals(source) && (countGeneratedSessions > 0 && countGeneratedSessions % 50 == 0))
					{
						transaction.commit();
						transaction = factory.beginTransaction();
					}
				}
				
			}
			profile.setLastGenDate(toDt.getDate());
			//WDEV-7238
			if(lastActualDate != null)
			{
				//WDEV-10530 - audit will not pick up changes if send in as ImsDate type
				profile.setLastActualGenDate(new java.util.Date(lastActualDate.getMilliSeconds()));
			}
			return countGeneratedSessions;
		}
		catch (StaleObjectException e)
		{
			transaction.rollback();
			throw new DomainException("StaleObjectException occurred saving session details - " + e.getMessage(), e);
			
		}
		catch (Exception e)
		{
			transaction.rollback();
			throw new DomainInterfaceException("Exception occurred generating session details - " + e.getMessage(), e);
		}
		finally
		{
			// WDEV-20625 - Before leaving this method, we need to set the audit classes back
			if (auditItemsRemoved != null && auditItemsRemoved.size() > 0)
			{
				ClassConfig cfg = getConfiguration().getClassConfig();
				
				for (int i=0; i<auditItemsRemoved.size(); i++)
				{
					cfg.makeObjectAudited(auditItemsRemoved.get(i));
				}
			}
			
		}
	}

	/**
	 * WDEV-20625
	 * Remove the session classes from auditing for the duration of the generate
	 */
	private ArrayList<String> pauseSessionAuditing() 
	{
		ArrayList<String> auditItemsRemoved  = new ArrayList<String>();
		String[] sessionClassNames = {"ims.scheduling.domain.objects.Sch_Session", "ims.scheduling.domain.objects.Session_Slot", "ims.scheduling.domain.objects.Session_ListOwner",
				"ims.scheduling.domain.objects.Session_Exc_Time", "ims.scheduling.domain.objects.SessionParentChildSlot", "ims.scheduling.domain.objects.SessionActivity"}; //WDEV-21137
					
		Configuration cfg = getConfiguration();
		if (cfg == null)
			return null;
		ClassConfig classCfg = cfg.getClassConfig();
		if (classCfg == null)
			return null;
		
		for (int i=0; i<sessionClassNames.length; i++)
		{
			String className=sessionClassNames[i];
			if (classCfg.isBoAudited(className))
			{
				classCfg.makeObjectNonAudited(className);
				auditItemsRemoved.add(className);
			}	
		}

		return auditItemsRemoved;
	}

	private void removeGlobalExclusions(DomainFactory factory, LinkedList generatedDays) throws DomainException
	{
		ExclusionDates impl = (ExclusionDates) getDomainImpl(ExclusionDatesImpl.class);
		ExclusionDatesVo exDate = impl.listExclusionDates();

		if(exDate == null)
			return;
		
		try
		{
			ImsDate[] dates = null;
			if (exDate.getDates() != null)
			{
				dates = new ImsDate[exDate.getDates().length];
				for (int i = 0; i < exDate.getDates().length; i++)
				{
					dates[i] = new ImsDate(exDate.getDates()[i].toString(DateFormat.ISO));
				}
			}

			ImsDate startDt = new ImsDate(new Date().toString(DateFormat.ISO));
			startDt.removeSpecifiedDates(generatedDays, dates);
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred in removeGlobalExclusions - " + e.getMessage(), e);
		}  
	}

	public LocationLiteVoCollection loadLocations() 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Location.class,factory);
		imsc.equal(Location.FieldNames.IsActive, true);
		imsc.equal(Location.FieldNames.IsVirtual, false);
		imsc.addOrder(Location.FieldNames.Name, ORDERMODE.ASC);
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.SURGERY.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.ANE.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.BAY.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.CASE_NOTE_FOLDER_LOCATION.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.CCA.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.CLINICAL.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.CLINICALIMAGINGDEPARTMENT.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.DEPT.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.MEDICAL_RECORDS.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.PATHOLOGYLABORATORY.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.PHN_DISTRICT.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.SECTOR.getID());
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.UNKNOWN_TYPE.getID());
		List locations=imsc.find();
		if (locations!=null&&locations.size()>0)
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return null;
	}

	public ProfileShortVoCollection loadProfiles(LocationRefVo location, String name) 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Sch_Profile.class,factory);
		
		if (location!=null && location.getID_LocationIsNotNull())
		{
			imsc.join("this.schLocation", "location");
			imsc.equal("location.id", location.getID_Location());
		}
		if (name!=null)
			imsc.like("this.name", name + "%");
		imsc.addOrder("name", ORDERMODE.ASC);
		imsc.setMaxResults(1000);
		List profiles=imsc.find();
		if (profiles.size()>0)
			return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
		return null;
		
		
	}

	//WDEV-20447
	public ProfileShortVoCollection listProfiles(LocationRefVo location,Sch_ProfileRefVo profile,ServiceRefVo service, Boolean isActive) 
	{
		
		DomainFactory factory = getDomainFactory();

		String hql = " select profile from Sch_Profile as profile ";

		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String andStr = " where ";
		StringBuffer condStr = new StringBuffer();
		
		if (location != null)
		{
			hql += " left join profile.schLocation as location ";
			
			String ids = getLocationsIdsForParentLocation(location);

			condStr.append(andStr + " location.id in ( " + ids + " ) ");
			
			andStr = " and ";
		}
		
		if (service!=null && service.getID_ServiceIsNotNull())
		{
			hql += " left join profile.service as serv ";

			condStr.append(andStr + " serv.id = :serviceID ");
			markers.add("serviceID");
			values.add(service.getID_Service());
			andStr = " and ";
		}
		
		if (profile!=null && profile.getID_Sch_ProfileIsNotNull())
		{
			condStr.append(andStr + " profile.id = :profileID ");
			markers.add("profileID");
			values.add(profile.getID_Sch_Profile());
			andStr = " and ";
		}
		
		if (Boolean.TRUE.equals(isActive))
		{
			condStr.append(andStr + " profile.isActive = :isActive ");
			markers.add("isActive");
			values.add(isActive);
			andStr = " and ";
		}
		
		condStr.append(" order by profile.name ASC");

		hql += condStr.toString();
		
		List profiles = factory.find(hql, markers, values);
		
		if (profiles.size()>0)
			return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
		
		return null;
				
	}

	private String getLocationsIdsForParentLocation(LocationRefVo location)
	{
		//http://jira/browse/WDEV-21222 
		OrganisationAndLocation impl =(OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getChildLocationsIdsForLocation(location.getBoId(), null, null,Boolean.FALSE);
	}
	
	public ServiceLiteVoCollection listActiveServiceByName(String name)
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Service.class,factory);
		
		imsc.equal("this.isActive", Boolean.TRUE);
		if (name!=null)
			imsc.like("this.serviceName", name + "%");
		imsc.addOrder("serviceName", ORDERMODE.ASC);
		imsc.setMaxResults(200);
		List services=imsc.find();
		if (services.size()>0)
			return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services);
		return null;	
	}

	public ProfileShortVo getProfile(Sch_ProfileRefVo profile)
	{
		if (profile == null || profile.getID_Sch_Profile() == null)
			throw new CodingRuntimeException("profile is null or id not provided in method getProfile");
		
		return ProfileShortVoAssembler.create((Sch_Profile) getDomainFactory().getDomainObject(profile));
	}

	//WDEV-12664
	public Integer countSessionsForProfile(Sch_ProfileRefVo profile)
	{
		if (profile == null)
			throw new CodingRuntimeException("profile cannot be null in method countSessionsForProfile");
		
		String hql = "select count (sess.id) from Sch_Session as sess where sess.sch_Profile.id = " +  profile.getID_Sch_Profile();
		List ret = getDomainFactory().find(hql);
		
		if (ret != null && ret.get(0) != null)
		{
			if (ret.get(0) instanceof Integer)
			{
				Integer iCount = (Integer) ret.get(0);
				return iCount;
			}
			else if (ret.get(0) instanceof Long)
			{
				Long lCount = (Long) ret.get(0);
				return lCount.intValue();
			}
		}
		return 0;
	}

	//WDEV-17916
	public Boolean createAdHocSession(ProfileShortVo profile, Date date) throws DomainInterfaceException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Sch_Profile doProfile = (Sch_Profile) factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());

		ImsDate imsDate;
		
		try
		{
			imsDate = new ImsDate(date.toString(DateFormat.ISO));
			
			Sch_Session session = createSession(factory, doProfile, imsDate.toString(true), BookingSource.INTERNAL, true);
			
			/* no need to update the Last Generated Date for an Ad-Hoc session
			if (doProfile.getLastGenDate() != null && profile.getLastGenDate().isLessThan(date))
			{
				doProfile.setLastGenDate(imsDate);
			}
			*/
			
			// null will be returned if there is already a session for this date
			if (session != null)
			{
				factory.save(session);
				return true;
			}
			else 
				return false;
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session details - " + e.getMessage(), e);
		}
	}

	public SessionForSlotsPreviewVo generateSessionForPreview(Sch_ProfileRefVo profileRef, Date fromDate, Date toDate) throws DomainInterfaceException
	{
		
		DomainFactory factory = getDomainFactory();
		Sch_Profile doProfile = (Sch_Profile) factory.getDomainObject(Sch_Profile.class, profileRef.getID_Sch_Profile());

		try
		{
			
		SessionForSlotsPreviewVo session = generateProfileSlotsForPreview(factory, doProfile, fromDate, toDate, BookingSource.INTERNAL);

		return session;
		
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session slots " + e.getMessage(), e);
		}
	}

	private SessionForSlotsPreviewVo generateProfileSlotsForPreview(DomainFactory factory, Sch_Profile profile, Date fromDt, Date toDt, BookingSource source) throws DomainException
	{
		
		SessionForSlotsPreviewVo session = null;
		
		try
		{
			int firstDay=0;
			
			if (profile.isIsSchSun())
				firstDay=Calendar.SUNDAY;
			else if (profile.isIsSchMon())
				firstDay=Calendar.MONDAY;
			else if (profile.isIsSchTue())
				firstDay=Calendar.TUESDAY;
			else if (profile.isIsSchWed())
				firstDay=Calendar.WEDNESDAY;
			else if (profile.isIsSchThur())
				firstDay=Calendar.THURSDAY;
			else if (profile.isIsSchFri())
				firstDay=Calendar.FRIDAY;
			else if (profile.isIsSchSat())
				firstDay=Calendar.SATURDAY;
			
			Date modifiedFromDt = new ims.framework.utils.Date(profile.getEffFrm());
			
			if(profile.getEffTo() != null)
			{
				if (toDt.getDate().after(profile.getEffTo()))
					toDt = new Date(profile.getEffTo());
			}

			// The fromDate should be set to the firstDay of the week to ensure correct generation
			// so if fromDate is Thursday, and first day is Tuesday, move back the from Date by 2 days
			ImsDate imsFromDt = new ImsDate(modifiedFromDt.toString(DateFormat.ISO));
			
			int fromDayOfWeek = imsFromDt.getDayOfWeek();
			
			if (fromDayOfWeek > firstDay)
			{
				imsFromDt.addValue(ImsDate.DAYS, (-1*(fromDayOfWeek - firstDay)));
				modifiedFromDt = new Date(imsFromDt.toString(true), DateFormat.ISO);
			}
			
			// Generate the list of days to generate for
			LinkedList generatedDays = new LinkedList();
			
			if(toDt != null && modifiedFromDt != null && toDt.isGreaterThan(modifiedFromDt))			
				generateDaysList(profile, modifiedFromDt, toDt, generatedDays);
			
			if (generatedDays.size() > 0)
			{
				
				removeGlobalExclusions(factory, generatedDays);				
				
				// Remove any exclusion dates for the profiles
				removeExclusions(profile, generatedDays);
				
				Date[] sessionDates = new Date[generatedDays.size()];
				
				// populateSessionDetails for each day in the generatedDays list
				for (int j = 0; j < generatedDays.size(); j++)
				{
					ImsDate dt = (ImsDate) generatedDays.get(j);
					
					if (dt.before(fromDt.getDate()))  // wdev-5651
					{
						continue;
					}
					
					// wdev-10444 as the date values seem to include time, the after doesn't work well 
					// when it's the actual last day.  Only exclude if the ISO format 'YYYYMMDD' text values
					// also don't equal i.e. it's not the same day
					if (dt.after(toDt.getDate()) && !dt.toString(true).equals(toDt.toString(DateFormat.ISO)))  // WDEV-10444 (extra check)
						continue;
					
					//just for one date
					if (session == null)
					{
						Sch_Session doSession = createSession(factory, profile, dt.toString(true), source, false);
						session = SessionForSlotsPreviewVoAssembler.create(doSession);
					}
					
					
					sessionDates[j] = new ims.framework.utils.Date(dt.toString(true), DateFormat.ISO);
					
				}
					
				if (session != null)
					session.setDatesGeneratedFor(sessionDates);
			}
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session details - " + e.getMessage(), e);
		}
		
		return session;
	}
	
	/*
	 * WDEV-20625
	 * getConfiguration
	 * Method to get the configuration class from session data in order to update non-audit items
	 */
	private Configuration getConfiguration()
	{
		SessionData sessData = (SessionData)this.getDomainFactory().getDomainSession().getAttribute(SessionConstants.SESSION_DATA);
		Configuration cfg = sessData.configurationModule.get();
		return cfg;
	}
	
	
	/**
	 * WDEV-21167
	 * Ripple out changes to Sessions and Cancel Appointments appropriately
	 * @throws StaleObjectException 
	 * 
	 */
	public Integer rippleProfileChanges() throws StaleObjectException, DomainInterfaceException
	{
	
		// List all ProfileRipple objects that have been updated within the dates provided
		DomainFactory factory = getDomainFactory();
		
		int numSessionsAffected=0, totalNumSessionsAffected=0;
		
		StringBuffer hql = new StringBuffer(" Select ripple from ProfileRipple ripple where ripple.active = 1 order by ripple.dateTimeRequested ");
		List profiles = factory.find(hql.toString());

		ArrayList<String> auditItemsRemoved = pauseSessionAuditing();
		StringWriter executionErrors = new StringWriter(); 
		try
		{
			if (profiles != null && profiles.size() > 0)
			{
				for (int i=0; i<profiles.size(); i++)
				{
					ProfileRipple domProfile = (ProfileRipple) profiles.get(i);
					try
					{
						numSessionsAffected = rippleProfileChange(factory, domProfile);
						totalNumSessionsAffected += numSessionsAffected;
						domProfile.setActive(false);
						domProfile.setDetails("" + numSessionsAffected + " session(s) updated");
						factory.save(domProfile);
					}
					catch (Exception e)
					{	
						//WDEV-23883 MAXIMS_10.5.3.17  first LOG the error
						e.printStackTrace(new PrintWriter(executionErrors));
						super.createSystemLogEntry (SystemLogType.QUARTZ_JOB, SystemLogLevel.ERROR, "Exception occurred executing Session Ripple job: \n " + executionErrors.toString());
						domProfile.setActive(false);
						domProfile.setDetails("Exception occurred during Session Ripple - " + e.getMessage());
						factory.save(domProfile);
						throw e;
					}
				}
			}
		}
		catch(Exception e)
		{
			if (e instanceof StaleObjectException || e instanceof DomainInterfaceException)
				throw new DomainInterfaceException(e.getMessage());
			e.printStackTrace();			
		}
		finally
		{
			// WDEV-20625 - Before leaving this method, we need to set the audit classes back
			if (auditItemsRemoved != null && auditItemsRemoved.size() > 0)
			{
				ClassConfig cfg = getConfiguration().getClassConfig();
				
				for (int i=0; i<auditItemsRemoved.size(); i++)
				{
					cfg.makeObjectAudited(auditItemsRemoved.get(i));
				}
			}
			
		}
		
		return totalNumSessionsAffected;
	}
	
	private int rippleProfileChange(DomainFactory factory, ProfileRipple domRipple) throws Exception
	{

		int numberOfSessionsAffected=0;
		if (domRipple != null)
		{
			// List the sessions and update
			String hql = " from Sch_Session sess where sess.sessionDate >= :effectiveFrom and sess.sch_Profile = :profile and (sess.isModified = 0 or sess.isModified is null) and (sess.isAdHocSession = 0 or sess.isAdHocSession is null)";
			List lst = factory.find(hql, new String[]{"effectiveFrom", "profile"}, new Object[]{domRipple.getEffectiveFromDate(), domRipple.getProfile()}, 50000);  //  Need to ensure it's not just the first 200 records updated
			if (lst != null && lst.size() > 0)
			{
		
				for (int i=0; i<lst.size(); i++)
				{
					Sch_Session domSession = (Sch_Session) lst.get(i);
					List<Session_Slot> slotList = new ArrayList<Session_Slot>(); //WDEV-23800 do not re-initialise the list MAXIMS_10.5.3.17
					// 	Check the ripple type and perform the session update accordingly
					if (domRipple.getStartTime() != null || domRipple.getEndTime() != null)
					{
						
							if (domRipple.getStartTime() != null)
								domSession.setStartTm(domRipple.getStartTime());
							if (domRipple.getEndTime() != null)
								domSession.setEndTm(domRipple.getEndTime());
							
					}
					
					if (domRipple.getListOwners() != null && domRipple.getListOwners().size() > 0)
					{
						// For ripple, we want to remove any in the current list not in the new list then
						// add to the list what's not in the new list.  We can't clear as get constraint error
						// based on the session slot using the slot responsibility field as it deletes and re-inserts
						//domSession.getListOwners().addAll(SlotGenerationUtils.copyListOwners(domRipple.getListOwners()));
						domSession = removeRedundantListOwners(domSession, domRipple.getListOwners());
						factory.saveNoFlush(domSession);
						domSession = addNewListOwners(factory, domSession, domRipple.getListOwners());
						
					}
					
					if (domRipple.getNewSlots() != null && domRipple.getNewSlots().size() > 0)
					{
						
						ImsDate dt = new ImsDate(domSession.getSessionDate().toString());
						// Only create the slot if not already there!
						Set newSlotSet = createSlots(domRipple.getNewSlots(), dt.toString(true), BookingSource.INTERNAL, domSession);
						// For each item in the newSlotSet, check if not a slot in the current session, then add
						Iterator it = newSlotSet.iterator();
						while (it.hasNext())
						{
							Session_Slot newSlot = (Session_Slot) it.next();
							if (!slotAlreadyExists(newSlot, domSession))
								domSession.getSessionSlots().add(newSlot);
						}
					}
					
					if (domRipple.getInactiveSlots() != null && domRipple.getInactiveSlots().size() > 0)
					{
						// Inactivate the slots and cancel all the appointments - setting isDisplaced=true
						Iterator<Profile_Slot> it = domRipple.getInactiveSlots().iterator();
				
						while (it.hasNext()) //WDEV-23800 first obtain the slot list for session, then update -  MAXIMS_10.5.3.17
						{							
							Profile_Slot profileSlot = (Profile_Slot) it.next();
							if (profileSlot != null)
								slotList.addAll(getSlotsFromProfileSlot(domSession, profileSlot));						
						}
						//WDEV-23702  -- changed to send multiple slot requests at once in the same message
						if (slotList != null && !slotList.isEmpty())
						{
							Iterator<Session_Slot> itSlots = slotList.iterator();
							StringBuilder cabMessage = new StringBuilder();							
							boolean eRSEnabled = ConfigFlag.GEN.ICAB_ENABLED.getValue();						
							boolean slotsCreatedExternally = ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book");
							
							while (itSlots.hasNext())
							{
								Session_Slot doSessionSlot = (Session_Slot)itSlots.next();				

								if (doSessionSlot != null)
								{
									boolean slotUpdateSentToCab = inactivateSlot(factory, domRipple, doSessionSlot);

									if (eRSEnabled && slotsCreatedExternally)
									{
										boolean isPublishedSlot =  isPublishedSlot(doSessionSlot);

										if (isPublishedSlot && !slotUpdateSentToCab)
										{
											doSessionSlot.setStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
											cabMessage.append(doSessionSlot.buildCabMessage());
											if (cabMessage.length() > 1800) 
											{	
												CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), cabMessage.toString(), "Inactivated Slots in Profile Maintenance");
												cabMessage.setLength(0);
											}
										}
									}
								}
							}
							if (slotsCreatedExternally && cabMessage.length() > 0)
							{	
								CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), cabMessage.toString(), "Inactivated Slots in Profile Maintenance");								
							}
						}
					}					
					//WDEV-23638
					if (domRipple.getName() != null)
						domSession.setName(domRipple.getName());
					if (domRipple.getDescription() != null)
						domSession.setDescription(domRipple.getDescription());
					//WDEV-23638
					
					factory.saveNoFlush(domSession);
				}
				numberOfSessionsAffected=lst.size();
			}
		}

		return numberOfSessionsAffected;
	}

	/**
	 * slotAlreadyExists
	 * This method will check to see if the new session slot already exists within the session
	 * @param newSlot
	 * @param domSession
	 * @return
	 */
	private boolean slotAlreadyExists(Session_Slot newSlot,	Sch_Session domSession) 
	{
		if (newSlot == null || domSession == null || domSession.getSessionSlots() == null)
			return false;
				
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot sessSlot = (Session_Slot)it.next();
			if (sessSlot != null)
			{
				if (sessSlot.getActivity() != null && newSlot.getActivity() != null && //WDEV-23883 cater for null activity, profile slot
						sessSlot.getActivity().getId().equals(newSlot.getActivity().getId()) &&  
						sessSlot.getProfileSlot() != null && newSlot.getProfileSlot() != null &&
						sessSlot.getProfileSlot().getId().equals(newSlot.getProfileSlot().getId()) &&
						sessSlot.getStartTm().equals(newSlot.getStartTm()))
					return true;
			}
		}
		return false;
	}

	/**
	 * addNewListOwners
	 * Add new listowners to the session that are not already in the collection
	 * @param domSession
	 * @param profileListOwners
	 * @return
	 * @throws StaleObjectException 
	 */
	private Sch_Session addNewListOwners(DomainFactory factory, Sch_Session domSession, Set profileListOwners) throws StaleObjectException 
	{
		if (domSession == null || domSession.getListOwners() == null)
			return domSession;
		
		Iterator it = profileListOwners.iterator();
		while (it.hasNext())
		{
			addOrUpdateListowner(factory, (Profile_ListOwner) it.next(), domSession);
				
		}
		return domSession;
	}

	/**
	 * removeRedundantListOwners
	 * Remove listowners from the session that are no longer specified for the profile
	 * @param domSession
	 * @param profileListOwners
	 * @return
	 */
	private Sch_Session removeRedundantListOwners(Sch_Session domSession, Set profileListOwners) 
	{
		if (domSession == null || domSession.getListOwners() == null)
			return domSession;
		
		// TODO
		// Change this to a collection loop and remove from the list those not needed
		Set newList = new HashSet();
		Iterator it = domSession.getListOwners().iterator();
		//WDEV-22991
		while (it.hasNext())
		{
			Session_ListOwner sessLo =(Session_ListOwner) it.next();
			boolean listOwnerStillValid = isListOwnerStillValid(sessLo, profileListOwners);
			boolean hasResponsibilityForSlots = hasResponsibilityForSlots(sessLo, domSession);
			
			//Need to check and update slot responsible where this is set to avoid constraint exc		
			if (!listOwnerStillValid && hasResponsibilityForSlots) //WDEV-23908
			{	
				updateSlotsForSessionFromProfileRippleSlot(domSession);
				updateManuallyAddedSlots(domSession,profileListOwners);
			}
			// remove the one not need
			if (listOwnerStillValid)
				newList.add(sessLo);
		}
		
		domSession.getListOwners().clear();
		domSession.getListOwners().addAll(newList);
		//domSession.setListOwners(newList);
		return domSession;
	}
	//WDEV-23908
	private void updateManuallyAddedSlots(Sch_Session domSession, Set profileListOwners)
	{
		if (domSession == null || domSession.getSessionSlots() == null || profileListOwners == null)
			return;
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot slot = (Session_Slot) it.next();			
			Session_ListOwner slotResp = slot.getSlotResp();
			
			if (slotResp != null && slot.getProfileSlot() == null)
			{
				if (profileListOwners != null)
				{
					 Profile_ListOwner slotRespToSet = profileListOwners.size() == 1 ? (Profile_ListOwner) profileListOwners.iterator().next() : null;
					 slot = updateSessionListOwnerFromProfSlot(slot, slotRespToSet);				
				}
			}
		}	
		
	}

	//WDEV-22991 
	private void updateSlotsForSessionFromProfileRippleSlot(Sch_Session domSession)
	{
		if (domSession == null || domSession.getSessionSlots() == null)
			return;
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot slot = (Session_Slot) it.next();			
			Session_ListOwner slotResp = slot.getSlotResp();			
			if (slotResp != null && slot.getProfileSlot() != null)
			{				
				Profile_Slot profileSlotRippled = slot.getProfileSlot();
				if (profileSlotRippled != null) //WDEV-23971
				{					
					slot = updateSessionListOwnerFromProfSlot(slot, profileSlotRippled.getSlotResp());				
				}
			}
		}	
	}
	
	private Session_Slot updateSessionListOwnerFromProfSlot(Session_Slot slot, Profile_ListOwner slotResp) 
	{
		if (slot == null)
			return null;
		if (slotResp == null)
		{
			slot.setSlotResp(null);
			return slot;
		}
		Session_ListOwner newSlotResp  = new Session_ListOwner();
		newSlotResp.setEndTime(slotResp.getEndTime());			
		newSlotResp.setMaxNoAppts(slotResp.getMaxNoAppts());
		newSlotResp.setStartTime(slotResp.getStartTime());
		newSlotResp.setAttendingClinician(slotResp.isAttendingClinician());
		newSlotResp.setListOwner(slotResp.isListOwner());
		newSlotResp.setHcp(slotResp.getHCP());

		slot.setSlotResp(newSlotResp);
		
		return slot;
	}
	//WDEV-22991  - end
	/**
	 * addOrUpdateListowner
	 * Method will check if the listowner is already in the session, if found it will update details, if not found it will add it.
	 * @param ProfileListowner
	 * @param Session
	 * @return
	 * @throws StaleObjectException 
	 */
	//WDEV-22659
	private void addOrUpdateListowner(DomainFactory factory, Profile_ListOwner profileLo, Sch_Session domSession) throws StaleObjectException 
	{
		if (profileLo == null)
			return;
		
		boolean insertRequired, updateRequired=false;
		boolean exactRecordFound=false;
		Iterator<Session_ListOwner> it = domSession.getListOwners().iterator();
		while (it.hasNext())
		{
			Session_ListOwner lo = (Session_ListOwner) it.next();
			boolean hasResponsibilityForSlots = hasResponsibilityForSlots(lo,domSession);
			if (lo.getHcp().equals(profileLo.getHCP()) && 
					((lo.isAttendingClinician() == null && profileLo.isAttendingClinician() == null ) 
							|| (lo.isAttendingClinician() != null && profileLo.isAttendingClinician() != null && lo.isAttendingClinician().equals(profileLo.isAttendingClinician()))) &&
					((lo.isListOwner() == null && profileLo.isListOwner() == null )
							|| (lo.isListOwner() != null && profileLo.isListOwner() != null && lo.isListOwner().equals(profileLo.isListOwner()))))
			{
				exactRecordFound=true; // Listowner found and no changes needed - no action required
				break;
			}
			updateRequired = lo.getHcp().equals(profileLo.getHCP());
			if (updateRequired)
			{		
				lo = updateSessionListOwnerFromProfileRipple(lo,profileLo);
				if (hasResponsibilityForSlots)
					updateSlotsForSession(domSession,profileLo);
			}
			
		}
		insertRequired = !isListOwnerHcpLinkedToSession(domSession,profileLo);
		if (!exactRecordFound && insertRequired)
		{
			Session_ListOwner sessOwner = new Session_ListOwner();
			sessOwner = updateSessionListOwnerFromProfileRipple(sessOwner,profileLo);
			sessOwner.setHcp(profileLo.getHCP());		
			
			domSession.getListOwners().add(sessOwner);			
			factory.saveNoFlush(sessOwner);
		}
	}

	private Session_ListOwner updateSessionListOwnerFromProfileRipple(Session_ListOwner sessOwner, Profile_ListOwner profileLo)
	{
		if (sessOwner == null)
			return null;
		
		sessOwner.setEndTime(profileLo.getEndTime());			
		sessOwner.setMaxNoAppts(profileLo.getMaxNoAppts());
		sessOwner.setStartTime(profileLo.getStartTime());
		sessOwner.setAttendingClinician(profileLo.isAttendingClinician());
		sessOwner.setListOwner(profileLo.isListOwner());
		
		return sessOwner;
	}
	//WDEV-22659
	private boolean isListOwnerHcpLinkedToSession(Sch_Session domSession,Profile_ListOwner profileLo)
	{
		if (domSession == null || domSession.getListOwners() == null)
			return false;
		Iterator it = domSession.getListOwners().iterator();
		while (it.hasNext())
		{
			Session_ListOwner lo = (Session_ListOwner) it.next();
			if (lo.getHcp().equals(profileLo.getHCP()))
				return true;
		}	
		return false;
	}
	//WDEV-22659
	private void updateSlotsForSession(Sch_Session domSession, Profile_ListOwner profileLo)
	{
		if (domSession == null || domSession.getSessionSlots() == null)
			return;
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot slot = (Session_Slot) it.next();	
			if (slot != null)
			{	
			Session_ListOwner slotResp = slot.getSlotResp();			
			slotResp = updateSessionListOwnerFromProfileRipple(slotResp, profileLo);
			}
		}	
	}
	//WDEV-22659
	private boolean hasResponsibilityForSlots(Session_ListOwner lo, Sch_Session domSession)
	{
		if (domSession == null || domSession.getSessionSlots() == null)
			return false;
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot slot = (Session_Slot) it.next();
			if (slot.getSlotResp() != null && slot.getSlotResp().getHcp().equals(lo.getHcp()))
				return true;
		}
		return false;
	}
	//WDEV-22659  --- ends here
	/**
	 * isListownerStillValid
	 * Method to check whether the Listowner for the session is still active in the new set for the profile
	 * @param lo
	 * @param profileListOwners
	 * @return
	 */
	private boolean isListOwnerStillValid(Session_ListOwner lo,	Set profileListOwners) 
	{
		if (profileListOwners == null || profileListOwners.size() == 0)
			return false;
		
		Iterator it = profileListOwners.iterator();
		while (it.hasNext())
		{
			Profile_ListOwner profileLo = (Profile_ListOwner) it.next();
			if (lo.getHcp().equals(profileLo.getHCP()) && Boolean.TRUE.equals(profileLo.isListOwner()))	//wdev-22659 //WDEV-23971
				return true;
		}
		
		return false;
	}

	private List getSlotsFromProfileSlot(Sch_Session domSession, Profile_Slot profileSlot) 
	{
		// Loop through session slots to ensure the correct one for the Profile Slot is returned
		if (profileSlot == null || domSession == null || domSession.getSessionSlots() == null)
			return null;
		
		ArrayList<Session_Slot> slotList = new ArrayList<Session_Slot>();
		
		Iterator it = domSession.getSessionSlots().iterator();
		while (it.hasNext())
		{
			Session_Slot domSlot = (Session_Slot) it.next();
			if (Status_Reason.CANCELLED.getID() != domSlot.getStatus().getId() && domSlot.getProfileSlot() != null && domSlot.getProfileSlot().getId().equals(profileSlot.getId()))
				slotList.add(domSlot);
		}
		
		return slotList;
	}

	private boolean inactivateSlot(DomainFactory factory, ProfileRipple domRipple, Session_Slot slot) throws StaleObjectException
	{
		slot.setIsActive(false);
		slot.setStatus(super.getDomLookup(Status_Reason.CANCELLED));
		slot.setStatusReason(domRipple.getCancellationReason());
		
		// WDEV - 23611
		boolean eRSEnabled = ConfigFlag.GEN.ICAB_ENABLED.getValue();
		boolean isPublishedSlot = eRSEnabled ? isPublishedSlot(slot) : false;
		boolean slotUpdateNotifyToCab = false;
						
		if (slot.getAppointment() != null)
		{
			Booking_Appointment domAppt = slot.getAppointment();
			if (domAppt.getApptStatus().getId() == Status_Reason.BOOKED.getID())
			{
				domAppt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));
				domAppt.setApptStatusReas(domRipple.getCancellationReason());
				domAppt.setIsDisplaced(true);
				//WDEV-23800 - start here MAXIMS_10.5.3.17 
				domAppt.setRequiresRebook(true);

				// WDEV-22357
				List<CatsReferral> catsReferralList = factory.find("select cats from CatsReferral as cats left join cats.appointments as appt where appt.id = :ApptId", new String[] {"ApptId"}, new Object[] {domAppt.getId()});
				if (catsReferralList != null && catsReferralList.size() == 1) // If greater than one it indicates data issues as an appointment should only be linked to one referral
				{
					CatsReferral domReferral = catsReferralList.get(0);
					if (domReferral != null)
					{	
						// If this is first activity, set consultation activity to null and the requiresRebook to true so it will appear on the First Consultation Activity Required worklist
						if ((domAppt.isFirstConsultationActivity() != null && domAppt.isFirstConsultationActivity()) || (domAppt.getActivity() != null && domAppt.getActivity().isFirstAppointment() != null && domAppt.getActivity().isFirstAppointment()))
						{						
							domReferral.setConsultationAppt(null);
							domReferral.setConsultationActivityRequired(true);											
						}
						else if (!Boolean.TRUE.equals(domAppt.isFirstConsultationActivity()) || (domAppt.getActivity() != null && !Boolean.TRUE.equals(domAppt.getActivity().isFirstAppointment())))
						{						
							domReferral.setHasRebookingSubsequentActivity(true);					
						}
						factory.saveNoFlush(domReferral);
					}
				}
				//WDEV-23800 - ends here
				// WDEV-22357 end
				// For C&B Appointments, we need to notify choose and book
				if (eRSEnabled && isPublishedSlot && Boolean.TRUE.equals(domAppt.isIsCABBooking()))
				{					
					domAppt.setApptStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
					slot.setStatus(getDomLookup(Status_Reason.CANCELLED_PENDING_APPT));//WDEV - 23611
					slotUpdateNotifyToCab = true;
					
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_APPT_CANCEL), domAppt, "Inactivated Slots in Profile Maintenance - Appointments Cancelled");
				}
				
				Appointment_Status domApptStat = new Appointment_Status();
				domApptStat.setApptDate(domAppt.getAppointmentDate());
				domApptStat.setApptTime(domAppt.getApptStartTime());
				domApptStat.setCancellationReason(domRipple.getCancellationReason());
				domApptStat.setStatus(domAppt.getApptStatus());
				domApptStat.setStatusChangeDateTime(new java.util.Date());
				domApptStat.setIsDisplaced(true);
				domApptStat.setComment("Appointment Displaced following Profile Maintenance");
				//WDEV-23185
				if (domAppt.getSession() != null)
				{
					domApptStat.setSession(domAppt.getSession());
				} //WDEV-23185
				
				domAppt.setCurrentStatusRecord(domApptStat);
				domAppt.getApptStatusHistory().add(domApptStat);
			}
			factory.saveNoFlush(domAppt);
		}
		if (eRSEnabled && isPublishedSlot && slot.getStatus().getId() != Status_Reason.CANCELLED_PENDING_APPT.getId())
		{			
			slot.setStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));			
		}
		factory.saveNoFlush(slot);
		
		return slotUpdateNotifyToCab;
	}

	private boolean isPublishedSlot(Session_Slot slot)
	{
		if (slot == null)
			return false;			
		// If this is a C&B published slot, we need to send a message to say it is not longer available
		if (slot.getDirectoryOfServices() != null && slot.getDirectoryOfServices().size() > 0)
		{
			Iterator slotIt = slot.getDirectoryOfServices().iterator();
			while (slotIt.hasNext())
			{
				DirectoryOfServiceSessionSlot dosSlot = (DirectoryOfServiceSessionSlot) slotIt.next();				
				if (Boolean.TRUE.equals(dosSlot.isIsPublished()))
				{					
					return true;					
				}
			}
		}
		return false;
	}
	
	
}
