//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.80 build 4198.17562)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.ReasonPastFirstApptKPIVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.impl.PatientCaseNotesImpl;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocShortMappingsVoCollection;
import ims.core.vo.LocShortVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.PatientCaseNoteRequestLiteVoCollection;
import ims.core.vo.domain.LocShortMappingsVoAssembler;
import ims.core.vo.domain.LocShortVoAssembler;
import ims.core.vo.domain.PatientCaseNoteRequestLiteVoAssembler;
import ims.core.vo.lookups.CaseNoteRequestCancellationReason;
import ims.core.vo.lookups.CaseNoteRequestStatus;
import ims.core.vo.lookups.LocationType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.scheduling.domain.TheatreSessionManagement;
import ims.scheduling.domain.base.impl.BaseMoveSessionDialogImpl;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionTheatreTCISlot;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.lookups.CancelAppointmentReason;
import ims.scheduling.vo.lookups.SchProfileType;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class MoveSessionDialogImpl extends BaseMoveSessionDialogImpl
{

	private static final long serialVersionUID = 1L;

	/**
	* moveSessionToDate
	* all appointments slots etc need to move to the new date
	*/
	public void moveSessionToDate(SessionShortVo session, Date toDate,	LocShortVo location, List breachedFirstAppointmentsIds,	ReasonPastFirstApptKPIVo reasonForBreach, LocShortVo caseNotesLocation,  Boolean cancelAppointments)  throws ims.domain.exceptions.StaleObjectException
	{
		if (session == null)
			throw new CodingRuntimeException("session cannot be null in method moveSessionToDate");

		Sch_Session doSession = SessionShortVoAssembler.extractSch_Session(getDomainFactory(), session);
		Location doLocation = LocShortVoAssembler.extractLocation(getDomainFactory(), location);
		//WDEV-19518 --start
		Boolean sessionRequiresCaseNoteLocation = doSession.isCaseNoteFolderNotRequired() == null || Boolean.FALSE.equals(doSession.isCaseNoteFolderNotRequired());
		
		if (caseNotesLocation != null && sessionRequiresCaseNoteLocation)
		{	
			Location caseNoteLocationDO = LocShortVoAssembler.extractLocation(getDomainFactory(), caseNotesLocation);
			doSession.setCaseNoteFolderLocation(caseNoteLocationDO);
		}
		if (doLocation != null)
		{
			doSession.setSchLocation(doLocation);
			doSession.setLocationMovedDateTime(new java.util.Date());
			if (sessionRequiresCaseNoteLocation)
				doSession.setCaseNoteFolderLocation(Boolean.TRUE.equals(doLocation.isCaseNoteFolderLocation()) ? doLocation : null); 			
		}	
		//WDEV-19518 ---ends here
		
		if (toDate != null)
			doSession.setSessionDate(toDate.getDate());

		if (SchProfileType.THEATRE.equals(session.getSessionProfileType()))
		{
			// Theatre TCI
			if (doSession.getTheatreSlots() != null)
			{
				Iterator tciSlotIterator = doSession.getTheatreSlots().iterator();
				while (tciSlotIterator.hasNext())
				{
					SessionTheatreTCISlot doTCISlot = (SessionTheatreTCISlot) tciSlotIterator.next();
						
					if (toDate != null)
						doTCISlot.setSessDateTime(toDate.getDate());

					if (doTCISlot.getAppointment() != null)
					{
						if (toDate != null)
							doTCISlot.getAppointment().setAppointmentDate(toDate.getDate());
						// update appointment Status and History
						updateAppointmentStatus(toDate, doTCISlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment(), true, breachedFirstAppointmentsIds, reasonForBreach, cancelAppointments);
					}
				}
			}

			// Theatre Fixed
			if (doSession.getParentChildSlots() != null)
			{
				Iterator pcSlotIterator = doSession.getParentChildSlots().iterator();
				while (pcSlotIterator.hasNext())
				{
					SessionParentChildSlot doSessPcSlot = (SessionParentChildSlot) pcSlotIterator.next();
						
					if (toDate != null)
						doSessPcSlot.setSessDateTime(toDate.getDate());

					if (doSessPcSlot.getAppointment() != null)
					{
						if (toDate != null)
							doSessPcSlot.getAppointment().setAppointmentDate(toDate.getDate());
						// update appointment Status and History
						updateAppointmentStatus(toDate, doSessPcSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment(), true, breachedFirstAppointmentsIds, reasonForBreach, cancelAppointments);
					}
				}
			}

			// O/P Slots
			if (doSession.getSessionSlots() != null)
			{
				Iterator sessSlotIterator = doSession.getSessionSlots().iterator();
				while (sessSlotIterator.hasNext())
				{
					Session_Slot doSessSlot = (Session_Slot) sessSlotIterator.next();
						
					if (toDate != null)
						doSessSlot.setSessDateTime(toDate.getDate());

					if (doSessSlot.getAppointment() != null)
					{
						if (toDate != null)
							doSessSlot.getAppointment().setAppointmentDate(toDate.getDate());
							
						// update appointment Status and History
						updateAppointmentStatus(toDate, doSessSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment(), true, breachedFirstAppointmentsIds, reasonForBreach, cancelAppointments);
					}
				}
			}
		}
		//Outpatient Session
		else if (Boolean.TRUE.equals(session.getIsFixed()) && doSession.getSessionSlots() != null)
		{
			Iterator sessSlotIterator = doSession.getSessionSlots().iterator();
				
			while (sessSlotIterator.hasNext())
			{
				Session_Slot doSessSlot = (Session_Slot) sessSlotIterator.next();
					
				if (toDate != null)
					doSessSlot.setSessDateTime(toDate.getDate());

				if (doSessSlot.getAppointment() != null)
				{
					if (!Boolean.TRUE.equals(doSessSlot.getAppointment().isIsCABBooking()) && toDate != null)
					{
						doSessSlot.getAppointment().setAppointmentDate(toDate.getDate());
					}
						
					// update appointment Status and History
					updateAppointmentStatus(toDate, doSessSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment(), false, breachedFirstAppointmentsIds, reasonForBreach, cancelAppointments);
				}
			}
		}
		//Flexible Outpatient Session
		else if (doSession.getParentChildSlots() != null)
		{
			Iterator sessSlotIterator = doSession.getParentChildSlots().iterator();
				
			while (sessSlotIterator.hasNext())
			{
				SessionParentChildSlot doSessSlot = (SessionParentChildSlot) sessSlotIterator.next();
					
				if (toDate != null)
					doSessSlot.setSessDateTime(toDate.getDate());

				if (doSessSlot.getAppointment() != null)
				{
					if (!Boolean.TRUE.equals(doSessSlot.getAppointment().isIsCABBooking()) && toDate != null)
					{
						doSessSlot.getAppointment().setAppointmentDate(toDate.getDate());
					}
						
					// update appointment Status and History
					updateAppointmentStatus(toDate, doSessSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment(), false, breachedFirstAppointmentsIds, reasonForBreach, cancelAppointments);
				}
			}
		}
			
		
		getDomainFactory().save(doSession);

		// CANCEL and Rebook Theatre Fixed Appointments
		Integer[] arrBookedAppts = getBookedAppointmentIdsForSession(session);
		if (arrBookedAppts != null)
		{

		}

	}

	/**
	 * @param toDate
	 * @param cancelComment 
	 * @param cancellationReason 
	 * @param reasonForBreach 
	 * @param breachedFirstAppointmentsIds 
	 * @param appointment
	 * @throws StaleObjectException 
	 */
	private void updateAppointmentStatus(ims.framework.utils.Date toDate, Booking_Appointment doAppointment, LookupInstance cancellationReason, String cancelComment, boolean isTheatre, List breachedFirstAppointmentsIds, ReasonPastFirstApptKPIVo reasonForBreach, Boolean cancelAppointments) throws StaleObjectException
	{
		if (doAppointment == null || doAppointment.getCurrentStatusRecord() == null)
			return;
		
		Appointment_Status doCurrent = doAppointment.getCurrentStatusRecord();
	
		//WDEV-12918 only cancel and rebook booked appointments (not dna etc.)
		//do not update status for C&B appointments
		if(!doCurrent.getStatus().equals(getDomLookup(Status_Reason.BOOKED)) || Boolean.TRUE.equals(doAppointment.isIsCABBooking()))
			return;
		
		Appointment_Status bookedStatus = null;
		Appointment_Status cancelledStatus = null;
		
		if (!isTheatre && breachedFirstAppointmentsIds != null && breachedFirstAppointmentsIds.size() > 0)
		{
			for (int i = 0; i < breachedFirstAppointmentsIds.size(); i++)
			{
				if (doAppointment.getId().equals(breachedFirstAppointmentsIds.get(i)))
				{
					if (reasonForBreach != null)
					{
						doAppointment.setReasonForBreachingFirstApptKPI(getDomLookup(reasonForBreach.getReason()));
						doAppointment.setCommentsForBreachingFirstApptKPI(reasonForBreach.getComment());
					}
					
					break;
				}
			}
		}
		
		if(Boolean.TRUE.equals(cancelAppointments))
		{	
			Booking_AppointmentRefVo appToBeCancelledVo = new Booking_AppointmentRefVo(doAppointment.getId(), doAppointment.getVersion());
			
			if (isTheatre && ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
			{
				
				CatsReferralListVo catsReferral = getCatsReferralForAppointment(appToBeCancelledVo);
				
				boolean providerCancellation =  true;
				boolean patientCancellation =   false;
				CancelAppointmentReason	cancelReason = cancellationReason != null ? new CancelAppointmentReason(cancellationReason.getId(), cancellationReason.getText(), cancellationReason.isActive()) : null;
				
				//WDEV-22845
				cancelTCIAndReferralEROD(catsReferral, appToBeCancelledVo, cancelReason, cancelComment, providerCancellation, patientCancellation, wasCancelledForNonMedicalReason(isTheatre, cancellationReason));
			}
			
			boolean hasTCI = doAppointment.getTheatreBooking() != null && hasAppointmentATciLinked(appToBeCancelledVo);
			cancelCaseNoteRequests(Booking_AppointmentVoAssembler.create(doAppointment),hasTCI);
			
			//add a cancelled
			cancelledStatus = new Appointment_Status();
			cancelledStatus.setApptDate(doCurrent.getApptDate());
			cancelledStatus.setApptTime(doCurrent.getApptTime());
			
			if (isTheatre)
				cancelledStatus.setComment("Move Theatre Session -  old appointment cancelled");
			else
				cancelledStatus.setComment("Move Outpatient Session -  old appointment cancelled");
			
			cancelledStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
			cancelledStatus.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
			cancelledStatus.setStatusChangeDateTime(new ims.framework.utils.DateTime().getJavaDate());
			cancelledStatus.setCancellationReason(cancellationReason);
			//WDEV-23185
			if (!isTheatre)
			{
				if (doAppointment.getSession() != null)
				{
					cancelledStatus.setSession(doAppointment.getSession());
				}
			} //WDEV-23185
			
			// WDEV-16523 
			if (cancelComment != null && cancelComment.length() >0)
			{
				if (isTheatre)
					cancelledStatus.setComment("Move Theatre Session -  old appointment cancelled \nComment: " + cancelComment.trim());
				else
					cancelledStatus.setComment("Move Outpatient Session -  old appointment cancelled \nComment: " + cancelComment.trim());
			}
			
					
			//add a booked
			bookedStatus = new Appointment_Status();
			
			if (toDate != null)
				bookedStatus.setApptDate(toDate.getDate());
			
			bookedStatus.setApptTime(doCurrent.getApptTime());
			
			if (isTheatre)
				bookedStatus.setComment("Move Theatre Session - new appointment Booked");
			else
				bookedStatus.setComment("Move Outpatient Session - new appointment Booked");
			
			bookedStatus.setStatus(getDomLookup(Status_Reason.BOOKED));
			bookedStatus.setStatusReason(getDomLookup(Status_Reason.BOOKED));
			bookedStatus.setStatusChangeDateTime(new ims.framework.utils.DateTime().getJavaDate());
			//WDEV-23185
			if (!isTheatre)
			{
				if (doAppointment.getSession() != null)
				{
					bookedStatus.setSession(doAppointment.getSession());
				}
			} //WDEV-23185
		
			if(doAppointment.getApptStatusHistory() != null)
			{		
				doAppointment.getApptStatusHistory().add(cancelledStatus);
				doAppointment.getApptStatusHistory().add(bookedStatus);
			}
		
			doAppointment.setApptStatus(getDomLookup(Status_Reason.BOOKED));
			doAppointment.setCurrentStatusRecord(bookedStatus);
		
		}
		
	}

	private boolean wasCancelledForNonMedicalReason(boolean isTheatre, LookupInstance cancellationReason)
	{
		
		DomainFactory factory = getDomainFactory();
			
		String hql = "select cr from CancellationTypeReason as cr left join cr.cancellationReason as cReason where cr.cancellationType = :cancelType and cReason.id = :reasonID";
			
			
		if (Boolean.TRUE.equals(isTheatre)) //Theatre Appointment
		{
			hql += " and cr.tCITheatre = 1 ";
		}
		else //Outpatient or Ward Attenders appointment
		{
			hql += " and cr.outpatients = 1 ";
		}
			
		List<?> cancelReasons = factory.find(hql, new String[]{"cancelType", "reasonID"}, new Object[]{getDomLookup(Status_Reason.HOSPITALCANCELLED), cancellationReason.getId()});
			
		if (cancelReasons == null || cancelReasons.isEmpty())
			return false;
			
		return  true;
	}
	
	//WDEV-22845
	private void cancelTCIAndReferralEROD(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo apptRef, CancelAppointmentReason cancellationReason, String cancellationComment, Boolean isProviderCancellation , Boolean isPatientCancellation, Boolean cancelledForNonmedicalReason) throws StaleObjectException //WDEV-18249
	{
		TheatreSessionManagement impl = (TheatreSessionManagement) getDomainImpl(TheatreSessionManagementImpl.class);
		impl.cancelTCIAndReferralEROD(catsReferral, apptRef, cancellationReason, cancellationComment, isProviderCancellation, isPatientCancellation, cancelledForNonmedicalReason);
	}
	
	private CatsReferralListVo getCatsReferralForAppointment(Booking_AppointmentRefVo appt)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provide for getCatsReferralForAppointment");
		
		DomainFactory factory = getDomainFactory();
		List catsRefId = factory.find("select catsRef.id from CatsReferral as catsRef left join catsRef.appointments as bookAppt where (bookAppt.id = '" + appt.getID_Booking_Appointment() + "')");
		if(catsRefId != null && catsRefId.size() > 0 && catsRefId.get(0) != null)
		{
			Integer val = (Integer) catsRefId.get(0);
			if(val != null && val.intValue() > 0)
			{
			//	return new CatsReferralRefVo(val, 0);//wdev-11902
				return CatsReferralListVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, val));//voReferralRef.getID_CatsReferral()));
			}
		}	
		return null;		
	}

	private boolean hasAppointmentATciLinked(Booking_AppointmentRefVo appt)
	{		
		String hql = "select count(appt.id) from TCIForPatientElectiveList as tci left join tci.appointment as appt where appt.id = :APPT_ID)";
		
		DomainFactory factory = getDomainFactory();
		
		long count = factory.countWithHQL(hql, new String[]{"APPT_ID"}, new Object[]{appt.getID_Booking_Appointment()});
		
		return count > 0;
	}
	
	private void cancelCaseNoteRequests(Booking_AppointmentVo appointment, boolean hasTCI) throws StaleObjectException
	{
		PatientCaseNoteRequestLiteVoCollection requestsForCancellation = getLinkedCaseNoteOpenRequests(appointment);
		
		if (requestsForCancellation == null || requestsForCancellation.size() == 0)
			return;
		
		Object mos = getMosUser();
		
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		
		for (int i = 0; i < requestsForCancellation.size(); i++)
		{
			CaseNoteRequestCancellationReason reqCancellationReason = hasTCI ? CaseNoteRequestCancellationReason.TCI_CANCELLED : CaseNoteRequestCancellationReason.APPOINTMENT_CANCELLED; //WDEV-20989
			impl.cancelRequest(requestsForCancellation.get(i), (MemberOfStaffRefVo) mos, reqCancellationReason);
		}
	}
	
	private PatientCaseNoteRequestLiteVoCollection getLinkedCaseNoteOpenRequests(Booking_AppointmentVo appointment)
	{
		if(appointment == null)
			   return null;
		
		List<?> list = getDomainFactory().find("select req from PatientCaseNoteRequest as req left join req.appointment as appt left join req.requestStatus as status " +
				"where (appt.id = :appointmentID and status.id = :requestStatusID)", new String[] {"appointmentID", "requestStatusID"}, new Object[] {appointment.getID_Booking_Appointment(), CaseNoteRequestStatus.OPEN.getID()});
		
		return PatientCaseNoteRequestLiteVoAssembler.createPatientCaseNoteRequestLiteVoCollectionFromPatientCaseNoteRequest(list);
	}
	
	/**
	* getSession
	*/
	public ims.scheduling.vo.SessionShortVo getSession(ims.scheduling.vo.Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method getSession");
		
		return SessionShortVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(session));
	}

	public Integer[] getBookedAppointmentIdsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method getBookedAppointmentIdsForSession");
		
		String hql = "select distinct appt.id from Booking_Appointment as appt left join appt.session as sess left join appt.apptStatus as lkpStatus where  (sess.id = " + session.getID_Sch_Session() + " and lkpStatus.id = " + Status_Reason.BOOKED.getID() + ")";
		
		Integer[] arrIds = null;
		List<Integer> ids = getDomainFactory().find(hql);
		if(ids != null && ids.size() > 0)
		{
			//arrIds = new Integer[ids.size()];
			arrIds = ids.toArray(new Integer[0]);
		}
		
		return arrIds;
	}

	public Integer countBookedAppointmentsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method countNonCancelledAppointmentsForSession");

		List lstCount = getDomainFactory().find("select count(appt.id) from Booking_Appointment appt where ( appt.isCABBooking is null or appt.isCABBooking = 0 ) and appt.session.id = " + session.getID_Sch_Session() + " and appt.apptStatus.id = " + Integer.valueOf(Status_Reason.BOOKED.getID()));

		int count = 0;
		if (lstCount != null)
		{
			Iterator it = lstCount.iterator();
			if (it.hasNext())
			{
				Long res = (Long) it.next();
				count = res.intValue();
			}
		}

		return count;
	}

	public List getFirstAppointmentsBreachDate(SessionShortVo session, Date moveToDate)
	{
		if (moveToDate == null)
			return null;
		
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("Cannot get Appointments on null sessionID");

		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String hql = "select appt.id from Booking_Appointment as appt left join appt.activity as activ left join appt.session as sess left join appt.apptStatus as appStatus where appt.firstApptKPIDate < :toDate and activ.firstAppointment = :isFirstAppt and sess.id = :sessionId and appStatus.id = :appointmentStatus " ;
		
		markers.add("toDate");
		values.add(moveToDate.getDate());
		
		markers.add("isFirstAppt");
		values.add(Boolean.TRUE);
		
		markers.add("sessionId");
		values.add(session.getID_Sch_Session());
		
		markers.add("appointmentStatus");
		values.add(Status_Reason.BOOKED.getID());
		
		List list = getDomainFactory().find(hql, markers, values);

		return list;
	}

	public LocationLiteVoCollection listActiveHospitals()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public LocationLiteVo getHospitalForCurrentLocation(LocationRefVo location)
	{
		if (location == null || location.getID_Location() == null)
			return null;

		DomainFactory factory = getDomainFactory();
		Location doLocation = (Location) factory.getDomainObject(Location.class, location.getID_Location());

		return getHospital(doLocation);
	}

	private LocationLiteVo getHospital(Location doLocation)
	{
		if (doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
		{
			return LocShortMappingsVoAssembler.create((LocSite) doLocation);
		}

		while (doLocation.getParentLocation() != null)
		{
			doLocation = doLocation.getParentLocation();

			if (doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			{
				return LocShortMappingsVoAssembler.create((LocSite) doLocation);
			}
		}

		return null;
	}
	
	public LocShortMappingsVoCollection listActiveTheatreLocationsForHospital(LocationRefVo location, String name)
	{
		if (location == null)
			return null;
		
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveLocationsForHospitalByName(location,new int[]{LocationType.THEATRE.getID(),LocationType.PROCEDURE_ROOM.getID()}, name);
	}

	public LocShortMappingsVoCollection listActiveOutpatientLocationsForHospital(LocationRefVo location, String name)
	{
		if (location == null)
			return null;
		
		OrganisationAndLocation impl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveLocationsForHospitalByName(location,new int[]{LocationType.CLINIC.getID(),LocationType.OUTPATIENT_DEPT.getID()}, name);
	}

}
